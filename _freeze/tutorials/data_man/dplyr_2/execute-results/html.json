{
  "hash": "466c8634b0193d0cf8a258eb115d39ca",
  "result": {
    "markdown": "---\ntitle: \"Chapter 3: Data manipulation using dplyr (part 2)\"\ndescription: \"Learn how to manipulate your data with the dplyr package\"\ndate: \"12/13/2021\"\nformat: html\nimage: images/dplyr1.png\ncategories: [dplyr, data wrangling]\nfilters:\n   - social-share\nshare:\n  permalink: \"https://one-carat-blog.netlify.app/tutorials/data_man/dplyr_2.html\"\n  description: \"Data manipulation using dplyr (part 2)\"\n  twitter: true\n  facebook: true\n  reddit: true\n  stumble: true\n  tumblr: true\n  linkedin: true\n  email: true\n---\n\n\n## Continuation from the previous chapter\n\nIn the [previous chapter](https://jeweljohnsonj.github.io/jeweljohnson.github.io/project5.html) we have seen quite a lot of functions from the `{dplyr}` package. In this chapter, we will see the rest of the functions where we learn how to handle row names, how to join columns and rows and different set operations in the `{dplyr}` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# loading necessary packages\nlibrary(dplyr)\n```\n:::\n\n\n### rownames_to_column() & column_to_rownames()\n\nTidy data does not use row names. So use `rownames_to_column()` command to convert row names to a new column to the data. The function `column_to_rownames()` does the exact opposite of `rownames_to_column()` as it converts a column into rownames but make sure that the column you are converting into rownames does not contain `NA` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mtcars dataset contains rownames\n# creates new column called car_names which contains row names\nmtcars %>% rownames_to_column(var = \"car_names\")\n\n# returns the original mtcars dataset\nmtcars %>% rownames_to_column(var = \"car_names\") %>%\n  column_to_rownames(var = \"car_names\")\n```\n:::\n\n\n## Combine tables/columns\n\n### bind_cols()\n\nJoins columns with other columns. Similar function as that of `cbind()` from base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tidytable::data.table(x = letters[1:5], y = c(1:5))\ndf2 <- tidytable::data.table(x = letters[3:7], y = c(6:10))\nbind_cols(df1,df2)\n\n#similar functionality\ncbind(df1,df2)\n```\n:::\n\n\n### bind_rows()\n\nJoins rows with other rows. Similar function as that of `rbind()` from base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tidytable::data.table(x = letters[1:5], y = c(1:5))\ndf2 <- tidytable::data.table(x = letters[3:7], y = c(6:10))\nbind_rows(df1,df2)\n\n#similar functionality\nrbind(df1,df2)\n```\n:::\n\n\nThe functions that are described below have the same functionality as that of `bind_cols()` but give you control over how the columns are joined.\n\n## Mutating joins and filtering joins\n\nMutating joins include `left_join()`, `right_join()`, `inner_join()` and `full_join()` and filtering joins include `semi_join()` and `anti_join()`.\n\n::: panel-tabset\n## left_join()\n\nIn the code below, matching variables of df2 are joined with df1. In the final data, you can see that only kevin and sam from df2 are matched with df1, and only those row values are joined with df1. For those variables which didn't get a match, the row values for those are filled with `NA`. You can interpret the variables with `NA` values as; both john and chris are not present in df2.\n\nIf you are familiar with set theory in mathematics, what we are doing essentially is similar to $(df1 \\cap df2) \\cup df1$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\ndf1 %>% left_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"john\",\"2\":\"1\",\"3\":\"NA\"},{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"chris\",\"2\":\"3\",\"3\":\"NA\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## right_join()\n\nSimilar to `left_join()` but here, you will be joining matching values from df1 to df2, the opposite of what we did earlier. As you can see only kevin and sam from the df1 is matched with df2, and only those row values are joined with df2. For the variables which didn't get a match, the row values for those are filled with `NA`. You can interpret the variables with `NA` values as; bob is not present in df1.\n\nThis function, in the manner used here, is similar to $(df1 \\cap df2) \\cup df2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\ndf1 %>% right_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"},{\"1\":\"bob\",\"2\":\"NA\",\"3\":\"12\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## inner_join()\n\nThe function `inner_join()` compares both df1 and df2 variables and only joins rows with the same variables. Here only kevin and sam are common in both the dataframes so the row values of only those columns are joined and others are omitted.\n\nThis function is similar to $df1 \\cap df2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\ndf1 %>% inner_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## full_join()\n\nThe function `full_join()` compares both df1 and df2 variables and joins all possible matches while retaining both mistakes in df1 and df2 with `NA` values.\n\nThis function is similar to $df1 \\cup df2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\ndf1 %>% full_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"john\",\"2\":\"1\",\"3\":\"NA\"},{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"chris\",\"2\":\"3\",\"3\":\"NA\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"},{\"1\":\"bob\",\"2\":\"NA\",\"3\":\"12\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## anti_join()\n\nThis is an example of filtering join. The function `anti_join()` compares df1 variables to and df2 variables and only outputs those variables of df1 which didn't get a match with df2.\n\nThis function, in the manner used here, is similar to $df1 \\cap df2^c$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\ndf1 %>% anti_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"john\",\"2\":\"1\"},{\"1\":\"chris\",\"2\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## semi_join()\n\nThis is an example of filtering join. The function `semi_join()` is similar to `inner_join()` but it only gives variables of df1 which has a match with df2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\n\ndf1 %>% semi_join(df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"kevin\",\"2\":\"2\"},{\"1\":\"sam\",\"2\":\"4\"},{\"1\":\"sam\",\"2\":\"5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nHere is a nice graphical representation of the functions we just described now. Image [source](https://rpubs.com/frasermyers/627597).\n\n::: {#fig-joins layout-ncol=\"2\"}\n![Mutating joins](images/joins.jpg){#fig-surus}\n\n![Filtering joins](images/joins1.jpg){#fig-hanno}\n\nGraphical abstract for joins. Image source: RPubs.com\n:::\n\n## Additional commands for joins\n\nAdditionally, you can specify which common columns to match.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\n\n# match with column 'x'\ndf1 %>% left_join(df2, by = \"x\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"john\",\"2\":\"1\",\"3\":\"NA\"},{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"chris\",\"2\":\"3\",\"3\":\"NA\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\ndf3 <- tidytable::data.table(a = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"), y = 1:5)\ndf4 <- tidytable::data.table(b = c(\"kevin\",\"sam\", \"bob\"), z = 10:12)\n\n# matching with column having different names, a and b in this case\ndf3 %>% left_join(df4, by = c(\"a\" = \"b\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"a\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"z\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"john\",\"2\":\"1\",\"3\":\"NA\"},{\"1\":\"kevin\",\"2\":\"2\",\"3\":\"10\"},{\"1\":\"chris\",\"2\":\"3\",\"3\":\"NA\"},{\"1\":\"sam\",\"2\":\"4\",\"3\":\"11\"},{\"1\":\"sam\",\"2\":\"5\",\"3\":\"11\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Set operations\n\nSimilar to the mutating join functions that we had seen, there are different functions related to set theory operations.\n\n### intersect()\n\nOutputs common rows in the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"))\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"))\n\nintersect(df1, df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"kevin\"},{\"1\":\"sam\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### setdiff()\n\nOutputs rows in first data frame but not in second data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"))\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"))\n\nsetdiff(df1, df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"john\"},{\"1\":\"chris\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### union()\n\nOutputs all the rows in both dataframes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"))\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"))\n\nunion(df1, df2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"john\"},{\"1\":\"kevin\"},{\"1\":\"chris\"},{\"1\":\"sam\"},{\"1\":\"bob\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### setequal()\n\nChecks whether two datasets have same number of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf1 <- tidytable::data.table(x = c(\"john\",\"kevin\",\"chris\",\"sam\",\"sam\"))\ndf2 <- tidytable::data.table(x = c(\"kevin\",\"sam\", \"bob\"))\n\nsetequal(df1, df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Summary\n\nIn this chapter, we have seen;\n\n::: incremental\n-   How to handle row names\n-   How to combine columns and rows\n-   What are mutating and filtering joins and various set operations\n:::\n\nThus to conclude this chapter, we have now learned almost all functions in the dplyr package and have seen how to manipulate data efficiently. With the knowledge of the pipe operator that we have seen in chapter 1, we are now equipped to write codes compactly and more clearly. I hope this chapter was useful for you and I will see you next time.\n\n## References\n\n1.  Hadley Wickham, Romain François, Lionel Henry and Kirill Müller (2021). dplyr: A Grammar of Data Manipulation. R package version 1.0.7. https://CRAN.R-project.org/package=dplyr. Here is the [link](https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf) to the cheat sheet explaining each and every function in `{dplyr}`.\n\n#### Last updated on {.unnumbered .unlisted .appendix}\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-11-01 14:21:36 IST\"\n```\n:::\n:::\n\n\n<a hidden href=\"https://info.flagcounter.com/ynrK\"><img src=\"https://s11.flagcounter.com/count2/ynrK/bg_000000/txt_FFFFFF/border_F0F0F0/columns_5/maxflags_25/viewers_0/labels_1/pageviews_1/flags_0/percent_0/\" alt=\"Flag Counter\" border=\"0\"/></a>\n",
    "supporting": [
      "dplyr_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}