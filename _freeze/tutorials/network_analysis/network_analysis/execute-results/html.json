{
  "hash": "6b302e0a236cbcf193c965532e511a7d",
  "result": {
    "markdown": "---\ntitle: \"Introduction to Network Analysis in R\"\ndescription: \"Learn to build and analyze network data using R\"\ndate: \"04/06/2023\"\ndate-modified: last-modified\ncode-annotations: select\nformat:\n  html:\n    css:\n      - https://cdn.knightlab.com/libs/juxtapose/latest/css/juxtapose.css\nimage: images/network_analysis.png\ncategories: [network analysis]\ndraft: true\nfilters:\n   - social-share\nshare:\n  permalink: \"https://one-carat-blog.netlify.app/tutorials/stat_model/network_analysis.html\"\n  description: \"Introduction to Network Analysis in R\"\n  twitter: true\n  facebook: true\n  reddit: true\n  stumble: true\n  tumblr: true\n  linkedin: true\n  email: true\n---\n\n\n:::{.callout-note}\n## TL;DR\n\nIn this article we will learn;\n\n1.    What is a network and what are the different ways to denote the network data?\n2.    How to convert the network data into an igraph object to analyze and plot the network via the `{igraph}` package in R.\n3.    What are vertex and edge attributes and how do we add them to the igraph object?\n4.    How do we filter network attributes and how to visualize them?\n5.    What are the different types of network visualizations?\n6.    What are directed networks?\n7.    What is path length?\n8.    What are the different measures of network structure?\n9.    What is network randomization test and what is its purpose?\n10.   what are the different network substructures?\n11.   How to identify special relationships in the network?\n12.   How to find communities in a network?\n13.   How to visualize the network in 3D using the `{threejs}` package\n\nWe will be using the `{igprah}` and `{threejs}` packages in this tutorial.\n:::\n\n## Introduction\n\nIn this tutorial, we will explore social networks and how to create and analyze them. A social network is a graphical representation of relationships between a group of individuals. For instance, the figure below shows a social network that could represent friendships among a group of people, bus routes to different locations in a city, or connections between different neurons.\n\n![A graph depicting a social network](images/social_network.png)\n\nIf we take a closer look at the figure, we can see that individual A has some kind of relationship with individuals B, C, and F, but not with D and E. The individuals, such as A, B, C, and so on, are called nodes or vertices, while the connections between them are known as lines, edges, or ties.\n\nNetwork data can be represented in different forms, such as an adjacency matrix or an edge list. The adjacency matrix for the network shown in the figure is provided below. In this matrix, each row and column corresponds to a vertex, and a value of 1 indicates the presence of an edge between the corresponding vertices.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for making the adjacency matrix for the above figure\"}\nif (!require(igraph)) install.packages('igraph')\nlibrary(igraph)\n\nname1 <- c(rep('a', 3), 'b', 'c', 'd')\nname2 <- c('b','c','f','d','e','e')\nrel <- data.frame(name1, name2)\nrel_ig <- graph_from_data_frame(rel)\nas_adjacency_matrix(rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 6 sparse Matrix of class \"dgCMatrix\"\n  a b c d f e\na . 1 1 . 1 .\nb . . . 1 . .\nc . . . . . 1\nd . . . . . 1\nf . . . . . .\ne . . . . . .\n```\n:::\n:::\n\n\nAlternatively, we can represent the same information in an edge list format, where all the edges in the network are listed in a 2x2 matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for making the edge list for the above figure\"}\nif (!require(igraph)) install.packages('igraph')\nlibrary(igraph)\n\nname1 <- c(rep('a', 3), 'b', 'c', 'd')\nname2 <- c('b','c','f','d','e','e')\nrel <- data.frame(name1, name2)\nrel_ig <- graph_from_data_frame(rel)\nas_edgelist(rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,] \"a\"  \"b\" \n[2,] \"a\"  \"c\" \n[3,] \"a\"  \"f\" \n[4,] \"b\"  \"d\" \n[5,] \"c\"  \"e\" \n[6,] \"d\"  \"e\" \n```\n:::\n:::\n\n\nThe edge list provided above displays each relationship or edge in the given social network through its rows. To gain a better understanding of how we can analyze and plot such data, let's work with a dataset resembling a real-life scenario.\n\n## Creating a dummy dataframe\n\nWe will work with a synthetic dataset consisting of 10 individuals and their relationships, gender, and weekly call duration. This will allow us to explore how social network analysis can be applied to real-life scenarios. The dataset includes friendships between individuals and other attributes such as gender and call duration. Below is the code used to generate this dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed for reproducibility\nset.seed(123)\n\n# Create a dataframe with 10 names and gender\ndf_names <- data.frame( # <1>\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Frank\",\n           \"Grace\", \"Henry\", \"Isabelle\", \"John\"),\n  gender = c(\"F\", \"M\", \"M\", \"M\", \"F\", \"M\", \"F\", \"M\", \"F\", \"M\")\n)\n\n# Create an empty dataframe to store the relationships\ndf_rel <- data.frame(name1 = character(), name2 = character(), # <2>\n                     call_hours = numeric()) \n\n# Generate random relationships with call hours\nwhile (nrow(df_rel) < 20) { # <3>\n  # Randomly select two names\n  name1 <- sample(df_names$name, 1) # <4>\n  name2 <- sample(df_names$name, 1)\n  \n  # Check if the selected names are the same or have already been added to the dataframe\n  if (name1 != name2 & !any((df_rel$name1 == name1 & df_rel$name2 == name2) | # <5>\n                            (df_rel$name1 == name2 & df_rel$name2 == name1))) { \n    # Add the relationship with a random number of call hours between 1 and 10\n    df_rel <- rbind(df_rel, data.frame(name1 = name1, name2 = name2, # <6>\n                                       call_hours = sample(1:10, 1))) \n  }\n}\n\n# Finally our dataset\ndf_rel # <7>\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"name1\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"name2\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"call_hours\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"John\",\"2\":\"Bob\",\"3\":\"6\"},{\"1\":\"Eve\",\"2\":\"David\",\"3\":\"6\"},{\"1\":\"Isabelle\",\"2\":\"John\",\"3\":\"5\"},{\"1\":\"Charlie\",\"2\":\"Isabelle\",\"3\":\"9\"},{\"1\":\"Henry\",\"2\":\"John\",\"3\":\"7\"},{\"1\":\"Charlie\",\"2\":\"David\",\"3\":\"1\"},{\"1\":\"Grace\",\"2\":\"Eve\",\"3\":\"10\"},{\"1\":\"Grace\",\"2\":\"Isabelle\",\"3\":\"9\"},{\"1\":\"John\",\"2\":\"Grace\",\"3\":\"5\"},{\"1\":\"Frank\",\"2\":\"Isabelle\",\"3\":\"2\"},{\"1\":\"Eve\",\"2\":\"Henry\",\"3\":\"2\"},{\"1\":\"Alice\",\"2\":\"Isabelle\",\"3\":\"9\"},{\"1\":\"Frank\",\"2\":\"Eve\",\"3\":\"9\"},{\"1\":\"John\",\"2\":\"David\",\"3\":\"6\"},{\"1\":\"Henry\",\"2\":\"Frank\",\"3\":\"6\"},{\"1\":\"Grace\",\"2\":\"Alice\",\"3\":\"6\"},{\"1\":\"Bob\",\"2\":\"Alice\",\"3\":\"2\"},{\"1\":\"Frank\",\"2\":\"Charlie\",\"3\":\"9\"},{\"1\":\"David\",\"2\":\"Frank\",\"3\":\"9\"},{\"1\":\"Charlie\",\"2\":\"Henry\",\"3\":\"9\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n1. First, the code creates a dataframe called df_names with 10 names and their genders.\n2. Then, an empty dataframe called df_rel is created to store the relationships.\n3. The while loop is used to generate random relationships between the names until df_rel has 20 rows.\n4. Inside the while loop, two names are randomly selected from the name column of df_names using the sample function.\n5. The if statement checks whether the two names are the same or whether they have already been added as a relationship to df_rel. If either of these conditions is true, the loop moves on to select a new pair of names.\n6. If the two names are different and have not been added to df_rel, a new row is added to df_rel with the selected names and a randomly generated number between 1 and 10 as the number of call hours.\n7. Once df_rel has 20 rows, the loop stops, and the final dataframe is printed using print(df_rel).\n\n## Converting dataframe to network data\n\nTo convert our dataframe into network data, we'll be using the {igraph} package in R and the graph.edgelist() function. However, before we can do that, we need to make sure that our dataframe is in the right format. The graph.edgelist() function requires a 2x2 edge list matrix, which means that our dataframe needs to be converted to a matrix using the as.matrix() function. For now, we'll also remove the call_hours column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installing and loading the igraph package\nif (!require(igraph)) install.packages('igraph')\nlibrary(igraph)\n\n# Creating an igraph object\ndf_rel_mx <- as.matrix(df_rel[,1:2])\ndf_rel_ig <- graph.edgelist(df_rel_mx, directed = F)\n\n# Viewing the igraph object\ndf_rel_ig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2495af4 UN-- 10 20 -- \n+ attr: name (v/c)\n+ edges from 2495af4 (vertex names):\n [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie \n [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   \n [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   \n[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   \n[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\n1.    In the first line of the output, the first number; 10 indicates that there are 10 vertices, and 20 means that there are 20 edges in the network.\n2.    Starting from the 4th line of the output, all the edges in the network are shown. These are relationships in the dataset.\n\nNow let us plot the network using the `plot()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(df_rel_ig)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nIn the above graph, each person is represented as a vertex, shown in blue. The edges between them indicate that they are friends with each other.\n\nThe `{igraph}` package provides various functions to further analyze the network data. For instance, we can use the `V()` function to view the vertices in the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing the nodes/vertices\nV(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 10/10 vertices, named, from 2495af4:\n [1] John     Bob      Eve      David    Isabelle Charlie  Henry    Grace   \n [9] Frank    Alice   \n```\n:::\n:::\n\n\nSimilarly, using the `E()` function returns all the edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing the edges\nE(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 20/20 edges from 2495af4 (vertex names):\n [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie \n [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   \n [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   \n[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   \n[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\nTo get the number of vertices we can use `gorder()` and for getting the number of edges we can use `gsize()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing the no. of vertices\ngorder(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\n# Viewing the no. of edges\ngsize(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\n## Network attributes\n\n### Vertex attributes\n\nLet us once again look at the igraph object output for the data we are using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing the igraph object\ndf_rel_ig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2495af4 UN-- 10 20 -- \n+ attr: name (v/c)\n+ edges from 2495af4 (vertex names):\n [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie \n [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   \n [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   \n[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   \n[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\nIn the second line of the output, we can see the attributes of the vertices. The network attributes can be either categorical or numerical. In this case, the attribute 'name' is a categorical variable denoting a person's name as vertices. Examples of numerical attributes include the age of an individual, the population of a city, or revenue of a company, etc.\n\nThe vertex attributes can be visualized using different shapes, colors, or sizes of the shape. To add a vertex attribute, we can use the `set_vertex_attr()` function. In the function arguments, we first input the igraph object, then the attribute name that we choose to give, which in this case would be 'gender', and finally the values for that attribute. Therefore, we use our df_names dataframe that we created before to fetch the gender data as the vertex attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Our dataframe with 10 names and gender\ndf_names <- data.frame(\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Frank\",\n           \"Grace\", \"Henry\", \"Isabelle\", \"John\"),\n  gender = c(\"F\", \"M\", \"M\", \"M\", \"F\", \"M\", \"F\", \"M\", \"F\", \"M\")\n)\n\n# Adding 'gender' as a vertex attribute\ndf_rel_ig_gender <- set_vertex_attr(df_rel_ig, \"gender\", value = df_names$gender)\n\n# Viewing the igraph object\ndf_rel_ig_gender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2495af4 UN-- 10 20 -- \n+ attr: name (v/c), gender (v/c)\n+ edges from 2495af4 (vertex names):\n [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie \n [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   \n [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   \n[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   \n[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\nIn the igraph object output, in the second line, you can see that a new vertex attribute called 'gender' has been added, which is denoted by 'gender (v/c)'.\n\n### Edge attributes\n\n\nSimilar to vertex attributes, edges can also convey different information. The common form of edge attribute is by changing the width of the line connecting the vertices. Therefore, we can convey information such as the number of bus routes between two places or the number of phone calls between two friends by changing the width size.\n\nIn our case, we can denote edge width to denote the call hours between two people. Similar to the previous case, we can use the set_edge_attr() function. The arguments for this function are similar to set_vertex_attr(), which we saw earlier.\n\nWe extract the call hour information from the df_rel dataframe that we created earlier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adding 'donations' as an edge attribute\ndf_rel_ig_call <- set_edge_attr(df_rel_ig, \"call_hours\",\n                                 value = df_rel$call_hours)\n\n# Viewing the igraph object\ndf_rel_ig_call\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2495af4 UN-- 10 20 -- \n+ attr: name (v/c), call_hours (e/n)\n+ edges from 2495af4 (vertex names):\n [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie \n [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   \n [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   \n[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   \n[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\nSimilar to the previous case, a new edge attribute called 'donations' have been added denoted by 'donations (e/n)'.\n\n### One-shot way to add attributes\n\nWe can use the `graph_from_data_frame()` function from the `{igraph}` package to create an igraph object directly if we have the vertex and edge information as separate dataframes. In the function arguments, the `d` parameter takes the edge list dataframe, where the first two columns contain the edges and the third column represents the edge attribute. Similarly, the vertices parameter takes the dataframe for vertex attributes, where the first column represents the vertices, and the remaining columns represent the vertex attributes.\n\nIn our case, we can use the `df_rel` dataframe for the d parameter, where the first two columns represent the edges, and the third column represents the call hours attribute. For the vertices parameter, we can use the `df_names` dataframe, where the first column represents the vertices (person names), and the second column represents the vertex attribute (gender). By using `graph_from_data_frame()` function, the vertex and edge attributes will be added to the igraph object automatically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adding the attributes\ndrug_ig_complete <- graph_from_data_frame(d = df_rel, vertices = df_names,\n                                 directed = F)\n\n# Viewing the igraph object\ndrug_ig_complete\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2501a55 UN-- 10 20 -- \n+ attr: name (v/c), gender (v/c), call_hours (e/n)\n+ edges from 2501a55 (vertex names):\n [1] Bob     --John     David   --Eve      Isabelle--John     Charlie --Isabelle\n [5] Henry   --John     Charlie --David    Eve     --Grace    Grace   --Isabelle\n [9] Grace   --John     Frank   --Isabelle Eve     --Henry    Alice   --Isabelle\n[13] Eve     --Frank    David   --John     Frank   --Henry    Alice   --Grace   \n[17] Alice   --Bob      Charlie --Frank    David   --Frank    Charlie --Henry   \n```\n:::\n:::\n\n\nWe can also use the functions; `vertex_attr()` to view the vertex attributes and `edge_attr()` to view edge attributes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing vertex attribute\nvertex_attr(drug_ig_complete)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n [1] \"Alice\"    \"Bob\"      \"Charlie\"  \"David\"    \"Eve\"      \"Frank\"   \n [7] \"Grace\"    \"Henry\"    \"Isabelle\" \"John\"    \n\n$gender\n [1] \"F\" \"M\" \"M\" \"M\" \"F\" \"M\" \"F\" \"M\" \"F\" \"M\"\n```\n:::\n\n```{.r .cell-code}\n# Viewing edge attribute\nedge_attr(drug_ig_complete)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$call_hours\n [1]  6  6  5  9  7  1 10  9  5  2  2  9  9  6  6  6  2  9  9  9\n```\n:::\n:::\n\n\n\n## Filtering attributes\n\nWith different attributes in the network, we can use different filters and see the data differently. Suppose we can want to see what all edges include \"John\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing all friends of John\nE(drug_ig_complete)[[.inc('John')]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 5/20 edges from 2501a55 (vertex names):\n       tail head tid hid call_hours\n1       Bob John   2  10          6\n3  Isabelle John   9  10          5\n5     Henry John   8  10          7\n9     Grace John   7  10          5\n14    David John   4  10          6\n```\n:::\n:::\n\n\nThe output shows all friends of John.\n\nLet us also check which friends call for more than 5 hours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Viewing relationships with call hours of more than 5 hours\nE(drug_ig_complete)[[call_hours > 5]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 14/20 edges from 2501a55 (vertex names):\n      tail     head tid hid call_hours\n1      Bob     John   2  10          6\n2    David      Eve   4   5          6\n4  Charlie Isabelle   3   9          9\n5    Henry     John   8  10          7\n7      Eve    Grace   5   7         10\n8    Grace Isabelle   7   9          9\n12   Alice Isabelle   1   9          9\n13     Eve    Frank   5   6          9\n14   David     John   4  10          6\n15   Frank    Henry   6   8          6\n16   Alice    Grace   1   7          6\n18 Charlie    Frank   3   6          9\n19   David    Frank   4   6          9\n20 Charlie    Henry   3   8          9\n```\n:::\n:::\n\n\nThere are 12 friendships where people call each other for more than 5 hours.\n\n## Visualizing the attributes\n\nThere are various ways to visualize both vertex and edge attributes in a network. For numerical attributes, we can change the size of the vertices and the width of the edges. For categorical attributes, we can change the color and shape of the vertices, and the line type and color of the edges.\n\n![Different ways to visualize network attributes](images/network_attributes.jpg)\n\n### Vertex attributes\n\nWith different attributes, we can also visualize them in the network graph in different ways. In the code given below, we assign color values to each of the vertices in the network depending on their gender. Here females will be coded as red and males as blue.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setting vertex color to gender\nV(drug_ig_complete)$color <- ifelse(V(drug_ig_complete)$gender == 'F', \"red\", \"blue\")\n\n# Plotting the network\nplot(drug_ig_complete, vertex.label.color = \"black\")\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### Edge attributes\n\nEdge attributes can be visualized in the network by changing the line type, color or by changing the width. In the code given below, we change the line width depending on the call hours between vertices (or friends).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extracting call_hours\ncall_hours <- E(drug_ig_complete)$call_hours\n\n# Plotting the network\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nIn the above graph, the line width is directly proportional to the call hours between the vertices. Higher line width corresponds to a greater number of call hours between friends.\n\n## Network Visualizations\n\nJust like how we can customize different network attributes, we can also change the way our network is visualized based on our data. For instance, if we are interested in sequential events or relationships between family members, then visualizing our network in a tree form would be better than the normal way. The `layout` argument in the `plot()` function can take different types of layout functions given in the `{igraph}` package, providing us with a range of ways to visualize our networks. To create a tree network, we can use the function `layout_as_tree()`. Below are some popular ways to visualize networks.\n\n::: {.panel-tabset}\n\n# Tree-like layout\n\nGood for showing hierarchical relations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in tree form\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_as_tree(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n# Circle\n\nPlace vertices on a circle, in the order of their vertex ids.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in circle form\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_in_circle(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n# DrL graph layout \n\nDrL is a force-directed graph layout toolbox focused on real-world large-scale graphs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in DrL graph layout\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_with_drl(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n# Fruchterman-Reingold layout\n\nPlace vertices on the plane using the force-directed layout algorithm by Fruchterman and Reingold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in Fruchterman-Reingold graph layout\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_with_fr(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n# Simple grid layout\n\nThis layout places vertices on a rectangular grid, in two or three dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in grid layout\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_on_grid(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n:::\n\nAlternatively, if we are unsure of which layout is best for the network at hand, we can use the function `layout_nicely()` which will assign the best layout automatically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting the graph in tree form\nplot(drug_ig_complete, vertex.label.color = \"black\", edge.color = 'grey',\n     edge.width = call_hours, layout = layout_nicely(drug_ig_complete))\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## Directed networks\n\nNetwork graphs can be either undirected or directed. Undirected graphs represent relationships between vertices as simply existing between them, whereas directed graphs indicate that the relationships have a direction. Examples of directed networks include disease outbreak data, family relationships, and school friendship networks.\n\nLet's create a dummy dataset to illustrate directed networks. We'll generate data on a disease outbreak that occurred in a community of 20 people.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code for making the dummy data\"}\n# Set seed for reproducibility\nset.seed(123)\n\n# create a data frame with two columns to store the information about the spread of the disease\ninfection_df <- data.frame(Infected=character(), Infected_By=character(), stringsAsFactors=FALSE)\n\n# set the number of infected people\nnum_infected <- 20\n\n# initialize the first infected person\ninfected <- c(\"Patient Zero\")\n\n# Loop over the remaining infected people and add them to the data frame\nfor (i in 1:num_infected) {\n  # randomly choose the person infected by the current infected person\n  infected_by <- sample(infected, 1)\n  \n  # add the currently infected person and the person infected by them to the data frame\n  infection_df <- rbind(infection_df, data.frame(Infected=paste(\"Person\", i),\n                                                 Infected_By=infected_by, stringsAsFactors=FALSE))\n  \n  # add the currently infected person to the list of infected people\n  infected <- c(infected, paste(\"Person\", i))\n}\n\n# Interchanging the columns\ninfection_df <- infection_df[, c(\"Infected_By\", \"Infected\")]\n\n# print the first few rows of the resulting data frame\nhead(infection_df)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"Infected_By\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Infected\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"Patient Zero\",\"2\":\"Person 1\",\"_rn_\":\"1\"},{\"1\":\"Patient Zero\",\"2\":\"Person 2\",\"_rn_\":\"2\"},{\"1\":\"Person 2\",\"2\":\"Person 3\",\"_rn_\":\"3\"},{\"1\":\"Person 1\",\"2\":\"Person 4\",\"_rn_\":\"4\"},{\"1\":\"Person 2\",\"2\":\"Person 5\",\"_rn_\":\"5\"},{\"1\":\"Person 1\",\"2\":\"Person 6\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThe dataframe `infection_df` contains data on 21 individuals (20 people and 1 patient zero). The infection starts with patient zero, which then spreads across the community. The dataframe has two columns: \"Infected_By\" indicates the person who is transmitting the disease, and \"Infected\" shows the person who is getting infected by that transmission.\n\nNow, let's plot the above dataframe as a network graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# create a graph object from the dataframe\ngraph <- graph_from_data_frame(infection_df, directed=TRUE)\n\n# plot the graph\nplot(graph, vertex.label.color=\"black\", vertex.size=10, vertex.label.cex=0.7,\n     edge.arrow.size=0.5, main=\"Disease Transmission Network\")\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nA notable difference from earlier graphs we have seen is that the edges now have an arrowhead indicating their direction. In the graph, the central node is \"Patient Zero\", who is the first infected person in the community. The vertex \"Patient Zero\" has two outgoing edges, one going to \"Person 1\" and the other to \"Person 2\". The arrowheads navigate us to show how the infection starting from \"Patient Zero\" infected the whole community. The `directed=TRUE` argument in the `graph_from_data_frame()` function tells R to create a directed igraph object. We can also check if a network is directed by using the `is.directed()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# create a graph object from the dataframe\ngraph <- graph_from_data_frame(infection_df, directed=TRUE)\n\n# print output\ngraph\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2741fe9 DN-- 21 20 -- \n+ attr: name (v/c)\n+ edges from 2741fe9 (vertex names):\n [1] Patient Zero->Person 1  Patient Zero->Person 2  Person 2    ->Person 3 \n [4] Person 1    ->Person 4  Person 2    ->Person 5  Person 1    ->Person 6 \n [7] Person 1    ->Person 7  Person 5    ->Person 8  Person 4    ->Person 9 \n[10] Person 3    ->Person 10 Person 5    ->Person 11 Person 8    ->Person 12\n[13] Person 9    ->Person 13 Person 10   ->Person 14 Person 4    ->Person 15\n[16] Person 2    ->Person 16 Person 8    ->Person 17 Person 2    ->Person 18\n[19] Person 7    ->Person 19 Person 6    ->Person 20\n```\n:::\n:::\n\n\nIn the first line of the output, 'DN' stands for 'Directed Network', for undirected networks it will be 'UN' which we have seen before. We can also use the function `is.directed()` to check if the network is directed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# create a graph object from the dataframe\ngraph <- graph_from_data_frame(infection_df, directed=TRUE)\n\n# checking if it's directed or not\nis.directed(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Identifying edges\n\nSuppose we want to see if there is a disease transmission between person 2 and person 10. To check this we can use the following code;\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# checking if an edge exists between person 2 and person 10\ngraph['Person 2', 'Person 10']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\nThe function returned 0, this means that there is no edge between the vertices that we were interested in. The function returns 1 if there exists an edge.\n\nWe can also see which edges go out from a vertex and go in into the vertex using the `incident()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# printing all edged going out from patient zero\nincident(graph, 'Patient Zero', mode = c(\"out\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 2/20 edges from 274d1ce (vertex names):\n[1] Patient Zero->Person 2 Patient Zero->Person 1\n```\n:::\n:::\n\nFrom the output, we can see that patient zero infects person 1 and person 2.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# printing all edges coming into person 3\nincident(graph, 'Person 3', mode = c(\"in\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 1/20 edge from 274d1ce (vertex names):\n[1] Person 2->Person 3\n```\n:::\n:::\n\nFrom the output, we can see that person 3 was infected by person 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# printing all edges connected to person 5\nincident(graph, 'Person 5', mode = c(\"all\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 3/20 edges from 274d1ce (vertex names):\n[1] Person 2->Person 5  Person 5->Person 8  Person 5->Person 11\n```\n:::\n:::\n\nFrom the output we can see that person 5 was infected by person 2 and thereafter person 5 goes on to infect person 8 and person 11.\n\nWe can also use the `head_of()` function to return the set of vertices that are at the beginning of the edges in the input. It gives the list of people who infected others.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# printing all vertices that are connected to an edge\nhead_of(graph, E(graph))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 20/21 vertices, named, from 274d1ce:\n [1] Person 1  Person 2  Person 3  Person 4  Person 5  Person 6  Person 7 \n [8] Person 8  Person 9  Person 10 Person 11 Person 12 Person 13 Person 14\n[15] Person 15 Person 16 Person 17 Person 18 Person 19 Person 20\n```\n:::\n:::\n\nHere, patient zero is not included in the output because it is not connected to any edges in the graph. The `head_of()` function returns only the vertices that are connected to edges in the graph, and since patient zero does not have any outgoing edges, it is not included in the output.\n\n### Identifying the neighbors\n\nTo track the spread of a pandemic in a small community, we need to identify the individuals who were infected by patient zero. This can be accomplished by identifying the immediate neighbors of patient zero using the `neighbors()` function.\n\nHere's an example of how we can find the infected neighbors in R using the `neighbors()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the neighbors of patient zero\nneighbors(graph, 'Patient Zero', mode = c(\"all\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 2/21 vertices, named, from 274d1ce:\n[1] Person 2 Person 1\n```\n:::\n:::\n\nWe can also see which neighbors are common for a particular vertex using the `intersect()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding neighbors of person 1 \nx <- neighbors(graph, 'Person 1', mode = c('all'))\n\n# finding neighbors of person 2\ny <- neighbors(graph, 'Person 2', mode = c('all'))\n\n# finding common neighbors between person 1 and person 2\nintersection(x,y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 1/21 vertex, named, from 274d1ce:\n[1] Patient Zero\n```\n:::\n:::\n\n\n### Path length (Geodesic distance)\n\nA measure to see how well a network is connected is to look at the length of the edges between all pairs of vertices. The length between a vertex and its immediate neighbor will be 1 and this is called path length or also known as geodesic distance. In our network graph, from patient zero to person 1, one connection is required to traverse, which means that the path length between them is 1. Between person 7 and patient zero the path length is 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a graph object from the dataframe\ngraph <- graph_from_data_frame(infection_df, directed=TRUE)\n\n# plot the graph\nplot(graph, vertex.label.color=\"black\", vertex.size=10, vertex.label.cex=0.7,\n     edge.arrow.size=0.5, main=\"Disease Transmission Network\")\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\nA good way to see how deep the infection has traversed, we have to see the longest path in the network. This longest path is called the diameter of the network. To get the diameter of the network we can use the function `farthest_vertices()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the longest path in the network\nfarthest_vertices(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vertices\n+ 2/21 vertices, named, from 27a8589:\n[1] Patient Zero Person 12   \n\n$distance\n[1] 4\n```\n:::\n:::\n\nTo see how the connections between patient zero and person 12 make up the longest path in the network we can use the function `get_diameter()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the longest path in the network\nget_diameter(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 5/21 vertices, named, from 27a8589:\n[1] Patient Zero Person 2     Person 5     Person 8     Person 12   \n```\n:::\n:::\n\nTo calculate the geodesic distances of all vertices from a particular vertex, we can use the function `distances()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding geodesic distances of all vertices from the vertex 'Patient Zero'\ndistances(graph, \"Patient Zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Patient Zero Person 2 Person 1 Person 5 Person 4 Person 3 Person 8\nPatient Zero            0        1        1        2        2        2        3\n             Person 9 Person 10 Person 7 Person 6 Person 11 Person 12 Person 13\nPatient Zero        3         3        2        2         3         4         4\n             Person 14 Person 15 Person 16 Person 17 Person 18 Person 19\nPatient Zero         4         3         2         4         2         3\n             Person 20\nPatient Zero         3\n```\n:::\n:::\n\nFrom the output, we can see how distance each vertex is away from patient zero. Person 1 and Person 2 seem to be immediate targets of disease transmission starting from patient zero and persons 12,13,14 and person 17 were the last people to be infected in the whole community.\n\nWe can also identify vertices that are reachable with N steps from a vertex of interest. Suppose we want to know vertices from patient zero that are reachable within 2 connections or 2 steps. We can use the `ego()` function for this task.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding vertices that are at min. 2 edges away from patient zero\nego(graph, 2, 'Patient Zero', mode = c('all'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 10/21 vertices, named, from 27a8589:\n [1] Patient Zero Person 2     Person 1     Person 5     Person 3    \n [6] Person 16    Person 18    Person 4     Person 7     Person 6    \n```\n:::\n:::\n\n\nLet us plot the network to visualize how far each vertex is from 'Patient Zero'. First we use `make_ego_graph()` function to get a sub-graph containing all neighbors of Patient Zero which is reachable within the diameter of the network. This essentially includes all vertices that are connected to Patient Zero. Then we calculate the distances of vertices from Patient Zero. The diameter of this network is 4, but we add 4+1 colors, as 'Patient Zero' has zero distance, we suggest 5 colors so that 'Patient Zero' has its color. In the final plot, we have vertex labels to denote the geodesic distances from Patient Zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# Make an ego graph\ngraph_ego <- make_ego_graph(graph, diameter(graph), nodes = 'Patient Zero', mode = c(\"all\"))[[1]]\n\n# Get a vector of geodesic distances of all vertices from vertex Patient Zero \ndists <- distances(graph_ego, \"Patient Zero\")\n\n# Create a color palette of length equal to the maximal geodesic distance plus one.\ncolors <- c(\"black\", \"red\", \"orange\", \"blue\", \"dodgerblue\")\n\n# Set color attribute to vertices of network graph_ego\nV(graph_ego)$color <- colors[dists+1]\n\n# Visualize the network based on geodesic distance from patient zero.\nplot(graph_ego, \n     vertex.label = dists, \n     vertex.label.color = \"white\",\n     vertex.label.cex = .6,\n     edge.color = 'black',\n     vertex.size = 15,\n     edge.arrow.size = .05,\n     main = \"Geodesic Distances from Patient Zero\"\n)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n## Measures of network structure\n\n### Degree\n\nDegree describes how many edges a vertex has. In undirected networks, the degree of a vertex is simply the sum of edges connecting that vertex. But for directed networks, since we have some edges going out from a vertex and some edges going into the same vertex, we essentially have out-degrees and in-degrees. The figure given below illustrates this.\n\n![In-degrees and Out-degrees](images/degree.png)\n\nVertices with a high number of connections or with a high degree can be important. We can check the degrees of all vertices with the `degree()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the degrees of all vertices in the network\ndegree(graph, mode = ('all'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 \n           2            5            4            3            3            2 \n    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 \n           3            2            2            2            2            1 \n   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 \n           1            1            1            1            1            1 \n   Person 18    Person 19    Person 20 \n           1            1            1 \n```\n:::\n:::\n\nFrom the results we can see that person 2 and person 1 have high degrees which suggests that they are important in the network. Essentially, person 1 and person 2 jump-started the infection in the community.\n\n### Betweenness\n\nThis is an index of how frequently the vertex lies on the shortest paths between any two vertices in the network. It can be thought of as how critical the vertex is to the flow of information through a network. Individuals with high betweenness are key bridges between different parts of a network. We can calculate the betweenness of each vertices using the `betweenness()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the betweenness of all vertices in the network\nbetweenness(graph, directed = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 \n           0           10            8            8            6            4 \n    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 \n           6            3            3            2            2            0 \n   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 \n           0            0            0            0            0            0 \n   Person 18    Person 19    Person 20 \n           0            0            0 \n```\n:::\n:::\n\nFrom the output, person 2 has the most number of nodes branching outwards followed by person 1 and person 5. This might suggest that person 1, person 2, and person 5 might be playing an important role in spreading the disease.\n\nWe can also use the `nromalized = T` argument to get the normalized betweenness values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the betweenness of all vertices in the network\nbetweenness(graph, directed = T, normalized = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 \n 0.000000000  0.026315789  0.021052632  0.021052632  0.015789474  0.010526316 \n    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 \n 0.015789474  0.007894737  0.007894737  0.005263158  0.005263158  0.000000000 \n   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 \n 0.000000000  0.000000000  0.000000000  0.000000000  0.000000000  0.000000000 \n   Person 18    Person 19    Person 20 \n 0.000000000  0.000000000  0.000000000 \n```\n:::\n:::\n\n\n### Eigenvector centrality\n\nCentrality is a measure of an individual vertexe's structural importance in a group based on its network position. Vertices with high eigenvector centrality are those that are connected to many other vertices but also to vertices that are themselves highly connected to other vertices. Eigenvector centrality can be calculated using the function `eigen_centrality()`. The function returns many other values also, but for now we are just focusing on the centrality value which is saved as `vector` in the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the eigenvector centrality of all vertices in the network\neigen_centrality(graph)$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 \n  0.64109893   1.00000000   0.62990379   0.63313313   0.37411961   0.48145630 \n    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 \n  0.36061817   0.17408817   0.22403489   0.29311159   0.29311159   0.24903370 \n   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 \n  0.14184391   0.06847505   0.08812086   0.14715450   0.39333544   0.14184391 \n   Person 18    Person 19    Person 20 \n  0.39333544   0.11529118   0.11529118 \n```\n:::\n:::\n\n\nHere in the output, Person 1,2,5, and patient zero are highly influential vertices in the network.\n\nWe can also plot the network with eigenvector centrality as a vertex size attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Saving eigenvector centrality values\ngraph_eigen_vector <- eigen_centrality(graph)$vector\n\n# plotting the network\nplot(graph,\n     vertex.label.color = \"black\",\n     vertex.label.cex = 0.6,\n     vertex.size = 25*(graph_eigen_vector),\n     edge.color = 'grey',\n     main = \"Disease Outbreak Network\")\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n### Density\n\nDensity is the simplest way of measuring the overall structure of the network. Density is the proportion of edges that do exist in a network out of all those that potentially could exist between every pair of vertices in the network. A density value of 1 would suggest all possible vertices are present in the network, which would also mean that the network is highly interconnected. To calculate the density we use the function `edge_density()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the density of the network\nedge_density(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.04761905\n```\n:::\n:::\n\nThe value ~ 0.05 (approximately) suggests that 5% of the total possible vertices are present in our network.\n\n### Average path length\n\nThe average path length is the mean of the lengths of the shortest paths between all pairs of vertices in the network. We can use the function `mean_distance()` to the graph and instruct the function whether the graph is undirected or directed to find the value. Lower values of average path length suggest that the network is highly interconnected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the average path length of the network\nmean_distance(graph, directed = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.981132\n```\n:::\n:::\n\n\n## Network randomization test\n\nSo far, we have seen the different kinds of measures used to determine the overall structure of the network. To check if the obtained value is unique to the network data at hand, we randomize our network data and calculate measures of network structure and compare them with the real values. To randomize our network, we use the function `erdos.renyi.game()`, which uses a particular algorithm to generate networks with a set probability of creating edges between the vertices in the network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generating a random network graph\nerdos.renyi.game(n = gorder(graph), p.or.m = edge_density(graph), type = 'gnp')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 287b122 U--- 21 8 -- Erdos-Renyi (gnp) graph\n+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)\n+ edges from 287b122:\n[1]  4-- 5  2-- 9 12--13  1--16 15--16 14--19 13--20  4--21\n```\n:::\n:::\n\n\nHere we specify the number of vertices (given by `n = gorder(graph)`) and the probability of a given edge being connected between any two vertices, given by the argument `p.or.m = edge_density(graph)`. The `type = 'gnp'` argument tells R that the graph has ‘n’ vertices, and for each edge, the probability that it is present in the graph is ‘p’.\n\nLet us calculate the average path length for this randomized network that we just created.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setting seed for reproducibility\nset.seed(123)\n\n# generating a random network graph\nrandom_graph <- erdos.renyi.game(n = gorder(graph), p.or.m = edge_density(graph), type = 'gnp')\n\n# finding the average length of the random network\nmean_distance(random_graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.904762\n```\n:::\n:::\n\nFrom the result, we can see that the average path length is slightly less than our original average path length. However, this is not enough to conclude that the original value we got is different from the random value. Therefore, let us repeat this randomization 1000 times, calculate the average path length each time, and check how many networks are greater or lesser than the average path length we originally calculated. This way, we can confidently say whether our original value is particularly different from that of the random values. This process is called a network randomization test. In summary, a randomization test tells us whether the features of our original network are particularly unusual or not.\n\nSo the pipeline that we will be following for network randomization is the following:\n\n\n```{mermaid}\n%%{init: {'theme': 'default'}}%%\ngraph TD\n    A[Generating 1000 random networks with the same number of vertices and with a similar edge density as that of the original network]\n    B[Calculate the average path length of the original network]\n    C[Calculate the average path length for all 1000 randomly generated networks]\n    D[Determine how many random networks are greater than or less than the average path length of the original network]\n    A-->B\n    B-->C\n    C-->D\n```\n\n\nNow let us calculate generate and calculate the average path length for 1000 random networks. We are using the `graph` igraph object which we created last time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed for reproducibility\nset.seed(123)\n\n# generating an empty list with 1000 entries\nlist_empty <- vector('list', 1000) # <1>\n\n# generating 1000 random networks and saving them in the empty list\nfor(i in 1:1000){ # <2>\n  list_empty[[i]] <- erdos.renyi.game(n = gorder(graph), p.or.m = edge_density(graph),\n                              type = \"gnp\")\n}\n\n# Calculate the average path length of 1000 random graphs\nlist_empty_avg_path <- unlist(lapply(list_empty, mean_distance, directed = T)) # <3>\n```\n:::\n\n1. First we generate an empty list with 1000 `NULL` entries which we will be using to store our 1000 random networks.\n2. The for loop generates 1000 random networks using the Erdős-Rényi model with the same number of vertices and edge density as the original network (which is got from the `graph` object, which we had saved earlier). The networks are then saved in the empty list created in the previous step.\n3. This line uses the `lapply()` function to apply the `mean_distance()` function to each element in the `list_empty` list, which calculates the average path length for each of the 1000 random networks. The `unlist()` function is used to convert the resulting list of average path lengths into a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the distribution of average path lengths\nhist(list_empty_avg_path) \nabline(v = average.path.length(graph, directed = T), col = \"red\", lty = 3, lwd = 2)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the proportion of graphs with an average path length lower than our observed\nmean(list_empty_avg_path < average.path.length(graph, directed = T)) # <4>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.534\n```\n:::\n:::\n\n4. The above code generates a histogram of the distribution of average path lengths for the 1000 random networks using the `hist()` function. The second line adds a vertical line at the average path length of the original network using the `abline()` function. Finally, the last line calculates the proportion of random networks that have an average path length less than that of the original network using the `mean()` function. The comparison is done using the `<` operator and the `average.path.length()` function calculates the average path length of the original network.\n\nFrom the histogram we can see that our original average path length, which is represented as a red dotted vertical line lies among the randomly generate list average path length. The high interconnectedness we observe in our original data may be due to random chance alone.\n\n## Network substructures\n\nUntil now we have looked at features that describe the network structure. In this section, we will learn about microstructural features of social networks that can be informative as to how a network functions.\n\n### Triangles (triads)\n\nIn a network, a triangle is a collection of three nodes (or vertices) that are all connected. A high number of triangles in a network indicates that nodes tend to be highly interconnected, forming dense clusters or communities. In contrast, a low number of triangles suggests that nodes are more sparsely connected and less likely to form tightly-knit groups.\n\nWe can use the function `triangles()` to show all the triangles in the network. Let us the `df_rel_ig` igraph object that we created at the beginning of this tutorial.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the network\nplot(df_rel_ig)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# show all triangles in the network.\nmatrix(triangles(df_rel_ig), nrow = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,]    1    5    5    9    9    9    9\n[2,]    5    8    9    3    3    4    6\n[3,]    8   10    6    4    7    6    7\n```\n:::\n\n```{.r .cell-code}\n# counting triangles with Isabelle as the vertex\ncount_triangles(df_rel_ig, vids= 'Isabelle')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nThere are 3 triangles with Isabelle as the vertex.\n\n### Transitivity\n\nThe number of triangles in a network can be quantified using a metric called the clustering coefficient (transitivity). The clustering coefficient of a node is defined as the fraction of pairs of the node's neighbors that are connected by an edge.\n\nGlobal transitivity (also known as the global clustering coefficient) is a measure of the proportion of triangles in the entire network. It is the ratio of the total number of triangles in a network to the total number of possible triangles. High global transitivity indicates that the nodes in the network are highly interconnected, forming tightly-knit clusters.\n\nTo calculate the global transitivity, we can use the function `transitivity()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculating global transitivity \ntransitivity(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.328125\n```\n:::\n:::\n\nThe value 0.32 means that 32% of the total possible triangles are represented in the given network.\n\nLocal transitivity (also known as local clustering coefficient) is a measure of the transitivity of individual nodes or small groups of nodes in the network. It is the proportion of triangles that exist among the neighbors of a given node to the total number of possible triangles among those neighbors. A high local transitivity indicates that a node's neighbors are highly interconnected, forming a cluster or clique, while a low local transitivity suggests that the node's neighbors are not well-connected to each other.\n\nTo calculate the local transitivity, we again use the function `transitivity()` but also include the following arguments to specify the individual vertex (`vids = `) and also specify that we want to calculate the local transitivity (`type = 'local'`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculating local transitivity around Isabelle\ntransitivity(df_rel_ig, vids = 'Isabelle', type = 'local')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3\n```\n:::\n:::\n\nThe value 0.3 means that, 30% of the total possible triangles with Isabelle as a vertex is represented in the given network.\n\n\nIn summary, global transitivity measures the extent of clustering in the entire network, while local transitivity measures the extent of clustering around individual nodes or small groups of nodes in the network.\n\n### Cliques\n\nA clique is a subset of nodes in a network where each node is directly connected to every other node in the subset. In other words, a clique is a fully connected subgraph, where every node in the subset has a direct edge to every other node in the subset.\n\nWe can use the `largest_cliques()` function to find the largest clique in the network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding the largest clique in the network\nlargest_cliques(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Alice    Isabelle Grace   \n\n[[2]]\n+ 3/10 vertices, named, from 2495af4:\n[1] David Frank Eve  \n\n[[3]]\n+ 3/10 vertices, named, from 2495af4:\n[1] David   Frank   Charlie\n\n[[4]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Isabelle Frank    Charlie \n\n[[5]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Isabelle John     Grace   \n\n[[6]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Henry Frank Eve  \n\n[[7]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Henry   Frank   Charlie\n```\n:::\n:::\n\nThere are 7 cliques tied with 3 vertices.\n\nWe can use `max_cliques()` function to showcase the biggest cliques for each number of vertexes (min. 2 vertices are required for a clique) \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# finding maximum cliques\nmax_cliques(df_rel_ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 2/10 vertices, named, from 2495af4:\n[1] Bob   Alice\n\n[[2]]\n+ 2/10 vertices, named, from 2495af4:\n[1] Bob  John\n\n[[3]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Alice    Isabelle Grace   \n\n[[4]]\n+ 3/10 vertices, named, from 2495af4:\n[1] David Frank Eve  \n\n[[5]]\n+ 3/10 vertices, named, from 2495af4:\n[1] David   Frank   Charlie\n\n[[6]]\n+ 2/10 vertices, named, from 2495af4:\n[1] David John \n\n[[7]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Isabelle Frank    Charlie \n\n[[8]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Isabelle John     Grace   \n\n[[9]]\n+ 2/10 vertices, named, from 2495af4:\n[1] John  Henry\n\n[[10]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Henry Frank Eve  \n\n[[11]]\n+ 3/10 vertices, named, from 2495af4:\n[1] Henry   Frank   Charlie\n\n[[12]]\n+ 2/10 vertices, named, from 2495af4:\n[1] Grace Eve  \n```\n:::\n:::\n\n\n![Network substructures](images/network_structure.png)\nThe figure given above illustrates a network featuring both closed and open triangles. In the figure, A-K-F, A-K-B, E-G-L are some of the closed triangles in the networks, similarly, J-H-I, E-G-J, E-A-H are open triangles with only two edges, H-I,C and F-C,H are open triangles with only one edge and E,J,I and H,E,C are some of the open triangles with no edges. Here A-C-F-K forms a clique. It should also be noted that a clique of size 3 (3 vertices) is a triangle.\n\n## Identifying special relationships\n\nIn this section, we will further explore the partitioning of networks into sub-networks and determine which vertices are more highly related to one another than others. We will also develop visualization methods by creating three-dimensional visualizations.\n\n### Assortativity\n\nLet us take our initial dataset. In this dataset, we have illustrated the relationships between 20 people. One of the interesting questions that we can ask about this network is whether individuals preferably make friends with the same gender or with their same age groups. This is determined by the measure called 'Assortativity'. Assortativity in network analysis refers to the tendency of nodes in a network to be connected to other nodes with similar properties or characteristics. In other words, nodes in an assortative network tend to be connected to other nodes that are like them in some way, such as having similar degrees, attributes, or other characteristics. In our networks, people might be preferably chosen to be in a relationship with other people who are of the same gender or age group.\n\nThe function to calculate the assortativity of a network is `assortativity()`. This function takes in two arguments, first is the igraph object and second is the attribute that is common among the vertices. In our dataset, let us use gender as the common attribute. If the common attribute is numeric, then we can directly input the values, but if it's categorical we have to first change it into numeric factor. In our case, we have to change the values of M and F to 0 and 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setting gender as the vertex attribute\ndf_rel_ig_gender <- set_vertex_attr(df_rel_ig, \"gender\", value = df_names$gender)\n\n# plotting our network\nplot(df_rel_ig_gender)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# converting gender values to numeric values\ngender_value <- as.numeric(factor(V(df_rel_ig_gender)$gender))\n\n# calculating the assortativity\nassortativity(df_rel_ig_gender, gender_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.1027569\n```\n:::\n:::\n\nAssortativity value ranges from -1 to 1. A value of -1 means that the vertices actively avoid forming relationships with similar vertices, 0 means that the vertices have no preferences in making connections and 1 means that the vertices actively like to form relationships with similar vertices. Here, we have a value of -0.1 which is approximately close to zero, which means the vertices form relationships with each other irrespective of their gender.\n\n### Assortativity degree\n\nAnother similar value is the assortativity degree. It refers to the extent to which nodes in a network tend to be connected to other nodes with similar degrees. It measures the correlation between the degrees of connected nodes in a network and can be quantified using the degree assortativity coefficient.\n\nThe degree assortativity coefficient ranges from -1 to 1, with values close to 1 indicating a highly assortative network, where nodes with high degrees tend to be connected to other nodes with high degrees, and nodes with low degrees tend to be connected to other nodes with low degrees. Values close to -1 indicate a disassortative network, where high-degree nodes tend to be connected to low-degree nodes and vice versa. Finally, a value close to 0 indicates a random network, where there is no particular correlation between the degrees of connected nodes.\n\nWe can use the function `assortativity.degree()` to calculate the assortativity degree.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculating the assortativity degree\nassortativity.degree(df_rel_ig_gender, directed = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.01639344\n```\n:::\n:::\n\nWe have a value of 0.01 which is again close to 0, which means that the vertices in our network do not care about the degree of other vertices while forming connections.\n\n### Reciprocity\n\nReciprocity in networks refers to the extent to which pairs of nodes in a network have mutual connections. In other words, if node A is connected to node B and node B is also connected to node A, then there is reciprocity between the two nodes.\n\nReciprocity can be measured using the reciprocity coefficient, which is the ratio of the number of reciprocated edges (i.e., edges that connect two nodes that are mutually connected) to the total number of edges in the network. The reciprocity coefficient ranges from 0 to 1, with higher values indicating a greater degree of reciprocity in the network.\n\nReciprocity is an important concept in network analysis because it can have significant implications for the structure and dynamics of networks. Networks with high levels of reciprocity tend to have stronger ties between nodes and be more densely connected, while networks with low levels of reciprocity tend to be more sparsely connected and have weaker ties between nodes.\n\nReciprocity can be calculated using the function `reciprocity()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculating the reciprocity\nreciprocity(df_rel_ig_gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\nSince our original graph object is undirected, we get the value 1.\n\n## Community detection\n\nNetworks sometimes form clusters or communities where a group of vertices with similar attributes form close connections compared to others. This is referred to as community defection. Community detection in network analysis refers to the process of identifying groups or clusters of nodes that are densely connected within a larger network. These groups are often referred to as communities, clusters, or modules, and can provide insights into the organization and function of the network.\n\nThere are many algorithms to identify communities in a network. We will be looking at two of them; greedy optimization algorithm (`cluster_fast_greedy()`) and Girvan-Newman algorithm (`cluster_edge_betweenness()`).\n\nThe greedy optimization algorithm iteratively merges nodes or communities in the network to maximize the modularity of the resulting partition. Modularity is a measure of the density of edges within communities compared to the expected density of edges in a randomized network. Maximizing modularity is a common criterion for community detection in networks because it reflects the degree to which the network is organized into cohesive and densely connected communities. The greedy optimization algorithm starts with each node in its community and iteratively merges the most similar communities until the modularity of the resulting partition can no longer be increased.\n\nThe Girvan-Newman algorithm iteratively removes the edges with the highest betweenness centrality in the network, which are the edges that are most frequently traversed by the shortest paths between pairs of nodes in the network. The removal of these edges gradually breaks the network into smaller and smaller clusters or communities. It is widely used for community detection in complex networks because it is relatively fast and can detect communities of varying sizes and shapes.\n\n### Fast-greedy community detection\n\nUsing the `cluster_fast_greedy()` function let us find if there exist any communities in our dataset `df_rel_ig_gender`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform fast-greedy community detection on the network graph\nfg = cluster_fast_greedy(df_rel_ig_gender)\n```\n:::\n\n\nUsing the `sizes()` function, we can see the number of members in each of the communities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determine the sizes of each community\nsizes(fg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCommunity sizes\n1 2 \n6 4 \n```\n:::\n:::\n\nThe output shows that Community 1 has 6 members and Community 2 has 4 members.\n\nThe `membership()` function shows to which community each of the members belongs to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determine which individuals belong to which community\nmembership(fg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    John      Bob      Eve    David Isabelle  Charlie    Henry    Grace \n       1        1        1        2        1        2        2        1 \n   Frank    Alice \n       2        1 \n```\n:::\n:::\n\n\nTo plot the community structure, we can simply use input from the 'communities' object that we have created using the algorithm function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the community structure of the network\nplot(fg, df_rel_ig_gender)\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n\n### Edge-betweenness community detection\n\nSimilar to the earlier case, we use the `cluster_edge_betweenness ()` function to find the communities in our dataset `df_rel_ig_gender`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform edge-betweenness community detection on the network graph\neb = cluster_edge_betweenness(df_rel_ig_gender)\n\n# Determine sizes of each community\nsizes(eb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCommunity sizes\n1 2 3 \n3 2 5 \n```\n:::\n:::\n\nThe output shows that Community 1 has 3 members community 2 has 2 members and Community 3 has 5 members.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determine which individuals belong to which community\nmembership(eb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    John      Bob      Eve    David Isabelle  Charlie    Henry    Grace \n       1        2        3        3        1        3        3        1 \n   Frank    Alice \n       3        2 \n```\n:::\n:::\n\n\nLet us now compare both graphs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plotting both graphs side-wise\npar(mfrow = c(1, 2))\nplot(fg, df_rel_ig_gender, main= \"Fast-greedy\")\nplot(eb, df_rel_ig_gender, main= \"Edge-betweenness\")\n```\n\n::: {.cell-output-display}\n![](network_analysis_files/figure-html/unnamed-chunk-67-1.png){width=672}\n:::\n:::\n\n\nIn general, the cluster-fast greedy algorithm is faster and more scalable than the cluster_edge_betweenness algorithm and is a good choice for large networks with many nodes and edges. It can detect communities of varying sizes and shapes and is less sensitive to noise.\n\nOn the other hand, the cluster edge betweenness algorithm is more computationally expensive and may be more appropriate for smaller networks. It can also be useful for identifying communities that are not well-separated or that overlap with each other.\n\n## Interactive network visualizations\n\nOne of the coolest things about network analysis is the visualization process. Up until now, we have only plotted static graphs. In this section, we will plot networks that can be physically (with a mouse pointer) interacted with using the `{threejs}` package in R. We will only cover the basics of 3D visualization.\n\nPlotting the graph is as simple as using the function `graphjs()` from the `{threejs}` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(threejs)) install.packages('threejs')\nlibrary(threejs)\n\n# plotting our previous network\ngraphjs(df_rel_ig_gender)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"scatterplotThree html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"L8kJrngjMw\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"L8kJrngjMw\">{\"x\":{\"NROW\":10,\"height\":null,\"width\":null,\"axis\":false,\"numticks\":[6,6,6],\"xticklabs\":null,\"yticklabs\":null,\"zticklabs\":null,\"color\":[\"#FFA500\"],\"size\":2,\"stroke\":\"black\",\"flipy\":true,\"grid\":false,\"renderer\":\"auto\",\"signif\":8,\"bg\":\"white\",\"cexsymbols\":1,\"xlim\":[-1,1],\"ylim\":[-1,1],\"zlim\":[-1,1],\"axisscale\":[1,1,1],\"pch\":[\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\"],\"elementId\":\"L8kJrngjMw\",\"from\":[[0,2,0,4,0,3,2,4,0,4,2,4,2,0,6,7,1,5,3,5]],\"to\":[[1,3,4,5,6,5,7,7,7,8,6,9,8,3,8,9,9,8,8,6]],\"lwd\":1,\"linealpha\":1,\"center\":true,\"main\":[\"\"],\"options\":true,\"alpha\":[1],\"vertices\":[[-0.48000535,0.050334145,-0.43971801,-1,-0.89020335,-1,1,0.67698797,-0.26050653,0.15855213,1,0.20097958,0.15411788,-0.25009526,0.40362007,-0.3851331,0.53220685,1,-0.4215466,0.72446446,0.05080441,0.76990088,-0.25336217,-0.48621616,0.54187606,0.58589198,0.69405843,0.12555554,-1,-0.38494864]],\"xticklab\":[\"-1.00\",\"-0.60\",\"-0.20\",\"0.20\",\"0.60\",\"1.00\"],\"yticklab\":[\"-1.00\",\"-0.60\",\"-0.20\",\"0.20\",\"0.60\",\"1.00\"],\"zticklab\":[\"1.00\",\"0.60\",\"0.20\",\"-0.20\",\"-0.60\",\"-1.00\"],\"xtick\":[0,0.2,0.4,0.6,0.8,1],\"ytick\":[0,0.2,0.4,0.6,0.8,1],\"ztick\":[0,0.2,0.4,0.6,0.8,1],\"axislength\":[1,1,1]},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\nWe can finally move our networks!\n\nLet us re-plot the network we got after using the fast-greedy community algorithm. Since the size of the network is 2, we denote two colors to represent each of the two communities. You can also hover over the vertices to display its name on top.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(threejs)\n\n# Perform fast-greedy community detection on network graph\nfg = cluster_fast_greedy(df_rel_ig_gender)\n\n# Create an object 'i' containing the memberships of the fast-greedy community detection\ni <-  membership(fg)\n\n# Check the number of different communities\nsize_fg <- sizes(fg)\n\n# Add a color attribute to each vertex, setting the vertex color based on community membership\ng <- set_vertex_attr(df_rel_ig_gender, \"color\", value = c(\"yellow\", \"blue\")[i])\n\n# Plot the graph using threejs\ngraphjs(g, vertex.label = df_names$name)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"scatterplotThree html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"KRQh8YnEss\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"KRQh8YnEss\">{\"x\":{\"NROW\":10,\"height\":null,\"width\":null,\"axis\":false,\"numticks\":[6,6,6],\"xticklabs\":null,\"yticklabs\":null,\"zticklabs\":null,\"color\":[[\"#FFFF00\",\"#FFFF00\",\"#FFFF00\",\"#0000FF\",\"#FFFF00\",\"#0000FF\",\"#0000FF\",\"#FFFF00\",\"#0000FF\",\"#FFFF00\"]],\"size\":2,\"stroke\":\"black\",\"flipy\":true,\"grid\":false,\"renderer\":\"auto\",\"signif\":8,\"bg\":\"white\",\"cexsymbols\":1,\"xlim\":[-1,1],\"ylim\":[-1,1],\"zlim\":[-1,1],\"axisscale\":[1,1,1],\"pch\":[\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\",\"@\"],\"elementId\":\"KRQh8YnEss\",\"from\":[[0,2,0,4,0,3,2,4,0,4,2,4,2,0,6,7,1,5,3,5]],\"to\":[[1,3,4,5,6,5,7,7,7,8,6,9,8,3,8,9,9,8,8,6]],\"lwd\":1,\"linealpha\":1,\"center\":true,\"main\":[\"\"],\"labels\":[\"Alice\",\"Bob\",\"Charlie\",\"David\",\"Eve\",\"Frank\",\"Grace\",\"Henry\",\"Isabelle\",\"John\"],\"options\":true,\"alpha\":[[1,1,1,1,1,1,1,1,1,1]],\"vertices\":[[-0.57488598,-0.034397014,-0.60417951,-0.79258009,1,-1,0.84281947,-0.75627011,-0.46899491,-0.21869611,-1,0.012123607,0.18791091,0.17498352,0.52810042,-0.84453286,-0.62833068,1,-1,-0.73242732,-0.13251548,1,0.21183803,-0.50057129,0.27437144,-0.72179706,0.6405584,0.54006203,0.99029912,-0.21659124]],\"xticklab\":[\"-1.00\",\"-0.60\",\"-0.20\",\"0.20\",\"0.60\",\"1.00\"],\"yticklab\":[\"-1.00\",\"-0.60\",\"-0.20\",\"0.20\",\"0.60\",\"1.00\"],\"zticklab\":[\"1.00\",\"0.60\",\"0.20\",\"-0.20\",\"-0.60\",\"-1.00\"],\"xtick\":[0,0.2,0.4,0.6,0.8,1],\"ytick\":[0,0.2,0.4,0.6,0.8,1],\"ztick\":[0,0.2,0.4,0.6,0.8,1],\"axislength\":[1,1,1]},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\nWith that, we have successfully learned the basics of network analysis using R.\n\n## Conclusion\n\nIn short, we learned about;\n\n1.    What is a network and what are the different ways to denote the network data?\n2.    How to convert the network data into an igraph object to analyze and plot the network via the `{igraph}` package in R.\n3.    What are vertex and edge attributes and how do add them to the igraph object?\n4.    How do filter attributes and how can we visualize them?\n5.    What are the different types of network visualizations?\n6.    What are directed networks?\n7.    What is path length?\n8.    What are the different measures of network structure?\n9.    What is network randomization test and why is its purpose?\n10.   what are the different network substructures?\n11.   How to identify special relationships in the network?\n12.   How to find communities in a network?\n13.   How to visualize the network in 3D using the `{threejs}` package ?\n\nThis tutorial is made from my note while attending the 'Network Analysis in R' course in DataCamp. There are bound to be mistakes in this tutorial and some of the things which I have written are from my understanding of the topic which might not reflect accurately what the correct notion about the topic is, therefore if you come across mistakes, please comment on them below in the comments section. I am more interested to learn the 3D visualization techniques which I find to be super cool. If I would learn some of that I will be writing a sequel to this tutorial. Thank you!\n\n\n<a hidden href=\"https://info.flagcounter.com/ynrK\"><img src=\"https://s11.flagcounter.com/count2/ynrK/bg_000000/txt_FFFFFF/border_F0F0F0/columns_5/maxflags_25/viewers_0/labels_1/pageviews_1/flags_0/percent_0/\" alt=\"Flag Counter\" border=\"0\"/></a>\n",
    "supporting": [
      "network_analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\r\n<script src=\"../../site_libs/jquery-3.5.1/jquery.min.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/three.min.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/Detector.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/Projector.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/CanvasRenderer.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/TrackballControls.js\"></script>\r\n<script src=\"../../site_libs/threejs-111/StateOrbitControls.js\"></script>\r\n<script src=\"../../site_libs/scatterplotThree-binding-0.3.3/scatterplotThree.js\"></script>\r\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\r\n<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}