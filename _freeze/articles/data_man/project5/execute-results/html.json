{
  "hash": "2ca8583823d6499654a3bf06f14500d2",
  "result": {
    "markdown": "---\ntitle: \"Chapter 1: Data tidying using tidyr\"\nsubtitle: |\n  Learn how to make your data tidy with the tidyr package.\nauthor: \"Jewel Johnson\"\ndate: \"12/11/2021\"\nformat:\n  html:\n    toc: true\n    toc-title: On this page\n    html-math-method: katex\n    css: styles.css\n    number-sections: true\n    smooth-scroll: true\n    highlight-style: github\n    code-link: true\n    code-fold: true\n    code-tools: true\ncitation: true\ncomments:\n  hypothesis: true\nexecute: \n  warning: false\n  freeze: auto\nimage: \"images/tidyr.png\"\n---\n\n\n## Introduction to tidyr package\n\nRaw data might not be always in a usable form for any form of analysis or visualization process. The `{tidyr}` package aims to help you in reshaping your data in a usable form. In short, it helps you to 'tidy' up your data using various tools. In this chapter, we will see how you can use the `{tidyr}` package to make your data tidy.\n\n## What is tidy data?\n\nFirst, we need to understand what tidy data looks like. For that let us imagine a scenario where you are a doctor who is trying to find the best treatment for a disease. Now your colleagues have short-listed five different treatment methods and have reported their efficacy values when tested with five different patients. Now you are tasked with finding which of the five treatments is the best against the disease. You open your computer and you find the following data of the experiment.\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"trt\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient1\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient2\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient3\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient4\"],\"name\":[5],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient5\"],\"name\":[6],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"treatment1\",\"2\":\"1\",\"3\":\"6\",\"4\":\"11\",\"5\":\"16\",\"6\":\"21\"},{\"1\":\"treatment2\",\"2\":\"2\",\"3\":\"7\",\"4\":\"12\",\"5\":\"17\",\"6\":\"22\"},{\"1\":\"treatment3\",\"2\":\"3\",\"3\":\"8\",\"4\":\"13\",\"5\":\"18\",\"6\":\"23\"},{\"1\":\"treatment4\",\"2\":\"4\",\"3\":\"9\",\"4\":\"14\",\"5\":\"19\",\"6\":\"24\"},{\"1\":\"treatment5\",\"2\":\"5\",\"3\":\"10\",\"4\":\"15\",\"5\":\"20\",\"6\":\"25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThis is how often data is stored because it is easy to write it this way. In the first column, you can see the different treatments from one to five. And in the second column, you have the efficacy values of the treatments for patient 1 and it goes on for the other patients. Now, this is a good example of how a dataset should not look like! Surprised? Let us see what makes this dataset 'dirty'.\n\nYou can quickly notice that there is no mentioning of what these numerical values mean. Of course, we know that they are efficacy values for the different treatments. But for someone who only has this data as a reference, that person would not have a clue as to what these numbers mean. Also, note that each of the rows contains multiple observation values which is not a feature of tidy data. This kind of data format is called 'wide data' which we will talk more about later.\n\nWith that being said, tidy data will have;\n\n1.  Each of its variables represented in its own column\n2.  Each observation or a case in its own row.\n3.  Each of the rows will contain only a single value.\n\nSo let us see how the 'tidier' version of this data would look like.\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"treatment\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient_ID\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"efficacy\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"treatment1\",\"2\":\"patient1\",\"3\":\"1\"},{\"1\":\"treatment1\",\"2\":\"patient2\",\"3\":\"6\"},{\"1\":\"treatment1\",\"2\":\"patient3\",\"3\":\"11\"},{\"1\":\"treatment1\",\"2\":\"patient4\",\"3\":\"16\"},{\"1\":\"treatment1\",\"2\":\"patient5\",\"3\":\"21\"},{\"1\":\"treatment2\",\"2\":\"patient1\",\"3\":\"2\"},{\"1\":\"treatment2\",\"2\":\"patient2\",\"3\":\"7\"},{\"1\":\"treatment2\",\"2\":\"patient3\",\"3\":\"12\"},{\"1\":\"treatment2\",\"2\":\"patient4\",\"3\":\"17\"},{\"1\":\"treatment2\",\"2\":\"patient5\",\"3\":\"22\"},{\"1\":\"treatment3\",\"2\":\"patient1\",\"3\":\"3\"},{\"1\":\"treatment3\",\"2\":\"patient2\",\"3\":\"8\"},{\"1\":\"treatment3\",\"2\":\"patient3\",\"3\":\"13\"},{\"1\":\"treatment3\",\"2\":\"patient4\",\"3\":\"18\"},{\"1\":\"treatment3\",\"2\":\"patient5\",\"3\":\"23\"},{\"1\":\"treatment4\",\"2\":\"patient1\",\"3\":\"4\"},{\"1\":\"treatment4\",\"2\":\"patient2\",\"3\":\"9\"},{\"1\":\"treatment4\",\"2\":\"patient3\",\"3\":\"14\"},{\"1\":\"treatment4\",\"2\":\"patient4\",\"3\":\"19\"},{\"1\":\"treatment4\",\"2\":\"patient5\",\"3\":\"24\"},{\"1\":\"treatment5\",\"2\":\"patient1\",\"3\":\"5\"},{\"1\":\"treatment5\",\"2\":\"patient2\",\"3\":\"10\"},{\"1\":\"treatment5\",\"2\":\"patient3\",\"3\":\"15\"},{\"1\":\"treatment5\",\"2\":\"patient4\",\"3\":\"20\"},{\"1\":\"treatment5\",\"2\":\"patient5\",\"3\":\"25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nYou can see each of the columns represent only one type of variable. In the first column, you have the types of treatments, followed by patient IDs and their efficacy values for each treatment. Also, note that each row represents only one observation. So this kind of data format is what we strive to achieve by using the `{tidyr}` package and they are called as 'long data'. So let us begin!\n\n## Reshaping dataset\n\nThere are different sets of commands which you can utilize to reshape your data and make it tidy. Let us each of these commands in action. But first, make sure you have the `{tidyr}` package loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load tidyr package\nlibrary(tidyr)\n```\n:::\n\n\n### pivot_longer()\n\nThe `pivot_longer()` command converts a 'wide data' to a 'long data'. It does so by converting row names to a new column under a new variable name with its corresponding values moved into another column with another variable name. So let us see how it goes. We will take the earlier mentioned example and will see how to make it tidy. Now you don't have to be concerned with the codes I have used to make the dummy data. Just have your focus on the `pivot_longer()` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n# making a dummy data\n# using sample function to pick random numbers in a sequence\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\n\n# cbind simple combines the columns of same size\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \n\ntrt <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\n\ntrt_data <- cbind(trt, treatment_data)\ntrt_data <- as.data.frame(trt_data) # making it a data frame\n\ntrt_data_tidy <- pivot_longer(trt_data,\n                              c(patient1,patient2,patient3,patient4,patient5), \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\nrmarkdown::paged_table(trt_data_tidy)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"trt\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient_ID\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"efficacy\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"treatment1\",\"2\":\"patient1\",\"3\":\"1\"},{\"1\":\"treatment1\",\"2\":\"patient2\",\"3\":\"6\"},{\"1\":\"treatment1\",\"2\":\"patient3\",\"3\":\"11\"},{\"1\":\"treatment1\",\"2\":\"patient4\",\"3\":\"16\"},{\"1\":\"treatment1\",\"2\":\"patient5\",\"3\":\"21\"},{\"1\":\"treatment2\",\"2\":\"patient1\",\"3\":\"2\"},{\"1\":\"treatment2\",\"2\":\"patient2\",\"3\":\"7\"},{\"1\":\"treatment2\",\"2\":\"patient3\",\"3\":\"12\"},{\"1\":\"treatment2\",\"2\":\"patient4\",\"3\":\"17\"},{\"1\":\"treatment2\",\"2\":\"patient5\",\"3\":\"22\"},{\"1\":\"treatment3\",\"2\":\"patient1\",\"3\":\"3\"},{\"1\":\"treatment3\",\"2\":\"patient2\",\"3\":\"8\"},{\"1\":\"treatment3\",\"2\":\"patient3\",\"3\":\"13\"},{\"1\":\"treatment3\",\"2\":\"patient4\",\"3\":\"18\"},{\"1\":\"treatment3\",\"2\":\"patient5\",\"3\":\"23\"},{\"1\":\"treatment4\",\"2\":\"patient1\",\"3\":\"4\"},{\"1\":\"treatment4\",\"2\":\"patient2\",\"3\":\"9\"},{\"1\":\"treatment4\",\"2\":\"patient3\",\"3\":\"14\"},{\"1\":\"treatment4\",\"2\":\"patient4\",\"3\":\"19\"},{\"1\":\"treatment4\",\"2\":\"patient5\",\"3\":\"24\"},{\"1\":\"treatment5\",\"2\":\"patient1\",\"3\":\"5\"},{\"1\":\"treatment5\",\"2\":\"patient2\",\"3\":\"10\"},{\"1\":\"treatment5\",\"2\":\"patient3\",\"3\":\"15\"},{\"1\":\"treatment5\",\"2\":\"patient4\",\"3\":\"20\"},{\"1\":\"treatment5\",\"2\":\"patient5\",\"3\":\"25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nFurthermore, you don't have to manually type in the column names as you can use `colnames()` to call the column names of the dataset. Another way of doing the same is by excluding the first column from the process. By doing so the command will automatically pivot all columns except the excluded ones, so in this way, we don't need to manually specify the column names. The codes given below will give you the same result as before.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \ntreatment <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\ntrt_data <- cbind(treatment, treatment_data)\ntrt_data <- as.data.frame(trt_data)\n# using colnames, [-1] is included to exclude the name of first column from the process\ntrt_data_tidy1 <- pivot_longer(trt_data,\n                              colnames(trt_data)[-1], \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\n\n# the same can be done by manually specifying which columns to exclude\n# this can be done by denoting the column name ('treatment' in this case) with '-' sign\ntrt_data_tidy2 <- pivot_longer(trt_data, names_to = \"patient_ID\",\n                               values_to = \"efficacy\", -treatment)\n# checking if both the tidy datasets are one and the same\ntrt_data_tidy1 == trt_data_tidy2\n```\n:::\n\n\nThe syntax for `pivot_longer()` is given below with description\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(\"data\", c(\"colname1, colname2,.....\"), \n  names_to = \"name of the column where your row names are present\",\n  values_to = \"name of the column where your corresponding row values are present\")\n```\n:::\n\n\nHere is a graphical representation\n\n![](images/pivot_longer().png)\n\n### pivot_wider()\n\nThe `pivot_wider()` does the exact opposite of what `pivot_longer()` does, which is to convert long data into wide data. We will use the previously given dummy data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n# making a dummy data\n# using sample function to pick random numbers in a sequence\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\n\n# cbind simple combines the columns of same size\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \n\ntrt <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\n\ntrt_data <- cbind(trt, treatment_data)\ntrt_data <- as.data.frame(trt_data) # making it a data frame\n\ntrt_data_tidy <- pivot_longer(trt_data,\n                              c(patient1,patient2,patient3,patient4,patient5), \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\n\n# making the data wide\ntrt_data_wider <- pivot_wider(trt_data_tidy, names_from = \"patient_ID\",\n                              values_from = \"efficacy\")\n\n# paged_Table() for viewing the dataset as a table, \n# you can see that the dataset is same as before\nrmarkdown::paged_table(trt_data_wider)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"trt\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient1\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient2\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient3\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient4\"],\"name\":[5],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"patient5\"],\"name\":[6],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"treatment1\",\"2\":\"1\",\"3\":\"6\",\"4\":\"11\",\"5\":\"16\",\"6\":\"21\"},{\"1\":\"treatment2\",\"2\":\"2\",\"3\":\"7\",\"4\":\"12\",\"5\":\"17\",\"6\":\"22\"},{\"1\":\"treatment3\",\"2\":\"3\",\"3\":\"8\",\"4\":\"13\",\"5\":\"18\",\"6\":\"23\"},{\"1\":\"treatment4\",\"2\":\"4\",\"3\":\"9\",\"4\":\"14\",\"5\":\"19\",\"6\":\"24\"},{\"1\":\"treatment5\",\"2\":\"5\",\"3\":\"10\",\"4\":\"15\",\"5\":\"20\",\"6\":\"25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThe syntax for `pivot_wider()` is given below with description\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(\"data\", \n  names_from = \"name of the column which contains your wide data columns\",\n  values_from = \"name of the column where your corresponding wide data column values are\")\n```\n:::\n\n\nHere is a graphical representation\n\n![](images/pivot_wider().png)\n\n## Splitting and uniting cells\n\nThere can be an instance where you want to split or untie cells within your dataset. Let us look at some examples.\n\n### unite()\n\nIn the data given below, let say we want to unite the century column and the year column together. This can be done using the `unite()` command. You can view the before and after instances in the tabs below.\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nevent <- c(letters[1:4])\ncentury <- c(rep(19:20, each = 2))\nyear <- c(seq(10,16,2))\ndata <- as.data.frame(cbind(event,century,year))\n\nrmarkdown::paged_table(data)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"century\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"19\",\"3\":\"10\"},{\"1\":\"b\",\"2\":\"19\",\"3\":\"12\"},{\"1\":\"c\",\"2\":\"20\",\"3\":\"14\"},{\"1\":\"d\",\"2\":\"20\",\"3\":\"16\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nevent <- c(letters[1:4])\ncentury <- c(rep(19:20, each = 2))\nyear <- c(seq(10,16,2))\ndata <- as.data.frame(cbind(event,century,year))\n\n# uniting columns century and year\ndata_new <- unite(data, century, year, col = \"event_year\", sep = \"\")\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"event_year\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"1910\"},{\"1\":\"b\",\"2\":\"1912\"},{\"1\":\"c\",\"2\":\"2014\"},{\"1\":\"d\",\"2\":\"2016\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nThe syntax of `unite()` is as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunite(\"dataset name\",\n      \"name of first column to unite, name of second column to unite,.......\",\n      col = \"name of the new column to which all the other column will unite together\",\n      sep = \"input any element as a separator between the joining column values\")\n# in this case we are not putting a sep value\n```\n:::\n\n\n### separate()\n\nIn the data given below, let say we want to split the 'area_perimeter' column into two separate columns. This can be done using the `separate()` command. You can view the before and after instances in the tabs below. As always I will be making dummy data to work with.\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"shapes\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"area_perimetre\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"10m^2_30m\"},{\"1\":\"b\",\"2\":\"11m^2_31m\"},{\"1\":\"c\",\"2\":\"12m^2_32m\"},{\"1\":\"d\",\"2\":\"13m^2_33m\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n\n# separating column values into two separate columns named area and perimeter respectively\ndata_new <- separate(data, area_perimetre, sep = \"_\",\n                     into = c(\"area\", \"perimetre\"))\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"shapes\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"area\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"perimetre\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"10m^2\",\"3\":\"30m\"},{\"1\":\"b\",\"2\":\"11m^2\",\"3\":\"31m\"},{\"1\":\"c\",\"2\":\"12m^2\",\"3\":\"32m\"},{\"1\":\"d\",\"2\":\"13m^2\",\"3\":\"33m\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nThe syntax of `separate()` is as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate(\"data name\",\n         \"column to separate into\",\n         sep = \"the separator element\",\n         into = c(\"col1\", \"col2\", \"........\")) # column names for the separated values\n```\n:::\n\n\n### separate_rows()\n\nSimilar to the above case, you can also separate column values into several rows.\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"shapes\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"area_perimetre\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"10m^2_30m\"},{\"1\":\"b\",\"2\":\"11m^2_31m\"},{\"1\":\"c\",\"2\":\"12m^2_32m\"},{\"1\":\"d\",\"2\":\"13m^2_33m\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n\n# separating column values into two several rows\ndata_new <- separate_rows(data, area_perimetre, sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"shapes\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"area_perimetre\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"10m^2\"},{\"1\":\"a\",\"2\":\"30m\"},{\"1\":\"b\",\"2\":\"11m^2\"},{\"1\":\"b\",\"2\":\"31m\"},{\"1\":\"c\",\"2\":\"12m^2\"},{\"1\":\"c\",\"2\":\"32m\"},{\"1\":\"d\",\"2\":\"13m^2\"},{\"1\":\"d\",\"2\":\"33m\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nThe syntax of `separate_rows()` is as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate_rows(\"data name\",\n         \"column to separate\",\n         sep = \"the separator element\")\n```\n:::\n\n\n## Expanding and completing dataset\n\nYou can expand your data to include all possible combinations of values of variables listed or complete the dataset with `NA` values for all possible combinations.\n\n### expand()\n\nUsing the `expand()` command we can expand our data with missing combinations for the variables we specify.\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# expanding dataset with brand and dress as variables\ndress_data_expand <- expand(dress_data, brand, dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_expand)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\"},{\"1\":\"a\",\"2\":\"pant\"},{\"1\":\"a\",\"2\":\"shirt\"},{\"1\":\"a\",\"2\":\"trousers\"},{\"1\":\"b\",\"2\":\"jeans\"},{\"1\":\"b\",\"2\":\"pant\"},{\"1\":\"b\",\"2\":\"shirt\"},{\"1\":\"b\",\"2\":\"trousers\"},{\"1\":\"c\",\"2\":\"jeans\"},{\"1\":\"c\",\"2\":\"pant\"},{\"1\":\"c\",\"2\":\"shirt\"},{\"1\":\"c\",\"2\":\"trousers\"},{\"1\":\"d\",\"2\":\"jeans\"},{\"1\":\"d\",\"2\":\"pant\"},{\"1\":\"d\",\"2\":\"shirt\"},{\"1\":\"d\",\"2\":\"trousers\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nThe syntax of `expand()` is as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand(\"data name\", \"column names which you want to expand separated by commas\")\n```\n:::\n\n\n### complete()\n\nThe `complete()` command functions similar to the `expand()` command, but it also fills in NA values for columns which we didn't specify, The main reason to use this command would be to convert implicit `NA` values hidden in the dataset to explicit `NA` values which are expressed in the dataset. Given below is a comparison between the `complete()` and `expand()` commands.\n\n::: panel-tabset\n## expand()\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# expanding dataset with brand and dress as variables\ndress_data_expand <- expand(dress_data, brand, dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_expand)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\"},{\"1\":\"a\",\"2\":\"pant\"},{\"1\":\"a\",\"2\":\"shirt\"},{\"1\":\"a\",\"2\":\"trousers\"},{\"1\":\"b\",\"2\":\"jeans\"},{\"1\":\"b\",\"2\":\"pant\"},{\"1\":\"b\",\"2\":\"shirt\"},{\"1\":\"b\",\"2\":\"trousers\"},{\"1\":\"c\",\"2\":\"jeans\"},{\"1\":\"c\",\"2\":\"pant\"},{\"1\":\"c\",\"2\":\"shirt\"},{\"1\":\"c\",\"2\":\"trousers\"},{\"1\":\"d\",\"2\":\"jeans\"},{\"1\":\"d\",\"2\":\"pant\"},{\"1\":\"d\",\"2\":\"shirt\"},{\"1\":\"d\",\"2\":\"trousers\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## complete()\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# completing dataset with brand and dress as variables\n# the variable 'size' will be filled with NAs as we did not specify it\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_complete)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"a\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"b\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\nThe syntax of `complete()` is as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplete(\"data name\", \"column names which you want to complete separated by commas\")\n```\n:::\n\n\n## Handling NAs or missing values\n\nMost data collection would often result in possible `NA` values. The `{tidyr}` package allows us to drop or convert `NA` values. We will reuse the earlier example. Below tabs show before and removing `NA` values.\n\n### drop_na()\n\nUse `drop_na()` to remove `NA` value containing rows from the dataset.\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_complete)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"a\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"b\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"b\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"c\",\"2\":\"trousers\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"jeans\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"pant\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"shirt\",\"3\":\"NA\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# dropping NA values\n\ndress_data_noNA <- drop_na(dress_data_complete)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_noNA)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n:::\n\n### fill()\n\nUse `fill()` to replace `NA` values by taking values from nearby cells. By default the `NA` values as replaced by whatever value that is above the cell containing the `NA` value. This can be changed by specifying the `.direction` value within `fill()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# direction 'downup' simultaneously fill both upwards and downwards NA containing cells\ndress_data_fill <- fill(dress_data_complete, size, .direction = \"downup\")\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_fill)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"pant\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"trousers\",\"3\":\"s\"},{\"1\":\"b\",\"2\":\"jeans\",\"3\":\"s\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"b\",\"2\":\"shirt\",\"3\":\"m\"},{\"1\":\"b\",\"2\":\"trousers\",\"3\":\"m\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"pant\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"shirt\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"trousers\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"pant\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"shirt\",\"3\":\"l\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### replace_na()\n\nUse `replace_na()` command to replace `NA` values to whatever value specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# replace NA to unknown\n# specify the column which have NA inside the list()\n# then equate the value which would replace NAs\ndress_data_zero <- replace_na(dress_data_complete, list(size = \"unknown\"))\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_zero)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"brand\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"dress\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"size\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"a\",\"2\":\"jeans\",\"3\":\"unknown\"},{\"1\":\"a\",\"2\":\"pant\",\"3\":\"unknown\"},{\"1\":\"a\",\"2\":\"shirt\",\"3\":\"s\"},{\"1\":\"a\",\"2\":\"trousers\",\"3\":\"unknown\"},{\"1\":\"b\",\"2\":\"jeans\",\"3\":\"unknown\"},{\"1\":\"b\",\"2\":\"pant\",\"3\":\"m\"},{\"1\":\"b\",\"2\":\"shirt\",\"3\":\"unknown\"},{\"1\":\"b\",\"2\":\"trousers\",\"3\":\"unknown\"},{\"1\":\"c\",\"2\":\"jeans\",\"3\":\"l\"},{\"1\":\"c\",\"2\":\"pant\",\"3\":\"unknown\"},{\"1\":\"c\",\"2\":\"shirt\",\"3\":\"unknown\"},{\"1\":\"c\",\"2\":\"trousers\",\"3\":\"unknown\"},{\"1\":\"d\",\"2\":\"jeans\",\"3\":\"unknown\"},{\"1\":\"d\",\"2\":\"pant\",\"3\":\"unknown\"},{\"1\":\"d\",\"2\":\"shirt\",\"3\":\"unknown\"},{\"1\":\"d\",\"2\":\"trousers\",\"3\":\"xl\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Summary\n\nSo in this chapter, we learned what is tidy data and how we can make our data into tidy data. Making our data tidy is very important as it helps us to analyse and visualise the data in a very efficient manner. We also learned how to reshape our data, how to split or unite cells, how to complete and expand data and how to handle `NA` values. Hope this chapter was fruitful for you!\n\n## References\n\n1.  Hadley Wickham (2021). tidyr: Tidy Messy Data. R package version 1.1.4. https://CRAN.R-project.org/package=tidyr\n\n#### Last updated on {.unnumbered .unlisted}\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-05-26 07:08:14 IST\"\n```\n:::\n:::\n\n\n<a hidden href=\"https://info.flagcounter.com/ynrK\"><img src=\"https://s11.flagcounter.com/count2/ynrK/bg_000000/txt_FFFFFF/border_F0F0F0/columns_5/maxflags_25/viewers_0/labels_1/pageviews_1/flags_0/percent_0/\" alt=\"Flag Counter\" border=\"0\"/></a>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}