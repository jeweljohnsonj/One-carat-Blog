<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.326">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jewel Johnson">
<meta name="dcterms.date" content="2023-04-06">
<meta name="description" content="Learn to build and analyze network data using R">

<title>SciQuest - Introduction to Network Analysis in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/social-share-0.1.0/social-share.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/social-share-0.1.0/all.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EVCS615JQR"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-EVCS615JQR', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

<script src="../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
<script src="../../site_libs/jquery-3.5.1/jquery.min.js"></script>
<script src="../../site_libs/threejs-111/three.min.js"></script>
<script src="../../site_libs/threejs-111/Detector.js"></script>
<script src="../../site_libs/threejs-111/Projector.js"></script>
<script src="../../site_libs/threejs-111/CanvasRenderer.js"></script>
<script src="../../site_libs/threejs-111/TrackballControls.js"></script>
<script src="../../site_libs/threejs-111/StateOrbitControls.js"></script>
<script src="../../site_libs/scatterplotThree-binding-0.3.3/scatterplotThree.js"></script>
<link href="../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css" rel="stylesheet">
<script src="../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js"></script>
<link href="../../site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet">
<script src="../../site_libs/pagedtable-1.1/js/pagedtable.js"></script>


<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="https://cdn.knightlab.com/libs/juxtapose/latest/css/juxtapose.css">
<meta property="og:title" content="SciQuest - Introduction to Network Analysis in R">
<meta property="og:description" content="Learn to build and analyze network data using R">
<meta property="og:image" content="https://sciquest.netlify.app/tutorials/network_analysis/images/network_analysis.png">
<meta property="og:site-name" content="SciQuest">
<meta property="og:image:height" content="1080">
<meta property="og:image:width" content="1920">
<meta name="twitter:title" content="SciQuest - Introduction to Network Analysis in R">
<meta name="twitter:description" content="Learn to build and analyze network data using R">
<meta name="twitter:image" content="https://sciquest.netlify.app/tutorials/network_analysis/images/network_analysis.png">
<meta name="twitter:image-height" content="1080">
<meta name="twitter:image-width" content="1920">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../favicon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">SciQuest</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html" rel="" target="">
 <span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://jeweljohnsonj.github.io/jewel_resume/" rel="" target="">
 <span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jeweljohnsonj/SciQuest" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/jeweljohnsonj" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Introduction to Network Analysis in R</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                  <div>
        <div class="description">
          Learn to build and analyze network data using R
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">network analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://sciquest.netlify.app/">Jewel Johnson</a> </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 6, 2023</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">April 15, 2023</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#creating-a-dummy-dataframe" id="toc-creating-a-dummy-dataframe" class="nav-link" data-scroll-target="#creating-a-dummy-dataframe"><span class="header-section-number">2</span> Creating a dummy dataframe</a></li>
  <li><a href="#converting-dataframe-to-network-data" id="toc-converting-dataframe-to-network-data" class="nav-link" data-scroll-target="#converting-dataframe-to-network-data"><span class="header-section-number">3</span> Converting dataframe to network data</a></li>
  <li><a href="#network-attributes" id="toc-network-attributes" class="nav-link" data-scroll-target="#network-attributes"><span class="header-section-number">4</span> Network attributes</a>
  <ul class="collapse">
  <li><a href="#vertex-attributes" id="toc-vertex-attributes" class="nav-link" data-scroll-target="#vertex-attributes"><span class="header-section-number">4.1</span> Vertex attributes</a></li>
  <li><a href="#edge-attributes" id="toc-edge-attributes" class="nav-link" data-scroll-target="#edge-attributes"><span class="header-section-number">4.2</span> Edge attributes</a></li>
  <li><a href="#one-shot-way-to-add-attributes" id="toc-one-shot-way-to-add-attributes" class="nav-link" data-scroll-target="#one-shot-way-to-add-attributes"><span class="header-section-number">4.3</span> One-shot way to add attributes</a></li>
  </ul></li>
  <li><a href="#filtering-attributes" id="toc-filtering-attributes" class="nav-link" data-scroll-target="#filtering-attributes"><span class="header-section-number">5</span> Filtering attributes</a></li>
  <li><a href="#visualizing-the-attributes" id="toc-visualizing-the-attributes" class="nav-link" data-scroll-target="#visualizing-the-attributes"><span class="header-section-number">6</span> Visualizing the attributes</a>
  <ul class="collapse">
  <li><a href="#vertex-attributes-1" id="toc-vertex-attributes-1" class="nav-link" data-scroll-target="#vertex-attributes-1"><span class="header-section-number">6.1</span> Vertex attributes</a></li>
  <li><a href="#edge-attributes-1" id="toc-edge-attributes-1" class="nav-link" data-scroll-target="#edge-attributes-1"><span class="header-section-number">6.2</span> Edge attributes</a></li>
  </ul></li>
  <li><a href="#network-visualizations" id="toc-network-visualizations" class="nav-link" data-scroll-target="#network-visualizations"><span class="header-section-number">7</span> Network Visualizations</a></li>
  <li><a href="#directed-networks" id="toc-directed-networks" class="nav-link" data-scroll-target="#directed-networks"><span class="header-section-number">8</span> Directed networks</a>
  <ul class="collapse">
  <li><a href="#identifying-edges" id="toc-identifying-edges" class="nav-link" data-scroll-target="#identifying-edges"><span class="header-section-number">8.1</span> Identifying edges</a></li>
  <li><a href="#identifying-the-neighbors" id="toc-identifying-the-neighbors" class="nav-link" data-scroll-target="#identifying-the-neighbors"><span class="header-section-number">8.2</span> Identifying the neighbors</a></li>
  <li><a href="#path-length-geodesic-distance" id="toc-path-length-geodesic-distance" class="nav-link" data-scroll-target="#path-length-geodesic-distance"><span class="header-section-number">8.3</span> Path length (Geodesic distance)</a></li>
  </ul></li>
  <li><a href="#measures-of-network-structure" id="toc-measures-of-network-structure" class="nav-link" data-scroll-target="#measures-of-network-structure"><span class="header-section-number">9</span> Measures of network structure</a>
  <ul class="collapse">
  <li><a href="#degree" id="toc-degree" class="nav-link" data-scroll-target="#degree"><span class="header-section-number">9.1</span> Degree</a></li>
  <li><a href="#betweenness" id="toc-betweenness" class="nav-link" data-scroll-target="#betweenness"><span class="header-section-number">9.2</span> Betweenness</a></li>
  <li><a href="#eigenvector-centrality" id="toc-eigenvector-centrality" class="nav-link" data-scroll-target="#eigenvector-centrality"><span class="header-section-number">9.3</span> Eigenvector centrality</a></li>
  <li><a href="#density" id="toc-density" class="nav-link" data-scroll-target="#density"><span class="header-section-number">9.4</span> Density</a></li>
  <li><a href="#average-path-length" id="toc-average-path-length" class="nav-link" data-scroll-target="#average-path-length"><span class="header-section-number">9.5</span> Average path length</a></li>
  </ul></li>
  <li><a href="#network-randomization-test" id="toc-network-randomization-test" class="nav-link" data-scroll-target="#network-randomization-test"><span class="header-section-number">10</span> Network randomization test</a></li>
  <li><a href="#network-substructures" id="toc-network-substructures" class="nav-link" data-scroll-target="#network-substructures"><span class="header-section-number">11</span> Network substructures</a>
  <ul class="collapse">
  <li><a href="#triangles-triads" id="toc-triangles-triads" class="nav-link" data-scroll-target="#triangles-triads"><span class="header-section-number">11.1</span> Triangles (triads)</a></li>
  <li><a href="#transitivity" id="toc-transitivity" class="nav-link" data-scroll-target="#transitivity"><span class="header-section-number">11.2</span> Transitivity</a></li>
  <li><a href="#cliques" id="toc-cliques" class="nav-link" data-scroll-target="#cliques"><span class="header-section-number">11.3</span> Cliques</a></li>
  </ul></li>
  <li><a href="#identifying-special-relationships" id="toc-identifying-special-relationships" class="nav-link" data-scroll-target="#identifying-special-relationships"><span class="header-section-number">12</span> Identifying special relationships</a>
  <ul class="collapse">
  <li><a href="#assortativity" id="toc-assortativity" class="nav-link" data-scroll-target="#assortativity"><span class="header-section-number">12.1</span> Assortativity</a></li>
  <li><a href="#assortativity-degree" id="toc-assortativity-degree" class="nav-link" data-scroll-target="#assortativity-degree"><span class="header-section-number">12.2</span> Assortativity degree</a></li>
  <li><a href="#reciprocity" id="toc-reciprocity" class="nav-link" data-scroll-target="#reciprocity"><span class="header-section-number">12.3</span> Reciprocity</a></li>
  </ul></li>
  <li><a href="#community-detection" id="toc-community-detection" class="nav-link" data-scroll-target="#community-detection"><span class="header-section-number">13</span> Community detection</a>
  <ul class="collapse">
  <li><a href="#fast-greedy-community-detection" id="toc-fast-greedy-community-detection" class="nav-link" data-scroll-target="#fast-greedy-community-detection"><span class="header-section-number">13.1</span> Fast-greedy community detection</a></li>
  <li><a href="#edge-betweenness-community-detection" id="toc-edge-betweenness-community-detection" class="nav-link" data-scroll-target="#edge-betweenness-community-detection"><span class="header-section-number">13.2</span> Edge-betweenness community detection</a></li>
  </ul></li>
  <li><a href="#interactive-network-visualizations" id="toc-interactive-network-visualizations" class="nav-link" data-scroll-target="#interactive-network-visualizations"><span class="header-section-number">14</span> Interactive network visualizations</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">15</span> Conclusion</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/jeweljohnsonj/SciQuest/edit/main/tutorials/network_analysis/network_analysis.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/jeweljohnsonj/SciQuest/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
TL;DR
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this article we will learn;</p>
<ol type="1">
<li>What is a network and what are the different ways to denote the network data?</li>
<li>How to convert the network data into an igraph object to analyze and plot the network via the <code>{igraph}</code> package in R.</li>
<li>What are vertex and edge attributes and how do we add them to the igraph object?</li>
<li>How do we filter network attributes and how to visualize them?</li>
<li>What are the different types of network visualizations?</li>
<li>What are directed networks?</li>
<li>What is path length?</li>
<li>What are the different measures of network structure?</li>
<li>What is network randomization test and what is its purpose?</li>
<li>what are the different network substructures?</li>
<li>How to identify special relationships in the network?</li>
<li>How to find communities in a network?</li>
<li>How to visualize the network in 3D using the <code>{threejs}</code> package</li>
</ol>
<p>We will be using the <code>{igprah}</code> and <code>{threejs}</code> packages in this tutorial.</p>
</div>
</div>
<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>In this tutorial, we will explore social networks and how to create and analyze them. A social network is a graphical representation of relationships between a group of individuals. For instance, the figure below shows a social network that could represent friendships among a group of people, bus routes to different locations in a city, or connections between different neurons.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/social_network.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">A graph depicting a social network</figcaption><p></p>
</figure>
</div>
<p>If we take a closer look at the figure, we can see that individual A has some kind of relationship with individuals B, C, and F, but not with D and E. The individuals, such as A, B, C, and so on, are called nodes or vertices, while the connections between them are known as lines, edges, or ties.</p>
<p>Network data can be represented in different forms, such as an adjacency matrix or an edge list. The adjacency matrix for the network shown in the figure is provided below. In this matrix, each row and column corresponds to a vertex, and a value of 1 indicates the presence of an edge between the corresponding vertices.</p>
<div class="cell">
<details>
<summary>Code for making the adjacency matrix for the above figure</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>name1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">'a'</span>, <span class="dv">3</span>), <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>name2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'b'</span>,<span class="st">'c'</span>,<span class="st">'f'</span>,<span class="st">'d'</span>,<span class="st">'e'</span>,<span class="st">'e'</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(name1, name2)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>rel_ig <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(rel)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">as_adjacency_matrix</span>(rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>6 x 6 sparse Matrix of class "dgCMatrix"
  a b c d f e
a . 1 1 . 1 .
b . . . 1 . .
c . . . . . 1
d . . . . . 1
f . . . . . .
e . . . . . .</code></pre>
</div>
</div>
<p>Alternatively, we can represent the same information in an edge list format, where all the edges in the network are listed in a 2x2 matrix.</p>
<div class="cell">
<details>
<summary>Code for making the edge list for the above figure</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>name1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">'a'</span>, <span class="dv">3</span>), <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>name2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'b'</span>,<span class="st">'c'</span>,<span class="st">'f'</span>,<span class="st">'d'</span>,<span class="st">'e'</span>,<span class="st">'e'</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(name1, name2)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>rel_ig <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(rel)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">as_edgelist</span>(rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,] "a"  "b" 
[2,] "a"  "c" 
[3,] "a"  "f" 
[4,] "b"  "d" 
[5,] "c"  "e" 
[6,] "d"  "e" </code></pre>
</div>
</div>
<p>The edge list provided above displays each relationship or edge in the given social network through its rows. To gain a better understanding of how we can analyze and plot such data, let’s work with a dataset resembling a real-life scenario.</p>
</section>
<section id="creating-a-dummy-dataframe" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="creating-a-dummy-dataframe"><span class="header-section-number">2</span> Creating a dummy dataframe</h2>
<p>We will work with a synthetic dataset consisting of 10 individuals and their relationships, gender, and weekly call duration. This will allow us to explore how social network analysis can be applied to real-life scenarios. The dataset includes friendships between individuals and other attributes such as gender and call duration. Below is the code used to generate this dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dataframe with 10 names and gender</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1">1</button><span id="annotated-cell-3-5" class="code-annotation-target"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a>df_names <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">name =</span> <span class="fu">c</span>(<span class="st">"Alice"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span>, <span class="st">"David"</span>, <span class="st">"Eve"</span>, <span class="st">"Frank"</span>,</span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Grace"</span>, <span class="st">"Henry"</span>, <span class="st">"Isabelle"</span>, <span class="st">"John"</span>),</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">gender =</span> <span class="fu">c</span>(<span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>)</span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an empty dataframe to store the relationships</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2">2</button><span id="annotated-cell-3-12" class="code-annotation-target"><a href="#annotated-cell-3-12" aria-hidden="true" tabindex="-1"></a>df_rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">name1 =</span> <span class="fu">character</span>(), <span class="at">name2 =</span> <span class="fu">character</span>(),</span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13" aria-hidden="true" tabindex="-1"></a>                     <span class="at">call_hours =</span> <span class="fu">numeric</span>()) </span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate random relationships with call hours</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3">3</button><span id="annotated-cell-3-16" class="code-annotation-target"><a href="#annotated-cell-3-16" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="fu">nrow</span>(df_rel) <span class="sc">&lt;</span> <span class="dv">20</span>) {</span>
<span id="annotated-cell-3-17"><a href="#annotated-cell-3-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Randomly select two names</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4">4</button><span id="annotated-cell-3-18" class="code-annotation-target"><a href="#annotated-cell-3-18" aria-hidden="true" tabindex="-1"></a>  name1 <span class="ot">&lt;-</span> <span class="fu">sample</span>(df_names<span class="sc">$</span>name, <span class="dv">1</span>)</span>
<span id="annotated-cell-3-19"><a href="#annotated-cell-3-19" aria-hidden="true" tabindex="-1"></a>  name2 <span class="ot">&lt;-</span> <span class="fu">sample</span>(df_names<span class="sc">$</span>name, <span class="dv">1</span>)</span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Check if the selected names are the same or have already been added to the dataframe</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5">5</button><span id="annotated-cell-3-22" class="code-annotation-target"><a href="#annotated-cell-3-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (name1 <span class="sc">!=</span> name2 <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">any</span>((df_rel<span class="sc">$</span>name1 <span class="sc">==</span> name1 <span class="sc">&amp;</span> df_rel<span class="sc">$</span>name2 <span class="sc">==</span> name2) <span class="sc">|</span></span>
<span id="annotated-cell-3-23"><a href="#annotated-cell-3-23" aria-hidden="true" tabindex="-1"></a>                            (df_rel<span class="sc">$</span>name1 <span class="sc">==</span> name2 <span class="sc">&amp;</span> df_rel<span class="sc">$</span>name2 <span class="sc">==</span> name1))) { </span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the relationship with a random number of call hours between 1 and 10</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="6">6</button><span id="annotated-cell-3-25" class="code-annotation-target"><a href="#annotated-cell-3-25" aria-hidden="true" tabindex="-1"></a>    df_rel <span class="ot">&lt;-</span> <span class="fu">rbind</span>(df_rel, <span class="fu">data.frame</span>(<span class="at">name1 =</span> name1, <span class="at">name2 =</span> name2,</span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">call_hours =</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">1</span>))) </span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="annotated-cell-3-29"><a href="#annotated-cell-3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-3-30"><a href="#annotated-cell-3-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Finally our dataset</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="7">7</button><span id="annotated-cell-3-31" class="code-annotation-target"><a href="#annotated-cell-3-31" aria-hidden="true" tabindex="-1"></a>df_rel</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-lines="5" data-code-cell="annotated-cell-3" data-code-annotation="1">First, the code creates a dataframe called df_names with 10 names and their genders.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-lines="12" data-code-cell="annotated-cell-3" data-code-annotation="2">Then, an empty dataframe called df_rel is created to store the relationships.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-lines="16" data-code-cell="annotated-cell-3" data-code-annotation="3">The while loop is used to generate random relationships between the names until df_rel has 20 rows.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-lines="18" data-code-cell="annotated-cell-3" data-code-annotation="4">Inside the while loop, two names are randomly selected from the name column of df_names using the sample function.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-lines="22" data-code-cell="annotated-cell-3" data-code-annotation="5">The if statement checks whether the two names are the same or whether they have already been added as a relationship to df_rel. If either of these conditions is true, the loop moves on to select a new pair of names.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="6">6</dt>
<dd>
<span data-code-lines="25" data-code-cell="annotated-cell-3" data-code-annotation="6">If the two names are different and have not been added to df_rel, a new row is added to df_rel with the selected names and a randomly generated number between 1 and 10 as the number of call hours.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="7">7</dt>
<dd>
<span data-code-lines="31" data-code-cell="annotated-cell-3" data-code-annotation="7">Once df_rel has 20 rows, the loop stops, and the final dataframe is printed using print(df_rel).</span>
</dd>
</dl>
</div>
<div class="cell-output-display">

<div data-pagedtable="false">
  <script data-pagedtable-source="" type="application/json">
{"columns":[{"label":["name1"],"name":[1],"type":["chr"],"align":["left"]},{"label":["name2"],"name":[2],"type":["chr"],"align":["left"]},{"label":["call_hours"],"name":[3],"type":["int"],"align":["right"]}],"data":[{"1":"John","2":"Bob","3":"6"},{"1":"Eve","2":"David","3":"6"},{"1":"Isabelle","2":"John","3":"5"},{"1":"Charlie","2":"Isabelle","3":"9"},{"1":"Henry","2":"John","3":"7"},{"1":"Charlie","2":"David","3":"1"},{"1":"Grace","2":"Eve","3":"10"},{"1":"Grace","2":"Isabelle","3":"9"},{"1":"John","2":"Grace","3":"5"},{"1":"Frank","2":"Isabelle","3":"2"},{"1":"Eve","2":"Henry","3":"2"},{"1":"Alice","2":"Isabelle","3":"9"},{"1":"Frank","2":"Eve","3":"9"},{"1":"John","2":"David","3":"6"},{"1":"Henry","2":"Frank","3":"6"},{"1":"Grace","2":"Alice","3":"6"},{"1":"Bob","2":"Alice","3":"2"},{"1":"Frank","2":"Charlie","3":"9"},{"1":"David","2":"Frank","3":"9"},{"1":"Charlie","2":"Henry","3":"9"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
</section>
<section id="converting-dataframe-to-network-data" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="converting-dataframe-to-network-data"><span class="header-section-number">3</span> Converting dataframe to network data</h2>
<p>To convert our dataframe into network data, we’ll be using the {igraph} package in R and the graph.edgelist() function. However, before we can do that, we need to make sure that our dataframe is in the right format. The graph.edgelist() function requires a 2x2 edge list matrix, which means that our dataframe needs to be converted to a matrix using the as.matrix() function. For now, we’ll also remove the call_hours column.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Installing and loading the igraph package</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating an igraph object</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>df_rel_mx <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(df_rel[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>df_rel_ig <span class="ot">&lt;-</span> <span class="fu">graph.edgelist</span>(df_rel_mx, <span class="at">directed =</span> F)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>df_rel_ig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 53fc946 UN-- 10 20 -- 
+ attr: name (v/c)
+ edges from 53fc946 (vertex names):
 [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie 
 [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   
 [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   
[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   
[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<ol type="1">
<li>In the first line of the output, the first number; 10 indicates that there are 10 vertices, and 20 means that there are 20 edges in the network.</li>
<li>Starting from the 4th line of the output, all the edges in the network are shown. These are relationships in the dataset.</li>
</ol>
<p>Now let us plot the network using the <code>plot()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the above graph, each person is represented as a vertex, shown in blue. The edges between them indicate that they are friends with each other.</p>
<p>The <code>{igraph}</code> package provides various functions to further analyze the network data. For instance, we can use the <code>V()</code> function to view the vertices in the dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the nodes/vertices</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 10/10 vertices, named, from 53fc946:
 [1] John     Bob      Eve      David    Isabelle Charlie  Henry    Grace   
 [9] Frank    Alice   </code></pre>
</div>
</div>
<p>Similarly, using the <code>E()</code> function returns all the edges.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the edges</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 20/20 edges from 53fc946 (vertex names):
 [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie 
 [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   
 [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   
[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   
[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<p>To get the number of vertices we can use <code>gorder()</code> and for getting the number of edges we can use <code>gsize()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the no. of vertices</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gorder</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the no. of edges</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gsize</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 20</code></pre>
</div>
</div>
</section>
<section id="network-attributes" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="network-attributes"><span class="header-section-number">4</span> Network attributes</h2>
<section id="vertex-attributes" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="vertex-attributes"><span class="header-section-number">4.1</span> Vertex attributes</h3>
<p>Let us once again look at the igraph object output for the data we are using.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df_rel_ig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 53fc946 UN-- 10 20 -- 
+ attr: name (v/c)
+ edges from 53fc946 (vertex names):
 [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie 
 [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   
 [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   
[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   
[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<p>In the second line of the output, we can see the attributes of the vertices. The network attributes can be either categorical or numerical. In this case, the attribute ‘name’ is a categorical variable denoting a person’s name as vertices. Examples of numerical attributes include the age of an individual, the population of a city, or revenue of a company, etc.</p>
<p>The vertex attributes can be visualized using different shapes, colors, or sizes of the shape. To add a vertex attribute, we can use the <code>set_vertex_attr()</code> function. In the function arguments, we first input the igraph object, then the attribute name that we choose to give, which in this case would be ‘gender’, and finally the values for that attribute. Therefore, we use our df_names dataframe that we created before to fetch the gender data as the vertex attribute.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Our dataframe with 10 names and gender</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>df_names <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">name =</span> <span class="fu">c</span>(<span class="st">"Alice"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span>, <span class="st">"David"</span>, <span class="st">"Eve"</span>, <span class="st">"Frank"</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Grace"</span>, <span class="st">"Henry"</span>, <span class="st">"Isabelle"</span>, <span class="st">"John"</span>),</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">gender =</span> <span class="fu">c</span>(<span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding 'gender' as a vertex attribute</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig, <span class="st">"gender"</span>, <span class="at">value =</span> df_names<span class="sc">$</span>gender)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 53fc946 UN-- 10 20 -- 
+ attr: name (v/c), gender (v/c)
+ edges from 53fc946 (vertex names):
 [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie 
 [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   
 [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   
[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   
[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<p>In the igraph object output, in the second line, you can see that a new vertex attribute called ‘gender’ has been added, which is denoted by ‘gender (v/c)’.</p>
</section>
<section id="edge-attributes" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="edge-attributes"><span class="header-section-number">4.2</span> Edge attributes</h3>
<p>Similar to vertex attributes, edges can also convey different information. The common form of edge attribute is by changing the width of the line connecting the vertices. Therefore, we can convey information such as the number of bus routes between two places or the number of phone calls between two friends by changing the width size.</p>
<p>In our case, we can denote edge width to denote the call hours between two people. Similar to the previous case, we can use the set_edge_attr() function. The arguments for this function are similar to set_vertex_attr(), which we saw earlier.</p>
<p>We extract the call hour information from the df_rel dataframe that we created earlier.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding 'donations' as an edge attribute</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>df_rel_ig_call <span class="ot">&lt;-</span> <span class="fu">set_edge_attr</span>(df_rel_ig, <span class="st">"call_hours"</span>,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">value =</span> df_rel<span class="sc">$</span>call_hours)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>df_rel_ig_call</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 53fc946 UN-- 10 20 -- 
+ attr: name (v/c), call_hours (e/n)
+ edges from 53fc946 (vertex names):
 [1] John    --Bob      Eve     --David    John    --Isabelle Isabelle--Charlie 
 [5] John    --Henry    David   --Charlie  Eve     --Grace    Isabelle--Grace   
 [9] John    --Grace    Isabelle--Frank    Eve     --Henry    Isabelle--Alice   
[13] Eve     --Frank    John    --David    Henry   --Frank    Grace   --Alice   
[17] Bob     --Alice    Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<p>Similar to the previous case, a new edge attribute called ‘donations’ have been added denoted by ‘donations (e/n)’.</p>
</section>
<section id="one-shot-way-to-add-attributes" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="one-shot-way-to-add-attributes"><span class="header-section-number">4.3</span> One-shot way to add attributes</h3>
<p>We can use the <code>graph_from_data_frame()</code> function from the <code>{igraph}</code> package to create an igraph object directly if we have the vertex and edge information as separate dataframes. In the function arguments, the <code>d</code> parameter takes the edge list dataframe, where the first two columns contain the edges and the third column represents the edge attribute. Similarly, the vertices parameter takes the dataframe for vertex attributes, where the first column represents the vertices, and the remaining columns represent the vertex attributes.</p>
<p>In our case, we can use the <code>df_rel</code> dataframe for the d parameter, where the first two columns represent the edges, and the third column represents the call hours attribute. For the vertices parameter, we can use the <code>df_names</code> dataframe, where the first column represents the vertices (person names), and the second column represents the vertex attribute (gender). By using <code>graph_from_data_frame()</code> function, the vertex and edge attributes will be added to the igraph object automatically.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding the attributes</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>drug_ig_complete <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(<span class="at">d =</span> df_rel, <span class="at">vertices =</span> df_names,</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">directed =</span> F)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>drug_ig_complete</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 548bb9e UN-- 10 20 -- 
+ attr: name (v/c), gender (v/c), call_hours (e/n)
+ edges from 548bb9e (vertex names):
 [1] Bob     --John     David   --Eve      Isabelle--John     Charlie --Isabelle
 [5] Henry   --John     Charlie --David    Eve     --Grace    Grace   --Isabelle
 [9] Grace   --John     Frank   --Isabelle Eve     --Henry    Alice   --Isabelle
[13] Eve     --Frank    David   --John     Frank   --Henry    Alice   --Grace   
[17] Alice   --Bob      Charlie --Frank    David   --Frank    Charlie --Henry   </code></pre>
</div>
</div>
<p>We can also use the functions; <code>vertex_attr()</code> to view the vertex attributes and <code>edge_attr()</code> to view edge attributes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing vertex attribute</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">vertex_attr</span>(drug_ig_complete)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$name
 [1] "Alice"    "Bob"      "Charlie"  "David"    "Eve"      "Frank"   
 [7] "Grace"    "Henry"    "Isabelle" "John"    

$gender
 [1] "F" "M" "M" "M" "F" "M" "F" "M" "F" "M"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing edge attribute</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">edge_attr</span>(drug_ig_complete)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$call_hours
 [1]  6  6  5  9  7  1 10  9  5  2  2  9  9  6  6  6  2  9  9  9</code></pre>
</div>
</div>
</section>
</section>
<section id="filtering-attributes" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="filtering-attributes"><span class="header-section-number">5</span> Filtering attributes</h2>
<p>With different attributes in the network, we can use different filters and see the data differently. Suppose we can want to see what all edges include “John”.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing all friends of John</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(drug_ig_complete)[[<span class="fu">.inc</span>(<span class="st">'John'</span>)]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 5/20 edges from 548bb9e (vertex names):
       tail head tid hid call_hours
1       Bob John   2  10          6
3  Isabelle John   9  10          5
5     Henry John   8  10          7
9     Grace John   7  10          5
14    David John   4  10          6</code></pre>
</div>
</div>
<p>The output shows all friends of John.</p>
<p>Let us also check which friends call for more than 5 hours.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing relationships with call hours of more than 5 hours</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(drug_ig_complete)[[call_hours <span class="sc">&gt;</span> <span class="dv">5</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 14/20 edges from 548bb9e (vertex names):
      tail     head tid hid call_hours
1      Bob     John   2  10          6
2    David      Eve   4   5          6
4  Charlie Isabelle   3   9          9
5    Henry     John   8  10          7
7      Eve    Grace   5   7         10
8    Grace Isabelle   7   9          9
12   Alice Isabelle   1   9          9
13     Eve    Frank   5   6          9
14   David     John   4  10          6
15   Frank    Henry   6   8          6
16   Alice    Grace   1   7          6
18 Charlie    Frank   3   6          9
19   David    Frank   4   6          9
20 Charlie    Henry   3   8          9</code></pre>
</div>
</div>
<p>There are 12 friendships where people call each other for more than 5 hours.</p>
</section>
<section id="visualizing-the-attributes" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="visualizing-the-attributes"><span class="header-section-number">6</span> Visualizing the attributes</h2>
<p>There are various ways to visualize both vertex and edge attributes in a network. For numerical attributes, we can change the size of the vertices and the width of the edges. For categorical attributes, we can change the color and shape of the vertices, and the line type and color of the edges.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/network_attributes.jpg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Different ways to visualize network attributes</figcaption><p></p>
</figure>
</div>
<section id="vertex-attributes-1" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="vertex-attributes-1"><span class="header-section-number">6.1</span> Vertex attributes</h3>
<p>With different attributes, we can also visualize them in the network graph in different ways. In the code given below, we assign color values to each of the vertices in the network depending on their gender. Here females will be coded as red and males as blue.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting vertex color to gender</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(drug_ig_complete)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">V</span>(drug_ig_complete)<span class="sc">$</span>gender <span class="sc">==</span> <span class="st">'F'</span>, <span class="st">"red"</span>, <span class="st">"blue"</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the network</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="edge-attributes-1" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="edge-attributes-1"><span class="header-section-number">6.2</span> Edge attributes</h3>
<p>Edge attributes can be visualized in the network by changing the line type, color or by changing the width. In the code given below, we change the line width depending on the call hours between vertices (or friends).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracting call_hours</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>call_hours <span class="ot">&lt;-</span> <span class="fu">E</span>(drug_ig_complete)<span class="sc">$</span>call_hours</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the network</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the above graph, the line width is directly proportional to the call hours between the vertices. Higher line width corresponds to a greater number of call hours between friends.</p>
</section>
</section>
<section id="network-visualizations" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="network-visualizations"><span class="header-section-number">7</span> Network Visualizations</h2>
<p>Just like how we can customize different network attributes, we can also change the way our network is visualized based on our data. For instance, if we are interested in sequential events or relationships between family members, then visualizing our network in a tree form would be better than the normal way. The <code>layout</code> argument in the <code>plot()</code> function can take different types of layout functions given in the <code>{igraph}</code> package, providing us with a range of ways to visualize our networks. To create a tree network, we can use the function <code>layout_as_tree()</code>. Below are some popular ways to visualize networks.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">Tree-like layout</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Circle</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false">DrL graph layout</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-4" role="tab" aria-controls="tabset-1-4" aria-selected="false">Fruchterman-Reingold layout</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-5" role="tab" aria-controls="tabset-1-5" aria-selected="false">Simple grid layout</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>Good for showing hierarchical relations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in tree form</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_as_tree</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>Place vertices on a circle, in the order of their vertex ids.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in circle form</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_in_circle</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p>DrL is a force-directed graph layout toolbox focused on real-world large-scale graphs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in DrL graph layout</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_with_drl</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
<div id="tabset-1-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-4-tab">
<p>Place vertices on the plane using the force-directed layout algorithm by Fruchterman and Reingold.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in Fruchterman-Reingold graph layout</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_with_fr</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
<div id="tabset-1-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-5-tab">
<p>This layout places vertices on a rectangular grid, in two or three dimensions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in grid layout</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_on_grid</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
</div>
</div>
<p>Alternatively, if we are unsure of which layout is best for the network at hand, we can use the function <code>layout_nicely()</code> which will assign the best layout automatically.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in tree form</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_nicely</span>(drug_ig_complete))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="directed-networks" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="directed-networks"><span class="header-section-number">8</span> Directed networks</h2>
<p>Network graphs can be either undirected or directed. Undirected graphs represent relationships between vertices as simply existing between them, whereas directed graphs indicate that the relationships have a direction. Examples of directed networks include disease outbreak data, family relationships, and school friendship networks.</p>
<p>Let’s create a dummy dataset to illustrate directed networks. We’ll generate data on a disease outbreak that occurred in a community of 20 people.</p>
<div class="cell">
<details>
<summary>Code for making the dummy data</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create a data frame with two columns to store the information about the spread of the disease</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>infection_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Infected=</span><span class="fu">character</span>(), <span class="at">Infected_By=</span><span class="fu">character</span>(), <span class="at">stringsAsFactors=</span><span class="cn">FALSE</span>)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co"># set the number of infected people</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>num_infected <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the first infected person</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>infected <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Patient Zero"</span>)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop over the remaining infected people and add them to the data frame</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>num_infected) {</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># randomly choose the person infected by the current infected person</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  infected_by <span class="ot">&lt;-</span> <span class="fu">sample</span>(infected, <span class="dv">1</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># add the currently infected person and the person infected by them to the data frame</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>  infection_df <span class="ot">&lt;-</span> <span class="fu">rbind</span>(infection_df, <span class="fu">data.frame</span>(<span class="at">Infected=</span><span class="fu">paste</span>(<span class="st">"Person"</span>, i),</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">Infected_By=</span>infected_by, <span class="at">stringsAsFactors=</span><span class="cn">FALSE</span>))</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># add the currently infected person to the list of infected people</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>  infected <span class="ot">&lt;-</span> <span class="fu">c</span>(infected, <span class="fu">paste</span>(<span class="st">"Person"</span>, i))</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Interchanging the columns</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>infection_df <span class="ot">&lt;-</span> infection_df[, <span class="fu">c</span>(<span class="st">"Infected_By"</span>, <span class="st">"Infected"</span>)]</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a><span class="co"># print the first few rows of the resulting data frame</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(infection_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">

<div data-pagedtable="false">
  <script data-pagedtable-source="" type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Infected_By"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Infected"],"name":[2],"type":["chr"],"align":["left"]}],"data":[{"1":"Patient Zero","2":"Person 1","_rn_":"1"},{"1":"Patient Zero","2":"Person 2","_rn_":"2"},{"1":"Person 2","2":"Person 3","_rn_":"3"},{"1":"Person 1","2":"Person 4","_rn_":"4"},{"1":"Person 2","2":"Person 5","_rn_":"5"},{"1":"Person 1","2":"Person 6","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</div>
<p>The dataframe <code>infection_df</code> contains data on 21 individuals (20 people and 1 patient zero). The infection starts with patient zero, which then spreads across the community. The dataframe has two columns: “Infected_By” indicates the person who is transmitting the disease, and “Infected” shows the person who is getting infected by that transmission.</p>
<p>Now, let’s plot the above dataframe as a network graph.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the graph</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph, <span class="at">vertex.label.color=</span><span class="st">"black"</span>, <span class="at">vertex.size=</span><span class="dv">10</span>, <span class="at">vertex.label.cex=</span><span class="fl">0.7</span>,</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size=</span><span class="fl">0.5</span>, <span class="at">main=</span><span class="st">"Disease Transmission Network"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>A notable difference from earlier graphs we have seen is that the edges now have an arrowhead indicating their direction. In the graph, the central node is “Patient Zero”, who is the first infected person in the community. The vertex “Patient Zero” has two outgoing edges, one going to “Person 1” and the other to “Person 2”. The arrowheads navigate us to show how the infection starting from “Patient Zero” infected the whole community. The <code>directed=TRUE</code> argument in the <code>graph_from_data_frame()</code> function tells R to create a directed igraph object. We can also check if a network is directed by using the <code>is.directed()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co"># print output</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>graph</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 57e39e8 DN-- 21 20 -- 
+ attr: name (v/c)
+ edges from 57e39e8 (vertex names):
 [1] Patient Zero-&gt;Person 1  Patient Zero-&gt;Person 2  Person 2    -&gt;Person 3 
 [4] Person 1    -&gt;Person 4  Person 2    -&gt;Person 5  Person 1    -&gt;Person 6 
 [7] Person 1    -&gt;Person 7  Person 5    -&gt;Person 8  Person 4    -&gt;Person 9 
[10] Person 3    -&gt;Person 10 Person 5    -&gt;Person 11 Person 8    -&gt;Person 12
[13] Person 9    -&gt;Person 13 Person 10   -&gt;Person 14 Person 4    -&gt;Person 15
[16] Person 2    -&gt;Person 16 Person 8    -&gt;Person 17 Person 2    -&gt;Person 18
[19] Person 7    -&gt;Person 19 Person 6    -&gt;Person 20</code></pre>
</div>
</div>
<p>In the first line of the output, ‘DN’ stands for ‘Directed Network’, for undirected networks it will be ‘UN’ which we have seen before. We can also use the function <code>is.directed()</code> to check if the network is directed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="co"># checking if it's directed or not</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="fu">is.directed</span>(graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<section id="identifying-edges" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="identifying-edges"><span class="header-section-number">8.1</span> Identifying edges</h3>
<p>Suppose we want to see if there is a disease transmission between person 2 and person 10. To check this we can use the following code;</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># checking if an edge exists between person 2 and person 10</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">'Person 2'</span>, <span class="st">'Person 10'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
<p>The function returned 0, this means that there is no edge between the vertices that we were interested in. The function returns 1 if there exists an edge.</p>
<p>We can also see which edges go out from a vertex and go in into the vertex using the <code>incident()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edged going out from patient zero</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"out"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 2/20 edges from 57eecca (vertex names):
[1] Patient Zero-&gt;Person 2 Patient Zero-&gt;Person 1</code></pre>
</div>
</div>
<p>From the output, we can see that patient zero infects person 1 and person 2.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edges coming into person 3</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Person 3'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"in"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 1/20 edge from 57eecca (vertex names):
[1] Person 2-&gt;Person 3</code></pre>
</div>
</div>
<p>From the output, we can see that person 3 was infected by person 2.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edges connected to person 5</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Person 5'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 3/20 edges from 57eecca (vertex names):
[1] Person 2-&gt;Person 5  Person 5-&gt;Person 8  Person 5-&gt;Person 11</code></pre>
</div>
</div>
<p>From the output we can see that person 5 was infected by person 2 and thereafter person 5 goes on to infect person 8 and person 11.</p>
<p>We can also use the <code>head_of()</code> function to return the set of vertices that are at the beginning of the edges in the input. It gives the list of people who infected others.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all vertices that are connected to an edge</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head_of</span>(graph, <span class="fu">E</span>(graph))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 20/21 vertices, named, from 57eecca:
 [1] Person 1  Person 2  Person 3  Person 4  Person 5  Person 6  Person 7 
 [8] Person 8  Person 9  Person 10 Person 11 Person 12 Person 13 Person 14
[15] Person 15 Person 16 Person 17 Person 18 Person 19 Person 20</code></pre>
</div>
</div>
<p>Here, patient zero is not included in the output because it is not connected to any edges in the graph. The <code>head_of()</code> function returns only the vertices that are connected to edges in the graph, and since patient zero does not have any outgoing edges, it is not included in the output.</p>
</section>
<section id="identifying-the-neighbors" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="identifying-the-neighbors"><span class="header-section-number">8.2</span> Identifying the neighbors</h3>
<p>To track the spread of a pandemic in a small community, we need to identify the individuals who were infected by patient zero. This can be accomplished by identifying the immediate neighbors of patient zero using the <code>neighbors()</code> function.</p>
<p>Here’s an example of how we can find the infected neighbors in R using the <code>neighbors()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the neighbors of patient zero</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="fu">neighbors</span>(graph, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 2/21 vertices, named, from 57eecca:
[1] Person 2 Person 1</code></pre>
</div>
</div>
<p>We can also see which neighbors are common for a particular vertex using the <code>intersect()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding neighbors of person 1 </span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">neighbors</span>(graph, <span class="st">'Person 1'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"># finding neighbors of person 2</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">neighbors</span>(graph, <span class="st">'Person 2'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co"># finding common neighbors between person 1 and person 2</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="fu">intersection</span>(x,y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 1/21 vertex, named, from 57eecca:
[1] Patient Zero</code></pre>
</div>
</div>
</section>
<section id="path-length-geodesic-distance" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="path-length-geodesic-distance"><span class="header-section-number">8.3</span> Path length (Geodesic distance)</h3>
<p>A measure to see how well a network is connected is to look at the length of the edges between all pairs of vertices. The length between a vertex and its immediate neighbor will be 1 and this is called path length or also known as geodesic distance. In our network graph, from patient zero to person 1, one connection is required to traverse, which means that the path length between them is 1. Between person 7 and patient zero the path length is 2.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the graph</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph, <span class="at">vertex.label.color=</span><span class="st">"black"</span>, <span class="at">vertex.size=</span><span class="dv">10</span>, <span class="at">vertex.label.cex=</span><span class="fl">0.7</span>,</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size=</span><span class="fl">0.5</span>, <span class="at">main=</span><span class="st">"Disease Transmission Network"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-35-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>A good way to see how deep the infection has traversed, we have to see the longest path in the network. This longest path is called the diameter of the network. To get the diameter of the network we can use the function <code>farthest_vertices()</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the longest path in the network</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="fu">farthest_vertices</span>(graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$vertices
+ 2/21 vertices, named, from 5852d47:
[1] Patient Zero Person 12   

$distance
[1] 4</code></pre>
</div>
</div>
<p>To see how the connections between patient zero and person 12 make up the longest path in the network we can use the function <code>get_diameter()</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the longest path in the network</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="fu">get_diameter</span>(graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>+ 5/21 vertices, named, from 5852d47:
[1] Patient Zero Person 2     Person 5     Person 8     Person 12   </code></pre>
</div>
</div>
<p>To calculate the geodesic distances of all vertices from a particular vertex, we can use the function <code>distances()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding geodesic distances of all vertices from the vertex 'Patient Zero'</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">distances</span>(graph, <span class="st">"Patient Zero"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             Patient Zero Person 2 Person 1 Person 5 Person 4 Person 3 Person 8
Patient Zero            0        1        1        2        2        2        3
             Person 9 Person 10 Person 7 Person 6 Person 11 Person 12 Person 13
Patient Zero        3         3        2        2         3         4         4
             Person 14 Person 15 Person 16 Person 17 Person 18 Person 19
Patient Zero         4         3         2         4         2         3
             Person 20
Patient Zero         3</code></pre>
</div>
</div>
<p>From the output, we can see how distance each vertex is away from patient zero. Person 1 and Person 2 seem to be immediate targets of disease transmission starting from patient zero and persons 12,13,14 and person 17 were the last people to be infected in the whole community.</p>
<p>We can also identify vertices that are reachable with N steps from a vertex of interest. Suppose we want to know vertices from patient zero that are reachable within 2 connections or 2 steps. We can use the <code>ego()</code> function for this task.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding vertices that are at min. 2 edges away from patient zero</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ego</span>(graph, <span class="dv">2</span>, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
+ 10/21 vertices, named, from 5852d47:
 [1] Patient Zero Person 2     Person 1     Person 5     Person 3    
 [6] Person 16    Person 18    Person 4     Person 7     Person 6    </code></pre>
</div>
</div>
<p>Let us plot the network to visualize how far each vertex is from ‘Patient Zero’. First we use <code>make_ego_graph()</code> function to get a sub-graph containing all neighbors of Patient Zero which is reachable within the diameter of the network. This essentially includes all vertices that are connected to Patient Zero. Then we calculate the distances of vertices from Patient Zero. The diameter of this network is 4, but we add 4+1 colors, as ‘Patient Zero’ has zero distance, we suggest 5 colors so that ‘Patient Zero’ has its color. In the final plot, we have vertex labels to denote the geodesic distances from Patient Zero.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Make an ego graph</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>graph_ego <span class="ot">&lt;-</span> <span class="fu">make_ego_graph</span>(graph, <span class="fu">diameter</span>(graph), <span class="at">nodes =</span> <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))[[<span class="dv">1</span>]]</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Get a vector of geodesic distances of all vertices from vertex Patient Zero </span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>dists <span class="ot">&lt;-</span> <span class="fu">distances</span>(graph_ego, <span class="st">"Patient Zero"</span>)</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a color palette of length equal to the maximal geodesic distance plus one.</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>colors <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"black"</span>, <span class="st">"red"</span>, <span class="st">"orange"</span>, <span class="st">"blue"</span>, <span class="st">"dodgerblue"</span>)</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Set color attribute to vertices of network graph_ego</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(graph_ego)<span class="sc">$</span>color <span class="ot">&lt;-</span> colors[dists<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the network based on geodesic distance from patient zero.</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph_ego, </span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label =</span> dists, </span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.color =</span> <span class="st">"white"</span>,</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.cex =</span> .<span class="dv">6</span>,</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.color =</span> <span class="st">'black'</span>,</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.size =</span> <span class="dv">15</span>,</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size =</span> .<span class="dv">05</span>,</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Geodesic Distances from Patient Zero"</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-40-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="measures-of-network-structure" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="measures-of-network-structure"><span class="header-section-number">9</span> Measures of network structure</h2>
<section id="degree" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="degree"><span class="header-section-number">9.1</span> Degree</h3>
<p>Degree describes how many edges a vertex has. In undirected networks, the degree of a vertex is simply the sum of edges connecting that vertex. But for directed networks, since we have some edges going out from a vertex and some edges going into the same vertex, we essentially have out-degrees and in-degrees. The figure given below illustrates this.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/degree.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">In-degrees and Out-degrees</figcaption><p></p>
</figure>
</div>
<p>Vertices with a high number of connections or with a high degree can be important. We can check the degrees of all vertices with the <code>degree()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the degrees of all vertices in the network</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="fu">degree</span>(graph, <span class="at">mode =</span> (<span class="st">'all'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Patient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 
           2            5            4            3            3            2 
    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 
           3            2            2            2            2            1 
   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 
           1            1            1            1            1            1 
   Person 18    Person 19    Person 20 
           1            1            1 </code></pre>
</div>
</div>
<p>From the results we can see that person 2 and person 1 have high degrees which suggests that they are important in the network. Essentially, person 1 and person 2 jump-started the infection in the community.</p>
</section>
<section id="betweenness" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="betweenness"><span class="header-section-number">9.2</span> Betweenness</h3>
<p>This is an index of how frequently the vertex lies on the shortest paths between any two vertices in the network. It can be thought of as how critical the vertex is to the flow of information through a network. Individuals with high betweenness are key bridges between different parts of a network. We can calculate the betweenness of each vertices using the <code>betweenness()</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the betweenness of all vertices in the network</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="fu">betweenness</span>(graph, <span class="at">directed =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Patient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 
           0           10            8            8            6            4 
    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 
           6            3            3            2            2            0 
   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 
           0            0            0            0            0            0 
   Person 18    Person 19    Person 20 
           0            0            0 </code></pre>
</div>
</div>
<p>From the output, person 2 has the most number of nodes branching outwards followed by person 1 and person 5. This might suggest that person 1, person 2, and person 5 might be playing an important role in spreading the disease.</p>
<p>We can also use the <code>nromalized = T</code> argument to get the normalized betweenness values.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the betweenness of all vertices in the network</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="fu">betweenness</span>(graph, <span class="at">directed =</span> T, <span class="at">normalized =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Patient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 
 0.000000000  0.026315789  0.021052632  0.021052632  0.015789474  0.010526316 
    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 
 0.015789474  0.007894737  0.007894737  0.005263158  0.005263158  0.000000000 
   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 
 0.000000000  0.000000000  0.000000000  0.000000000  0.000000000  0.000000000 
   Person 18    Person 19    Person 20 
 0.000000000  0.000000000  0.000000000 </code></pre>
</div>
</div>
</section>
<section id="eigenvector-centrality" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="eigenvector-centrality"><span class="header-section-number">9.3</span> Eigenvector centrality</h3>
<p>Centrality is a measure of an individual vertexe’s structural importance in a group based on its network position. Vertices with high eigenvector centrality are those that are connected to many other vertices but also to vertices that are themselves highly connected to other vertices. Eigenvector centrality can be calculated using the function <code>eigen_centrality()</code>. The function returns many other values also, but for now we are just focusing on the centrality value which is saved as <code>vector</code> in the output.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the eigenvector centrality of all vertices in the network</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="fu">eigen_centrality</span>(graph)<span class="sc">$</span>vector</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Patient Zero     Person 2     Person 1     Person 5     Person 4     Person 3 
  0.64109893   1.00000000   0.62990379   0.63313313   0.37411961   0.48145630 
    Person 8     Person 9    Person 10     Person 7     Person 6    Person 11 
  0.36061817   0.17408817   0.22403489   0.29311159   0.29311159   0.24903370 
   Person 12    Person 13    Person 14    Person 15    Person 16    Person 17 
  0.14184391   0.06847505   0.08812086   0.14715450   0.39333544   0.14184391 
   Person 18    Person 19    Person 20 
  0.39333544   0.11529118   0.11529118 </code></pre>
</div>
</div>
<p>Here in the output, Person 1,2,5, and patient zero are highly influential vertices in the network.</p>
<p>We can also plot the network with eigenvector centrality as a vertex size attribute.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Saving eigenvector centrality values</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>graph_eigen_vector <span class="ot">&lt;-</span> <span class="fu">eigen_centrality</span>(graph)<span class="sc">$</span>vector</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting the network</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph,</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.color =</span> <span class="st">"black"</span>,</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.cex =</span> <span class="fl">0.6</span>,</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.size =</span> <span class="dv">25</span><span class="sc">*</span>(graph_eigen_vector),</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Disease Outbreak Network"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-45-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="density" class="level3" data-number="9.4">
<h3 data-number="9.4" class="anchored" data-anchor-id="density"><span class="header-section-number">9.4</span> Density</h3>
<p>Density is the simplest way of measuring the overall structure of the network. Density is the proportion of edges that do exist in a network out of all those that potentially could exist between every pair of vertices in the network. A density value of 1 would suggest all possible vertices are present in the network, which would also mean that the network is highly interconnected. To calculate the density we use the function <code>edge_density()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the density of the network</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="fu">edge_density</span>(graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.04761905</code></pre>
</div>
</div>
<p>The value ~ 0.05 (approximately) suggests that 5% of the total possible vertices are present in our network.</p>
</section>
<section id="average-path-length" class="level3" data-number="9.5">
<h3 data-number="9.5" class="anchored" data-anchor-id="average-path-length"><span class="header-section-number">9.5</span> Average path length</h3>
<p>The average path length is the mean of the lengths of the shortest paths between all pairs of vertices in the network. We can use the function <code>mean_distance()</code> to the graph and instruct the function whether the graph is undirected or directed to find the value. Lower values of average path length suggest that the network is highly interconnected.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the average path length of the network</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean_distance</span>(graph, <span class="at">directed =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.981132</code></pre>
</div>
</div>
</section>
</section>
<section id="network-randomization-test" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="network-randomization-test"><span class="header-section-number">10</span> Network randomization test</h2>
<p>So far, we have seen the different kinds of measures used to determine the overall structure of the network. To check if the obtained value is unique to the network data at hand, we randomize our network data and calculate measures of network structure and compare them with the real values. To randomize our network, we use the function <code>erdos.renyi.game()</code>, which uses a particular algorithm to generate networks with a set probability of creating edges between the vertices in the network.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># generating a random network graph</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph), <span class="at">type =</span> <span class="st">'gnp'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IGRAPH 592bc49 U--- 21 8 -- Erdos-Renyi (gnp) graph
+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)
+ edges from 592bc49:
[1]  4-- 5  2-- 9 12--13  1--16 15--16 14--19 13--20  4--21</code></pre>
</div>
</div>
<p>Here we specify the number of vertices (given by <code>n = gorder(graph)</code>) and the probability of a given edge being connected between any two vertices, given by the argument <code>p.or.m = edge_density(graph)</code>. The <code>type = 'gnp'</code> argument tells R that the graph has ‘n’ vertices, and for each edge, the probability that it is present in the graph is ‘p’.</p>
<p>Let us calculate the average path length for this randomized network that we just created.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># setting seed for reproducibility</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="co"># generating a random network graph</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>random_graph <span class="ot">&lt;-</span> <span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph), <span class="at">type =</span> <span class="st">'gnp'</span>)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the average length of the random network</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="fu">mean_distance</span>(random_graph)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.904762</code></pre>
</div>
</div>
<p>From the result, we can see that the average path length is slightly less than our original average path length. However, this is not enough to conclude that the original value we got is different from the random value. Therefore, let us repeat this randomization 1000 times, calculate the average path length each time, and check how many networks are greater or lesser than the average path length we originally calculated. This way, we can confidently say whether our original value is particularly different from that of the random values. This process is called a network randomization test. In summary, a randomization test tells us whether the features of our original network are particularly unusual or not.</p>
<p>So the pipeline that we will be following for network randomization is the following:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<div>
<pre class="mermaid mermaid-js">%%{init: {'theme': 'default'}}%%
graph TD
    A[Generating 1000 random networks with the same number of vertices and with a similar edge density as that of the original network]
    B[Calculate the average path length of the original network]
    C[Calculate the average path length for all 1000 randomly generated networks]
    D[Determine how many random networks are greater than or less than the average path length of the original network]
    A--&gt;B
    B--&gt;C
    C--&gt;D
</pre>
</div>
</div>
</div>
</div>
<p>Now let us calculate generate and calculate the average path length for 1000 random networks. We are using the <code>graph</code> igraph object which we created last time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-47"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-47-1"><a href="#annotated-cell-47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="annotated-cell-47-2"><a href="#annotated-cell-47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="annotated-cell-47-3"><a href="#annotated-cell-47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-47-4"><a href="#annotated-cell-47-4" aria-hidden="true" tabindex="-1"></a><span class="co"># generating an empty list with 1000 entries</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-47" data-target-annotation="1">1</button><span id="annotated-cell-47-5" class="code-annotation-target"><a href="#annotated-cell-47-5" aria-hidden="true" tabindex="-1"></a>list_empty <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="st">'list'</span>, <span class="dv">1000</span>)</span>
<span id="annotated-cell-47-6"><a href="#annotated-cell-47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-47-7"><a href="#annotated-cell-47-7" aria-hidden="true" tabindex="-1"></a><span class="co"># generating 1000 random networks and saving them in the empty list</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-47" data-target-annotation="2">2</button><span id="annotated-cell-47-8" class="code-annotation-target"><a href="#annotated-cell-47-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>){</span>
<span id="annotated-cell-47-9"><a href="#annotated-cell-47-9" aria-hidden="true" tabindex="-1"></a>  list_empty[[i]] <span class="ot">&lt;-</span> <span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph),</span>
<span id="annotated-cell-47-10"><a href="#annotated-cell-47-10" aria-hidden="true" tabindex="-1"></a>                              <span class="at">type =</span> <span class="st">"gnp"</span>)</span>
<span id="annotated-cell-47-11"><a href="#annotated-cell-47-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="annotated-cell-47-12"><a href="#annotated-cell-47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-47-13"><a href="#annotated-cell-47-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the average path length of 1000 random graphs</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-47" data-target-annotation="3">3</button><span id="annotated-cell-47-14" class="code-annotation-target"><a href="#annotated-cell-47-14" aria-hidden="true" tabindex="-1"></a>list_empty_avg_path <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">lapply</span>(list_empty, mean_distance, <span class="at">directed =</span> T))</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-47" data-target-annotation="1">1</dt>
<dd>
<span data-code-lines="5" data-code-cell="annotated-cell-47" data-code-annotation="1">First we generate an empty list with 1000 <code>NULL</code> entries which we will be using to store our 1000 random networks.</span>
</dd>
<dt data-target-cell="annotated-cell-47" data-target-annotation="2">2</dt>
<dd>
<span data-code-lines="8" data-code-cell="annotated-cell-47" data-code-annotation="2">The for loop generates 1000 random networks using the Erdős-Rényi model with the same number of vertices and edge density as the original network (which is got from the <code>graph</code> object, which we had saved earlier). The networks are then saved in the empty list created in the previous step.</span>
</dd>
<dt data-target-cell="annotated-cell-47" data-target-annotation="3">3</dt>
<dd>
<span data-code-lines="14" data-code-cell="annotated-cell-47" data-code-annotation="3">This line uses the <code>lapply()</code> function to apply the <code>mean_distance()</code> function to each element in the <code>list_empty</code> list, which calculates the average path length for each of the 1000 random networks. The <code>unlist()</code> function is used to convert the resulting list of average path lengths into a vector.</span>
</dd>
</dl>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the distribution of average path lengths</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(list_empty_avg_path) </span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="fu">average.path.length</span>(graph, <span class="at">directed =</span> T), <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">lty =</span> <span class="dv">3</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-49" data-target-annotation="4">4</dt>
<dd>
<span data-code-lines="2" data-code-cell="annotated-cell-49" data-code-annotation="4">The above code generates a histogram of the distribution of average path lengths for the 1000 random networks using the <code>hist()</code> function. The second line adds a vertical line at the average path length of the original network using the <code>abline()</code> function. Finally, the last line calculates the proportion of random networks that have an average path length less than that of the original network using the <code>mean()</code> function. The comparison is done using the <code>&lt;</code> operator and the <code>average.path.length()</code> function calculates the average path length of the original network.</span>
</dd>
</dl>
</div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-52-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="annotated-cell-49"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-49-1"><a href="#annotated-cell-49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the proportion of graphs with an average path length lower than our observed</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-49" data-target-annotation="4">4</button><span id="annotated-cell-49-2" class="code-annotation-target"><a href="#annotated-cell-49-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(list_empty_avg_path <span class="sc">&lt;</span> <span class="fu">average.path.length</span>(graph, <span class="at">directed =</span> T))</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.534</code></pre>
</div>
</div>
<p>From the histogram we can see that our original average path length, which is represented as a red dotted vertical line lies among the randomly generate list average path length. The high interconnectedness we observe in our original data may be due to random chance alone.</p>
</section>
<section id="network-substructures" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="network-substructures"><span class="header-section-number">11</span> Network substructures</h2>
<p>Until now we have looked at features that describe the network structure. In this section, we will learn about microstructural features of social networks that can be informative as to how a network functions.</p>
<section id="triangles-triads" class="level3" data-number="11.1">
<h3 data-number="11.1" class="anchored" data-anchor-id="triangles-triads"><span class="header-section-number">11.1</span> Triangles (triads)</h3>
<p>In a network, a triangle is a collection of three nodes (or vertices) that are all connected. A high number of triangles in a network indicates that nodes tend to be highly interconnected, forming dense clusters or communities. In contrast, a low number of triangles suggests that nodes are more sparsely connected and less likely to form tightly-knit groups.</p>
<p>We can use the function <code>triangles()</code> to show all the triangles in the network. Let us the <code>df_rel_ig</code> igraph object that we created at the beginning of this tutorial.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the network</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-53-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co"># show all triangles in the network.</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="fu">matrix</span>(<span class="fu">triangles</span>(df_rel_ig), <span class="at">nrow =</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    1    5    5    9    9    9    9
[2,]    5    8    9    3    3    4    6
[3,]    8   10    6    4    7    6    7</code></pre>
</div>
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co"># counting triangles with Isabelle as the vertex</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="fu">count_triangles</span>(df_rel_ig, <span class="at">vids=</span> <span class="st">'Isabelle'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
</div>
<p>There are 3 triangles with Isabelle as the vertex.</p>
</section>
<section id="transitivity" class="level3" data-number="11.2">
<h3 data-number="11.2" class="anchored" data-anchor-id="transitivity"><span class="header-section-number">11.2</span> Transitivity</h3>
<p>The number of triangles in a network can be quantified using a metric called the clustering coefficient (transitivity). The clustering coefficient of a node is defined as the fraction of pairs of the node’s neighbors that are connected by an edge.</p>
<p>Global transitivity (also known as the global clustering coefficient) is a measure of the proportion of triangles in the entire network. It is the ratio of the total number of triangles in a network to the total number of possible triangles. High global transitivity indicates that the nodes in the network are highly interconnected, forming tightly-knit clusters.</p>
<p>To calculate the global transitivity, we can use the function <code>transitivity()</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculating global transitivity </span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="fu">transitivity</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.328125</code></pre>
</div>
</div>
<p>The value 0.32 means that 32% of the total possible triangles are represented in the given network.</p>
<p>Local transitivity (also known as local clustering coefficient) is a measure of the transitivity of individual nodes or small groups of nodes in the network. It is the proportion of triangles that exist among the neighbors of a given node to the total number of possible triangles among those neighbors. A high local transitivity indicates that a node’s neighbors are highly interconnected, forming a cluster or clique, while a low local transitivity suggests that the node’s neighbors are not well-connected to each other.</p>
<p>To calculate the local transitivity, we again use the function <code>transitivity()</code> but also include the following arguments to specify the individual vertex (<code>vids =</code>) and also specify that we want to calculate the local transitivity (<code>type = 'local'</code>)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating local transitivity around Isabelle</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="fu">transitivity</span>(df_rel_ig, <span class="at">vids =</span> <span class="st">'Isabelle'</span>, <span class="at">type =</span> <span class="st">'local'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3</code></pre>
</div>
</div>
<p>The value 0.3 means that, 30% of the total possible triangles with Isabelle as a vertex is represented in the given network.</p>
<p>In summary, global transitivity measures the extent of clustering in the entire network, while local transitivity measures the extent of clustering around individual nodes or small groups of nodes in the network.</p>
</section>
<section id="cliques" class="level3" data-number="11.3">
<h3 data-number="11.3" class="anchored" data-anchor-id="cliques"><span class="header-section-number">11.3</span> Cliques</h3>
<p>A clique is a subset of nodes in a network where each node is directly connected to every other node in the subset. In other words, a clique is a fully connected subgraph, where every node in the subset has a direct edge to every other node in the subset.</p>
<p>We can use the <code>largest_cliques()</code> function to find the largest clique in the network</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the largest clique in the network</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="fu">largest_cliques</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
+ 3/10 vertices, named, from 53fc946:
[1] Alice    Isabelle Grace   

[[2]]
+ 3/10 vertices, named, from 53fc946:
[1] David Frank Eve  

[[3]]
+ 3/10 vertices, named, from 53fc946:
[1] David   Frank   Charlie

[[4]]
+ 3/10 vertices, named, from 53fc946:
[1] Isabelle Frank    Charlie 

[[5]]
+ 3/10 vertices, named, from 53fc946:
[1] Isabelle John     Grace   

[[6]]
+ 3/10 vertices, named, from 53fc946:
[1] Henry Frank Eve  

[[7]]
+ 3/10 vertices, named, from 53fc946:
[1] Henry   Frank   Charlie</code></pre>
</div>
</div>
<p>There are 7 cliques tied with 3 vertices.</p>
<p>We can use <code>max_cliques()</code> function to showcase the biggest cliques for each number of vertexes (min. 2 vertices are required for a clique)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co"># finding maximum cliques</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="fu">max_cliques</span>(df_rel_ig)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
+ 2/10 vertices, named, from 53fc946:
[1] Bob   Alice

[[2]]
+ 2/10 vertices, named, from 53fc946:
[1] Bob  John

[[3]]
+ 3/10 vertices, named, from 53fc946:
[1] Alice    Isabelle Grace   

[[4]]
+ 3/10 vertices, named, from 53fc946:
[1] David Frank Eve  

[[5]]
+ 3/10 vertices, named, from 53fc946:
[1] David   Frank   Charlie

[[6]]
+ 2/10 vertices, named, from 53fc946:
[1] David John 

[[7]]
+ 3/10 vertices, named, from 53fc946:
[1] Isabelle Frank    Charlie 

[[8]]
+ 3/10 vertices, named, from 53fc946:
[1] Isabelle John     Grace   

[[9]]
+ 2/10 vertices, named, from 53fc946:
[1] John  Henry

[[10]]
+ 3/10 vertices, named, from 53fc946:
[1] Henry Frank Eve  

[[11]]
+ 3/10 vertices, named, from 53fc946:
[1] Henry   Frank   Charlie

[[12]]
+ 2/10 vertices, named, from 53fc946:
[1] Grace Eve  </code></pre>
</div>
</div>
<p><img src="images/network_structure.png" class="img-fluid" alt="Network substructures"> The figure given above illustrates a network featuring both closed and open triangles. In the figure, A-K-F, A-K-B, E-G-L are some of the closed triangles in the networks, similarly, J-H-I, E-G-J, E-A-H are open triangles with only two edges, H-I,C and F-C,H are open triangles with only one edge and E,J,I and H,E,C are some of the open triangles with no edges. Here A-C-F-K forms a clique. It should also be noted that a clique of size 3 (3 vertices) is a triangle.</p>
</section>
</section>
<section id="identifying-special-relationships" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="identifying-special-relationships"><span class="header-section-number">12</span> Identifying special relationships</h2>
<p>In this section, we will further explore the partitioning of networks into sub-networks and determine which vertices are more highly related to one another than others. We will also develop visualization methods by creating three-dimensional visualizations.</p>
<section id="assortativity" class="level3" data-number="12.1">
<h3 data-number="12.1" class="anchored" data-anchor-id="assortativity"><span class="header-section-number">12.1</span> Assortativity</h3>
<p>Let us take our initial dataset. In this dataset, we have illustrated the relationships between 20 people. One of the interesting questions that we can ask about this network is whether individuals preferably make friends with the same gender or with their same age groups. This is determined by the measure called ‘Assortativity’. Assortativity in network analysis refers to the tendency of nodes in a network to be connected to other nodes with similar properties or characteristics. In other words, nodes in an assortative network tend to be connected to other nodes that are like them in some way, such as having similar degrees, attributes, or other characteristics. In our networks, people might be preferably chosen to be in a relationship with other people who are of the same gender or age group.</p>
<p>The function to calculate the assortativity of a network is <code>assortativity()</code>. This function takes in two arguments, first is the igraph object and second is the attribute that is common among the vertices. In our dataset, let us use gender as the common attribute. If the common attribute is numeric, then we can directly input the values, but if it’s categorical we have to first change it into numeric factor. In our case, we have to change the values of M and F to 0 and 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co"># setting gender as the vertex attribute</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig, <span class="st">"gender"</span>, <span class="at">value =</span> df_names<span class="sc">$</span>gender)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting our network</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig_gender)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-58-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co"># converting gender values to numeric values</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>gender_value <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">factor</span>(<span class="fu">V</span>(df_rel_ig_gender)<span class="sc">$</span>gender))</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the assortativity</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="fu">assortativity</span>(df_rel_ig_gender, gender_value)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.1027569</code></pre>
</div>
</div>
<p>Assortativity value ranges from -1 to 1. A value of -1 means that the vertices actively avoid forming relationships with similar vertices, 0 means that the vertices have no preferences in making connections and 1 means that the vertices actively like to form relationships with similar vertices. Here, we have a value of -0.1 which is approximately close to zero, which means the vertices form relationships with each other irrespective of their gender.</p>
</section>
<section id="assortativity-degree" class="level3" data-number="12.2">
<h3 data-number="12.2" class="anchored" data-anchor-id="assortativity-degree"><span class="header-section-number">12.2</span> Assortativity degree</h3>
<p>Another similar value is the assortativity degree. It refers to the extent to which nodes in a network tend to be connected to other nodes with similar degrees. It measures the correlation between the degrees of connected nodes in a network and can be quantified using the degree assortativity coefficient.</p>
<p>The degree assortativity coefficient ranges from -1 to 1, with values close to 1 indicating a highly assortative network, where nodes with high degrees tend to be connected to other nodes with high degrees, and nodes with low degrees tend to be connected to other nodes with low degrees. Values close to -1 indicate a disassortative network, where high-degree nodes tend to be connected to low-degree nodes and vice versa. Finally, a value close to 0 indicates a random network, where there is no particular correlation between the degrees of connected nodes.</p>
<p>We can use the function <code>assortativity.degree()</code> to calculate the assortativity degree.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the assortativity degree</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="fu">assortativity.degree</span>(df_rel_ig_gender, <span class="at">directed =</span> F)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.01639344</code></pre>
</div>
</div>
<p>We have a value of 0.01 which is again close to 0, which means that the vertices in our network do not care about the degree of other vertices while forming connections.</p>
</section>
<section id="reciprocity" class="level3" data-number="12.3">
<h3 data-number="12.3" class="anchored" data-anchor-id="reciprocity"><span class="header-section-number">12.3</span> Reciprocity</h3>
<p>Reciprocity in networks refers to the extent to which pairs of nodes in a network have mutual connections. In other words, if node A is connected to node B and node B is also connected to node A, then there is reciprocity between the two nodes.</p>
<p>Reciprocity can be measured using the reciprocity coefficient, which is the ratio of the number of reciprocated edges (i.e., edges that connect two nodes that are mutually connected) to the total number of edges in the network. The reciprocity coefficient ranges from 0 to 1, with higher values indicating a greater degree of reciprocity in the network.</p>
<p>Reciprocity is an important concept in network analysis because it can have significant implications for the structure and dynamics of networks. Networks with high levels of reciprocity tend to have stronger ties between nodes and be more densely connected, while networks with low levels of reciprocity tend to be more sparsely connected and have weaker ties between nodes.</p>
<p>Reciprocity can be calculated using the function <code>reciprocity()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the reciprocity</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reciprocity</span>(df_rel_ig_gender)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Since our original graph object is undirected, we get the value 1.</p>
</section>
</section>
<section id="community-detection" class="level2" data-number="13">
<h2 data-number="13" class="anchored" data-anchor-id="community-detection"><span class="header-section-number">13</span> Community detection</h2>
<p>Networks sometimes form clusters or communities where a group of vertices with similar attributes form close connections compared to others. This is referred to as community defection. Community detection in network analysis refers to the process of identifying groups or clusters of nodes that are densely connected within a larger network. These groups are often referred to as communities, clusters, or modules, and can provide insights into the organization and function of the network.</p>
<p>There are many algorithms to identify communities in a network. We will be looking at two of them; greedy optimization algorithm (<code>cluster_fast_greedy()</code>) and Girvan-Newman algorithm (<code>cluster_edge_betweenness()</code>).</p>
<p>The greedy optimization algorithm iteratively merges nodes or communities in the network to maximize the modularity of the resulting partition. Modularity is a measure of the density of edges within communities compared to the expected density of edges in a randomized network. Maximizing modularity is a common criterion for community detection in networks because it reflects the degree to which the network is organized into cohesive and densely connected communities. The greedy optimization algorithm starts with each node in its community and iteratively merges the most similar communities until the modularity of the resulting partition can no longer be increased.</p>
<p>The Girvan-Newman algorithm iteratively removes the edges with the highest betweenness centrality in the network, which are the edges that are most frequently traversed by the shortest paths between pairs of nodes in the network. The removal of these edges gradually breaks the network into smaller and smaller clusters or communities. It is widely used for community detection in complex networks because it is relatively fast and can detect communities of varying sizes and shapes.</p>
<section id="fast-greedy-community-detection" class="level3" data-number="13.1">
<h3 data-number="13.1" class="anchored" data-anchor-id="fast-greedy-community-detection"><span class="header-section-number">13.1</span> Fast-greedy community detection</h3>
<p>Using the <code>cluster_fast_greedy()</code> function let us find if there exist any communities in our dataset <code>df_rel_ig_gender</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform fast-greedy community detection on the network graph</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>fg <span class="ot">=</span> <span class="fu">cluster_fast_greedy</span>(df_rel_ig_gender)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the <code>sizes()</code> function, we can see the number of members in each of the communities.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine the sizes of each community</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sizes</span>(fg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Community sizes
1 2 
6 4 </code></pre>
</div>
</div>
<p>The output shows that Community 1 has 6 members and Community 2 has 4 members.</p>
<p>The <code>membership()</code> function shows to which community each of the members belongs to.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine which individuals belong to which community</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="fu">membership</span>(fg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    John      Bob      Eve    David Isabelle  Charlie    Henry    Grace 
       1        1        1        2        1        2        2        1 
   Frank    Alice 
       2        1 </code></pre>
</div>
</div>
<p>To plot the community structure, we can simply use input from the ‘communities’ object that we have created using the algorithm function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the community structure of the network</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fg, df_rel_ig_gender)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-64-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="edge-betweenness-community-detection" class="level3" data-number="13.2">
<h3 data-number="13.2" class="anchored" data-anchor-id="edge-betweenness-community-detection"><span class="header-section-number">13.2</span> Edge-betweenness community detection</h3>
<p>Similar to the earlier case, we use the <code>cluster_edge_betweenness ()</code> function to find the communities in our dataset <code>df_rel_ig_gender</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform edge-betweenness community detection on the network graph</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>eb <span class="ot">=</span> <span class="fu">cluster_edge_betweenness</span>(df_rel_ig_gender)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine sizes of each community</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sizes</span>(eb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Community sizes
1 2 3 
3 2 5 </code></pre>
</div>
</div>
<p>The output shows that Community 1 has 3 members community 2 has 2 members and Community 3 has 5 members.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine which individuals belong to which community</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="fu">membership</span>(eb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    John      Bob      Eve    David Isabelle  Charlie    Henry    Grace 
       1        2        3        3        1        3        3        1 
   Frank    Alice 
       3        2 </code></pre>
</div>
</div>
<p>Let us now compare both graphs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting both graphs side-wise</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fg, df_rel_ig_gender, <span class="at">main=</span> <span class="st">"Fast-greedy"</span>)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(eb, df_rel_ig_gender, <span class="at">main=</span> <span class="st">"Edge-betweenness"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="network_analysis_files/figure-html/unnamed-chunk-67-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In general, the cluster-fast greedy algorithm is faster and more scalable than the cluster_edge_betweenness algorithm and is a good choice for large networks with many nodes and edges. It can detect communities of varying sizes and shapes and is less sensitive to noise.</p>
<p>On the other hand, the cluster edge betweenness algorithm is more computationally expensive and may be more appropriate for smaller networks. It can also be useful for identifying communities that are not well-separated or that overlap with each other.</p>
</section>
</section>
<section id="interactive-network-visualizations" class="level2" data-number="14">
<h2 data-number="14" class="anchored" data-anchor-id="interactive-network-visualizations"><span class="header-section-number">14</span> Interactive network visualizations</h2>
<p>One of the coolest things about network analysis is the visualization process. Up until now, we have only plotted static graphs. In this section, we will plot networks that can be physically (with a mouse pointer) interacted with using the <code>{threejs}</code> package in R. We will only cover the basics of 3D visualization.</p>
<p>Plotting the graph is as simple as using the function <code>graphjs()</code> from the <code>{threejs}</code> package.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(threejs)) <span class="fu">install.packages</span>(<span class="st">'threejs'</span>)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(threejs)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting our previous network</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="fu">graphjs</span>(df_rel_ig_gender)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="scatterplotThree html-widget html-fill-item-overflow-hidden html-fill-item" id="L8kJrngjMw" style="width:100%;height:464px;"></div>
<script type="application/json" data-for="L8kJrngjMw">{"x":{"NROW":10,"height":null,"width":null,"axis":false,"numticks":[6,6,6],"xticklabs":null,"yticklabs":null,"zticklabs":null,"color":["#FFA500"],"size":2,"stroke":"black","flipy":true,"grid":false,"renderer":"auto","signif":8,"bg":"white","cexsymbols":1,"xlim":[-1,1],"ylim":[-1,1],"zlim":[-1,1],"axisscale":[1,1,1],"pch":["@","@","@","@","@","@","@","@","@","@"],"elementId":"L8kJrngjMw","from":[[0,2,0,4,0,3,2,4,0,4,2,4,2,0,6,7,1,5,3,5]],"to":[[1,3,4,5,6,5,7,7,7,8,6,9,8,3,8,9,9,8,8,6]],"lwd":1,"linealpha":1,"center":true,"main":[""],"options":true,"alpha":[1],"vertices":[[-0.48000535,0.050334145,-0.43971801,-1,-0.89020335,-1,1,0.67698797,-0.26050653,0.15855213,1,0.20097958,0.15411788,-0.25009526,0.40362007,-0.3851331,0.53220685,1,-0.4215466,0.72446446,0.05080441,0.76990088,-0.25336217,-0.48621616,0.54187606,0.58589198,0.69405843,0.12555554,-1,-0.38494864]],"xticklab":["-1.00","-0.60","-0.20","0.20","0.60","1.00"],"yticklab":["-1.00","-0.60","-0.20","0.20","0.60","1.00"],"zticklab":["1.00","0.60","0.20","-0.20","-0.60","-1.00"],"xtick":[0,0.2,0.4,0.6,0.8,1],"ytick":[0,0.2,0.4,0.6,0.8,1],"ztick":[0,0.2,0.4,0.6,0.8,1],"axislength":[1,1,1]},"evals":[],"jsHooks":[]}</script>
</div>
</div>
<p>We can finally move our networks!</p>
<p>Let us re-plot the network we got after using the fast-greedy community algorithm. Since the size of the network is 2, we denote two colors to represent each of the two communities. You can also hover over the vertices to display its name on top.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(threejs)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform fast-greedy community detection on network graph</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>fg <span class="ot">=</span> <span class="fu">cluster_fast_greedy</span>(df_rel_ig_gender)</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an object 'i' containing the memberships of the fast-greedy community detection</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span>  <span class="fu">membership</span>(fg)</span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the number of different communities</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>size_fg <span class="ot">&lt;-</span> <span class="fu">sizes</span>(fg)</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a color attribute to each vertex, setting the vertex color based on community membership</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig_gender, <span class="st">"color"</span>, <span class="at">value =</span> <span class="fu">c</span>(<span class="st">"yellow"</span>, <span class="st">"blue"</span>)[i])</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the graph using threejs</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a><span class="fu">graphjs</span>(g, <span class="at">vertex.label =</span> df_names<span class="sc">$</span>name)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="scatterplotThree html-widget html-fill-item-overflow-hidden html-fill-item" id="KRQh8YnEss" style="width:100%;height:464px;"></div>
<script type="application/json" data-for="KRQh8YnEss">{"x":{"NROW":10,"height":null,"width":null,"axis":false,"numticks":[6,6,6],"xticklabs":null,"yticklabs":null,"zticklabs":null,"color":[["#FFFF00","#FFFF00","#FFFF00","#0000FF","#FFFF00","#0000FF","#0000FF","#FFFF00","#0000FF","#FFFF00"]],"size":2,"stroke":"black","flipy":true,"grid":false,"renderer":"auto","signif":8,"bg":"white","cexsymbols":1,"xlim":[-1,1],"ylim":[-1,1],"zlim":[-1,1],"axisscale":[1,1,1],"pch":["@","@","@","@","@","@","@","@","@","@"],"elementId":"KRQh8YnEss","from":[[0,2,0,4,0,3,2,4,0,4,2,4,2,0,6,7,1,5,3,5]],"to":[[1,3,4,5,6,5,7,7,7,8,6,9,8,3,8,9,9,8,8,6]],"lwd":1,"linealpha":1,"center":true,"main":[""],"labels":["Alice","Bob","Charlie","David","Eve","Frank","Grace","Henry","Isabelle","John"],"options":true,"alpha":[[1,1,1,1,1,1,1,1,1,1]],"vertices":[[-0.57488598,-0.034397014,-0.60417951,-0.79258009,1,-1,0.84281947,-0.75627011,-0.46899491,-0.21869611,-1,0.012123607,0.18791091,0.17498352,0.52810042,-0.84453286,-0.62833068,1,-1,-0.73242732,-0.13251548,1,0.21183803,-0.50057129,0.27437144,-0.72179706,0.6405584,0.54006203,0.99029912,-0.21659124]],"xticklab":["-1.00","-0.60","-0.20","0.20","0.60","1.00"],"yticklab":["-1.00","-0.60","-0.20","0.20","0.60","1.00"],"zticklab":["1.00","0.60","0.20","-0.20","-0.60","-1.00"],"xtick":[0,0.2,0.4,0.6,0.8,1],"ytick":[0,0.2,0.4,0.6,0.8,1],"ztick":[0,0.2,0.4,0.6,0.8,1],"axislength":[1,1,1]},"evals":[],"jsHooks":[]}</script>
</div>
</div>
<p>With that, we have successfully learned the basics of network analysis using R.</p>
</section>
<section id="conclusion" class="level2" data-number="15">
<h2 data-number="15" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">15</span> Conclusion</h2>
<p>In short, we learned about;</p>
<ol type="1">
<li>What is a network and what are the different ways to denote the network data?</li>
<li>How to convert the network data into an igraph object to analyze and plot the network via the <code>{igraph}</code> package in R.</li>
<li>What are vertex and edge attributes and how do add them to the igraph object?</li>
<li>How do filter attributes and how can we visualize them?</li>
<li>What are the different types of network visualizations?</li>
<li>What are directed networks?</li>
<li>What is path length?</li>
<li>What are the different measures of network structure?</li>
<li>What is network randomization test and why is its purpose?</li>
<li>what are the different network substructures?</li>
<li>How to identify special relationships in the network?</li>
<li>How to find communities in a network?</li>
<li>How to visualize the network in 3D using the <code>{threejs}</code> package ?</li>
</ol>
<p>This tutorial is based on my notes from attending the ‘Network Analysis in R’ course on DataCamp. As with any personal notes, there may be mistakes and some of the information presented may not accurately reflect the topic. If you notice any errors, please feel free to leave a comment in the section below.</p>
<p>I am particularly interested in learning about 3D visualization techniques, which I find to be fascinating. If I am able to learn more about this topic, I will write a sequel to this tutorial. Thank you for reading!</p>
<p><a hidden="" href="https://info.flagcounter.com/ynrK"><img src="https://s11.flagcounter.com/count2/ynrK/bg_000000/txt_FFFFFF/border_F0F0F0/columns_5/maxflags_25/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></p>


<!-- -->

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{johnson2023,
  author = {Johnson, Jewel},
  title = {Introduction to {Network} {Analysis} in {R}},
  date = {2023-04-06},
  url = {https://sciquest.netlify.app//tutorials/network_analysis/network_analysis.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-johnson2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Johnson, Jewel. 2023. <span>“Introduction to Network Analysis in
R.”</span> April 6, 2023. <a href="https://sciquest.netlify.app//tutorials/network_analysis/network_analysis.html">https://sciquest.netlify.app//tutorials/network_analysis/network_analysis.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Handle positioning of the toggle
      window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          trigger: 'click',
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          positionFixed: true,
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="jeweljohnsonj/SciQuest" data-repo-id="R_kgDOHW124A" data-category="General" data-category-id="DIC_kwDOHW124M4CPNVL" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb122" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Introduction to Network Analysis in R"</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> "Learn to build and analyze network data using R"</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "04/06/2023"</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="an">code-annotations:</span><span class="co"> select</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="co">    css:</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a><span class="co">      - https://cdn.knightlab.com/libs/juxtapose/latest/css/juxtapose.css</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> images/network_analysis.png</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [network analysis]</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="an">filters:</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a><span class="co">   - social-share</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a><span class="an">share:</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="co">  permalink: "https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html"</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a><span class="co">  description: "Introduction to Network Analysis in R"</span></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a><span class="co">  twitter: true</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a><span class="co">  facebook: true</span></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a><span class="co">  reddit: true</span></span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a><span class="co">  stumble: true</span></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a><span class="co">  tumblr: true</span></span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a><span class="co">  linkedin: true</span></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a><span class="co">  email: true</span></span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb122-28"><a href="#cb122-28" aria-hidden="true" tabindex="-1"></a><span class="fu">## TL;DR</span></span>
<span id="cb122-29"><a href="#cb122-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-30"><a href="#cb122-30" aria-hidden="true" tabindex="-1"></a>In this article we will learn;</span>
<span id="cb122-31"><a href="#cb122-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-32"><a href="#cb122-32" aria-hidden="true" tabindex="-1"></a><span class="ss">1.    </span>What is a network and what are the different ways to denote the network data?</span>
<span id="cb122-33"><a href="#cb122-33" aria-hidden="true" tabindex="-1"></a><span class="ss">2.    </span>How to convert the network data into an igraph object to analyze and plot the network via the <span class="in">`{igraph}`</span> package in R.</span>
<span id="cb122-34"><a href="#cb122-34" aria-hidden="true" tabindex="-1"></a><span class="ss">3.    </span>What are vertex and edge attributes and how do we add them to the igraph object?</span>
<span id="cb122-35"><a href="#cb122-35" aria-hidden="true" tabindex="-1"></a><span class="ss">4.    </span>How do we filter network attributes and how to visualize them?</span>
<span id="cb122-36"><a href="#cb122-36" aria-hidden="true" tabindex="-1"></a><span class="ss">5.    </span>What are the different types of network visualizations?</span>
<span id="cb122-37"><a href="#cb122-37" aria-hidden="true" tabindex="-1"></a><span class="ss">6.    </span>What are directed networks?</span>
<span id="cb122-38"><a href="#cb122-38" aria-hidden="true" tabindex="-1"></a><span class="ss">7.    </span>What is path length?</span>
<span id="cb122-39"><a href="#cb122-39" aria-hidden="true" tabindex="-1"></a><span class="ss">8.    </span>What are the different measures of network structure?</span>
<span id="cb122-40"><a href="#cb122-40" aria-hidden="true" tabindex="-1"></a><span class="ss">9.    </span>What is network randomization test and what is its purpose?</span>
<span id="cb122-41"><a href="#cb122-41" aria-hidden="true" tabindex="-1"></a><span class="ss">10.   </span>what are the different network substructures?</span>
<span id="cb122-42"><a href="#cb122-42" aria-hidden="true" tabindex="-1"></a><span class="ss">11.   </span>How to identify special relationships in the network?</span>
<span id="cb122-43"><a href="#cb122-43" aria-hidden="true" tabindex="-1"></a><span class="ss">12.   </span>How to find communities in a network?</span>
<span id="cb122-44"><a href="#cb122-44" aria-hidden="true" tabindex="-1"></a><span class="ss">13.   </span>How to visualize the network in 3D using the <span class="in">`{threejs}`</span> package</span>
<span id="cb122-45"><a href="#cb122-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-46"><a href="#cb122-46" aria-hidden="true" tabindex="-1"></a>We will be using the <span class="in">`{igprah}`</span> and <span class="in">`{threejs}`</span> packages in this tutorial.</span>
<span id="cb122-47"><a href="#cb122-47" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb122-48"><a href="#cb122-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-49"><a href="#cb122-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb122-50"><a href="#cb122-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-51"><a href="#cb122-51" aria-hidden="true" tabindex="-1"></a>In this tutorial, we will explore social networks and how to create and analyze them. A social network is a graphical representation of relationships between a group of individuals. For instance, the figure below shows a social network that could represent friendships among a group of people, bus routes to different locations in a city, or connections between different neurons.</span>
<span id="cb122-52"><a href="#cb122-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-53"><a href="#cb122-53" aria-hidden="true" tabindex="-1"></a><span class="al">![A graph depicting a social network](images/social_network.png)</span></span>
<span id="cb122-54"><a href="#cb122-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-55"><a href="#cb122-55" aria-hidden="true" tabindex="-1"></a>If we take a closer look at the figure, we can see that individual A has some kind of relationship with individuals B, C, and F, but not with D and E. The individuals, such as A, B, C, and so on, are called nodes or vertices, while the connections between them are known as lines, edges, or ties.</span>
<span id="cb122-56"><a href="#cb122-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-57"><a href="#cb122-57" aria-hidden="true" tabindex="-1"></a>Network data can be represented in different forms, such as an adjacency matrix or an edge list. The adjacency matrix for the network shown in the figure is provided below. In this matrix, each row and column corresponds to a vertex, and a value of 1 indicates the presence of an edge between the corresponding vertices.</span>
<span id="cb122-58"><a href="#cb122-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-61"><a href="#cb122-61" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-62"><a href="#cb122-62" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb122-63"><a href="#cb122-63" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: Code for making the adjacency matrix for the above figure</span></span>
<span id="cb122-64"><a href="#cb122-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-65"><a href="#cb122-65" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb122-66"><a href="#cb122-66" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-67"><a href="#cb122-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-68"><a href="#cb122-68" aria-hidden="true" tabindex="-1"></a>name1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">'a'</span>, <span class="dv">3</span>), <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>)</span>
<span id="cb122-69"><a href="#cb122-69" aria-hidden="true" tabindex="-1"></a>name2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'b'</span>,<span class="st">'c'</span>,<span class="st">'f'</span>,<span class="st">'d'</span>,<span class="st">'e'</span>,<span class="st">'e'</span>)</span>
<span id="cb122-70"><a href="#cb122-70" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(name1, name2)</span>
<span id="cb122-71"><a href="#cb122-71" aria-hidden="true" tabindex="-1"></a>rel_ig <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(rel)</span>
<span id="cb122-72"><a href="#cb122-72" aria-hidden="true" tabindex="-1"></a><span class="fu">as_adjacency_matrix</span>(rel_ig)</span>
<span id="cb122-73"><a href="#cb122-73" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-74"><a href="#cb122-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-75"><a href="#cb122-75" aria-hidden="true" tabindex="-1"></a>Alternatively, we can represent the same information in an edge list format, where all the edges in the network are listed in a 2x2 matrix.</span>
<span id="cb122-76"><a href="#cb122-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-79"><a href="#cb122-79" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-80"><a href="#cb122-80" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb122-81"><a href="#cb122-81" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: Code for making the edge list for the above figure</span></span>
<span id="cb122-82"><a href="#cb122-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-83"><a href="#cb122-83" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb122-84"><a href="#cb122-84" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-85"><a href="#cb122-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-86"><a href="#cb122-86" aria-hidden="true" tabindex="-1"></a>name1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">'a'</span>, <span class="dv">3</span>), <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>)</span>
<span id="cb122-87"><a href="#cb122-87" aria-hidden="true" tabindex="-1"></a>name2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'b'</span>,<span class="st">'c'</span>,<span class="st">'f'</span>,<span class="st">'d'</span>,<span class="st">'e'</span>,<span class="st">'e'</span>)</span>
<span id="cb122-88"><a href="#cb122-88" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(name1, name2)</span>
<span id="cb122-89"><a href="#cb122-89" aria-hidden="true" tabindex="-1"></a>rel_ig <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(rel)</span>
<span id="cb122-90"><a href="#cb122-90" aria-hidden="true" tabindex="-1"></a><span class="fu">as_edgelist</span>(rel_ig)</span>
<span id="cb122-91"><a href="#cb122-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-92"><a href="#cb122-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-93"><a href="#cb122-93" aria-hidden="true" tabindex="-1"></a>The edge list provided above displays each relationship or edge in the given social network through its rows. To gain a better understanding of how we can analyze and plot such data, let's work with a dataset resembling a real-life scenario.</span>
<span id="cb122-94"><a href="#cb122-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-95"><a href="#cb122-95" aria-hidden="true" tabindex="-1"></a><span class="fu">## Creating a dummy dataframe</span></span>
<span id="cb122-96"><a href="#cb122-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-97"><a href="#cb122-97" aria-hidden="true" tabindex="-1"></a>We will work with a synthetic dataset consisting of 10 individuals and their relationships, gender, and weekly call duration. This will allow us to explore how social network analysis can be applied to real-life scenarios. The dataset includes friendships between individuals and other attributes such as gender and call duration. Below is the code used to generate this dataset.</span>
<span id="cb122-98"><a href="#cb122-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-101"><a href="#cb122-101" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-102"><a href="#cb122-102" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-103"><a href="#cb122-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-104"><a href="#cb122-104" aria-hidden="true" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="cb122-105"><a href="#cb122-105" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb122-106"><a href="#cb122-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-107"><a href="#cb122-107" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dataframe with 10 names and gender</span></span>
<span id="cb122-108"><a href="#cb122-108" aria-hidden="true" tabindex="-1"></a>df_names <span class="ot">&lt;-</span> <span class="fu">data.frame</span>( <span class="co"># &lt;1&gt;</span></span>
<span id="cb122-109"><a href="#cb122-109" aria-hidden="true" tabindex="-1"></a>  <span class="at">name =</span> <span class="fu">c</span>(<span class="st">"Alice"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span>, <span class="st">"David"</span>, <span class="st">"Eve"</span>, <span class="st">"Frank"</span>,</span>
<span id="cb122-110"><a href="#cb122-110" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Grace"</span>, <span class="st">"Henry"</span>, <span class="st">"Isabelle"</span>, <span class="st">"John"</span>),</span>
<span id="cb122-111"><a href="#cb122-111" aria-hidden="true" tabindex="-1"></a>  <span class="at">gender =</span> <span class="fu">c</span>(<span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>)</span>
<span id="cb122-112"><a href="#cb122-112" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-113"><a href="#cb122-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-114"><a href="#cb122-114" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an empty dataframe to store the relationships</span></span>
<span id="cb122-115"><a href="#cb122-115" aria-hidden="true" tabindex="-1"></a>df_rel <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">name1 =</span> <span class="fu">character</span>(), <span class="at">name2 =</span> <span class="fu">character</span>(), <span class="co"># &lt;2&gt;</span></span>
<span id="cb122-116"><a href="#cb122-116" aria-hidden="true" tabindex="-1"></a>                     <span class="at">call_hours =</span> <span class="fu">numeric</span>()) </span>
<span id="cb122-117"><a href="#cb122-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-118"><a href="#cb122-118" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate random relationships with call hours</span></span>
<span id="cb122-119"><a href="#cb122-119" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="fu">nrow</span>(df_rel) <span class="sc">&lt;</span> <span class="dv">20</span>) { <span class="co"># &lt;3&gt;</span></span>
<span id="cb122-120"><a href="#cb122-120" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Randomly select two names</span></span>
<span id="cb122-121"><a href="#cb122-121" aria-hidden="true" tabindex="-1"></a>  name1 <span class="ot">&lt;-</span> <span class="fu">sample</span>(df_names<span class="sc">$</span>name, <span class="dv">1</span>) <span class="co"># &lt;4&gt;</span></span>
<span id="cb122-122"><a href="#cb122-122" aria-hidden="true" tabindex="-1"></a>  name2 <span class="ot">&lt;-</span> <span class="fu">sample</span>(df_names<span class="sc">$</span>name, <span class="dv">1</span>)</span>
<span id="cb122-123"><a href="#cb122-123" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb122-124"><a href="#cb122-124" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Check if the selected names are the same or have already been added to the dataframe</span></span>
<span id="cb122-125"><a href="#cb122-125" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (name1 <span class="sc">!=</span> name2 <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">any</span>((df_rel<span class="sc">$</span>name1 <span class="sc">==</span> name1 <span class="sc">&amp;</span> df_rel<span class="sc">$</span>name2 <span class="sc">==</span> name2) <span class="sc">|</span> <span class="co"># &lt;5&gt;</span></span>
<span id="cb122-126"><a href="#cb122-126" aria-hidden="true" tabindex="-1"></a>                            (df_rel<span class="sc">$</span>name1 <span class="sc">==</span> name2 <span class="sc">&amp;</span> df_rel<span class="sc">$</span>name2 <span class="sc">==</span> name1))) { </span>
<span id="cb122-127"><a href="#cb122-127" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the relationship with a random number of call hours between 1 and 10</span></span>
<span id="cb122-128"><a href="#cb122-128" aria-hidden="true" tabindex="-1"></a>    df_rel <span class="ot">&lt;-</span> <span class="fu">rbind</span>(df_rel, <span class="fu">data.frame</span>(<span class="at">name1 =</span> name1, <span class="at">name2 =</span> name2, <span class="co"># &lt;6&gt;</span></span>
<span id="cb122-129"><a href="#cb122-129" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">call_hours =</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">1</span>))) </span>
<span id="cb122-130"><a href="#cb122-130" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb122-131"><a href="#cb122-131" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb122-132"><a href="#cb122-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-133"><a href="#cb122-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Finally our dataset</span></span>
<span id="cb122-134"><a href="#cb122-134" aria-hidden="true" tabindex="-1"></a>df_rel <span class="co"># &lt;7&gt;</span></span>
<span id="cb122-135"><a href="#cb122-135" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-136"><a href="#cb122-136" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>First, the code creates a dataframe called df_names with 10 names and their genders.</span>
<span id="cb122-137"><a href="#cb122-137" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Then, an empty dataframe called df_rel is created to store the relationships.</span>
<span id="cb122-138"><a href="#cb122-138" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>The while loop is used to generate random relationships between the names until df_rel has 20 rows.</span>
<span id="cb122-139"><a href="#cb122-139" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Inside the while loop, two names are randomly selected from the name column of df_names using the sample function.</span>
<span id="cb122-140"><a href="#cb122-140" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>The if statement checks whether the two names are the same or whether they have already been added as a relationship to df_rel. If either of these conditions is true, the loop moves on to select a new pair of names.</span>
<span id="cb122-141"><a href="#cb122-141" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>If the two names are different and have not been added to df_rel, a new row is added to df_rel with the selected names and a randomly generated number between 1 and 10 as the number of call hours.</span>
<span id="cb122-142"><a href="#cb122-142" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Once df_rel has 20 rows, the loop stops, and the final dataframe is printed using print(df_rel).</span>
<span id="cb122-143"><a href="#cb122-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-144"><a href="#cb122-144" aria-hidden="true" tabindex="-1"></a><span class="fu">## Converting dataframe to network data</span></span>
<span id="cb122-145"><a href="#cb122-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-146"><a href="#cb122-146" aria-hidden="true" tabindex="-1"></a>To convert our dataframe into network data, we'll be using the {igraph} package in R and the graph.edgelist() function. However, before we can do that, we need to make sure that our dataframe is in the right format. The graph.edgelist() function requires a 2x2 edge list matrix, which means that our dataframe needs to be converted to a matrix using the as.matrix() function. For now, we'll also remove the call_hours column.</span>
<span id="cb122-147"><a href="#cb122-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-150"><a href="#cb122-150" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-151"><a href="#cb122-151" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-152"><a href="#cb122-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-153"><a href="#cb122-153" aria-hidden="true" tabindex="-1"></a><span class="co"># Installing and loading the igraph package</span></span>
<span id="cb122-154"><a href="#cb122-154" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(igraph)) <span class="fu">install.packages</span>(<span class="st">'igraph'</span>)</span>
<span id="cb122-155"><a href="#cb122-155" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-156"><a href="#cb122-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-157"><a href="#cb122-157" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating an igraph object</span></span>
<span id="cb122-158"><a href="#cb122-158" aria-hidden="true" tabindex="-1"></a>df_rel_mx <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(df_rel[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb122-159"><a href="#cb122-159" aria-hidden="true" tabindex="-1"></a>df_rel_ig <span class="ot">&lt;-</span> <span class="fu">graph.edgelist</span>(df_rel_mx, <span class="at">directed =</span> F)</span>
<span id="cb122-160"><a href="#cb122-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-161"><a href="#cb122-161" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb122-162"><a href="#cb122-162" aria-hidden="true" tabindex="-1"></a>df_rel_ig</span>
<span id="cb122-163"><a href="#cb122-163" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-164"><a href="#cb122-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-165"><a href="#cb122-165" aria-hidden="true" tabindex="-1"></a><span class="ss">1.    </span>In the first line of the output, the first number; 10 indicates that there are 10 vertices, and 20 means that there are 20 edges in the network.</span>
<span id="cb122-166"><a href="#cb122-166" aria-hidden="true" tabindex="-1"></a><span class="ss">2.    </span>Starting from the 4th line of the output, all the edges in the network are shown. These are relationships in the dataset.</span>
<span id="cb122-167"><a href="#cb122-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-168"><a href="#cb122-168" aria-hidden="true" tabindex="-1"></a>Now let us plot the network using the <span class="in">`plot()`</span> function.</span>
<span id="cb122-169"><a href="#cb122-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-172"><a href="#cb122-172" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-173"><a href="#cb122-173" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig)</span>
<span id="cb122-174"><a href="#cb122-174" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-175"><a href="#cb122-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-176"><a href="#cb122-176" aria-hidden="true" tabindex="-1"></a>In the above graph, each person is represented as a vertex, shown in blue. The edges between them indicate that they are friends with each other.</span>
<span id="cb122-177"><a href="#cb122-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-178"><a href="#cb122-178" aria-hidden="true" tabindex="-1"></a>The <span class="in">`{igraph}`</span> package provides various functions to further analyze the network data. For instance, we can use the <span class="in">`V()`</span> function to view the vertices in the dataset.</span>
<span id="cb122-179"><a href="#cb122-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-182"><a href="#cb122-182" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-183"><a href="#cb122-183" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the nodes/vertices</span></span>
<span id="cb122-184"><a href="#cb122-184" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(df_rel_ig)</span>
<span id="cb122-185"><a href="#cb122-185" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-186"><a href="#cb122-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-187"><a href="#cb122-187" aria-hidden="true" tabindex="-1"></a>Similarly, using the <span class="in">`E()`</span> function returns all the edges.</span>
<span id="cb122-188"><a href="#cb122-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-191"><a href="#cb122-191" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-192"><a href="#cb122-192" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the edges</span></span>
<span id="cb122-193"><a href="#cb122-193" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(df_rel_ig)</span>
<span id="cb122-194"><a href="#cb122-194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-195"><a href="#cb122-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-196"><a href="#cb122-196" aria-hidden="true" tabindex="-1"></a>To get the number of vertices we can use <span class="in">`gorder()`</span> and for getting the number of edges we can use <span class="in">`gsize()`</span>.</span>
<span id="cb122-197"><a href="#cb122-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-200"><a href="#cb122-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-201"><a href="#cb122-201" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the no. of vertices</span></span>
<span id="cb122-202"><a href="#cb122-202" aria-hidden="true" tabindex="-1"></a><span class="fu">gorder</span>(df_rel_ig)</span>
<span id="cb122-203"><a href="#cb122-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-204"><a href="#cb122-204" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the no. of edges</span></span>
<span id="cb122-205"><a href="#cb122-205" aria-hidden="true" tabindex="-1"></a><span class="fu">gsize</span>(df_rel_ig)</span>
<span id="cb122-206"><a href="#cb122-206" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-207"><a href="#cb122-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-208"><a href="#cb122-208" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network attributes</span></span>
<span id="cb122-209"><a href="#cb122-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-210"><a href="#cb122-210" aria-hidden="true" tabindex="-1"></a><span class="fu">### Vertex attributes</span></span>
<span id="cb122-211"><a href="#cb122-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-212"><a href="#cb122-212" aria-hidden="true" tabindex="-1"></a>Let us once again look at the igraph object output for the data we are using.</span>
<span id="cb122-213"><a href="#cb122-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-216"><a href="#cb122-216" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-217"><a href="#cb122-217" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb122-218"><a href="#cb122-218" aria-hidden="true" tabindex="-1"></a>df_rel_ig</span>
<span id="cb122-219"><a href="#cb122-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-220"><a href="#cb122-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-221"><a href="#cb122-221" aria-hidden="true" tabindex="-1"></a>In the second line of the output, we can see the attributes of the vertices. The network attributes can be either categorical or numerical. In this case, the attribute 'name' is a categorical variable denoting a person's name as vertices. Examples of numerical attributes include the age of an individual, the population of a city, or revenue of a company, etc.</span>
<span id="cb122-222"><a href="#cb122-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-223"><a href="#cb122-223" aria-hidden="true" tabindex="-1"></a>The vertex attributes can be visualized using different shapes, colors, or sizes of the shape. To add a vertex attribute, we can use the <span class="in">`set_vertex_attr()`</span> function. In the function arguments, we first input the igraph object, then the attribute name that we choose to give, which in this case would be 'gender', and finally the values for that attribute. Therefore, we use our df_names dataframe that we created before to fetch the gender data as the vertex attribute.</span>
<span id="cb122-224"><a href="#cb122-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-227"><a href="#cb122-227" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-228"><a href="#cb122-228" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-229"><a href="#cb122-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-230"><a href="#cb122-230" aria-hidden="true" tabindex="-1"></a><span class="co"># Our dataframe with 10 names and gender</span></span>
<span id="cb122-231"><a href="#cb122-231" aria-hidden="true" tabindex="-1"></a>df_names <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb122-232"><a href="#cb122-232" aria-hidden="true" tabindex="-1"></a>  <span class="at">name =</span> <span class="fu">c</span>(<span class="st">"Alice"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span>, <span class="st">"David"</span>, <span class="st">"Eve"</span>, <span class="st">"Frank"</span>,</span>
<span id="cb122-233"><a href="#cb122-233" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Grace"</span>, <span class="st">"Henry"</span>, <span class="st">"Isabelle"</span>, <span class="st">"John"</span>),</span>
<span id="cb122-234"><a href="#cb122-234" aria-hidden="true" tabindex="-1"></a>  <span class="at">gender =</span> <span class="fu">c</span>(<span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>, <span class="st">"F"</span>, <span class="st">"M"</span>)</span>
<span id="cb122-235"><a href="#cb122-235" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-236"><a href="#cb122-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-237"><a href="#cb122-237" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding 'gender' as a vertex attribute</span></span>
<span id="cb122-238"><a href="#cb122-238" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig, <span class="st">"gender"</span>, <span class="at">value =</span> df_names<span class="sc">$</span>gender)</span>
<span id="cb122-239"><a href="#cb122-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-240"><a href="#cb122-240" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb122-241"><a href="#cb122-241" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender</span>
<span id="cb122-242"><a href="#cb122-242" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-243"><a href="#cb122-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-244"><a href="#cb122-244" aria-hidden="true" tabindex="-1"></a>In the igraph object output, in the second line, you can see that a new vertex attribute called 'gender' has been added, which is denoted by 'gender (v/c)'.</span>
<span id="cb122-245"><a href="#cb122-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-246"><a href="#cb122-246" aria-hidden="true" tabindex="-1"></a><span class="fu">### Edge attributes</span></span>
<span id="cb122-247"><a href="#cb122-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-248"><a href="#cb122-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-249"><a href="#cb122-249" aria-hidden="true" tabindex="-1"></a>Similar to vertex attributes, edges can also convey different information. The common form of edge attribute is by changing the width of the line connecting the vertices. Therefore, we can convey information such as the number of bus routes between two places or the number of phone calls between two friends by changing the width size.</span>
<span id="cb122-250"><a href="#cb122-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-251"><a href="#cb122-251" aria-hidden="true" tabindex="-1"></a>In our case, we can denote edge width to denote the call hours between two people. Similar to the previous case, we can use the set_edge_attr() function. The arguments for this function are similar to set_vertex_attr(), which we saw earlier.</span>
<span id="cb122-252"><a href="#cb122-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-253"><a href="#cb122-253" aria-hidden="true" tabindex="-1"></a>We extract the call hour information from the df_rel dataframe that we created earlier.</span>
<span id="cb122-254"><a href="#cb122-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-257"><a href="#cb122-257" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-258"><a href="#cb122-258" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding 'donations' as an edge attribute</span></span>
<span id="cb122-259"><a href="#cb122-259" aria-hidden="true" tabindex="-1"></a>df_rel_ig_call <span class="ot">&lt;-</span> <span class="fu">set_edge_attr</span>(df_rel_ig, <span class="st">"call_hours"</span>,</span>
<span id="cb122-260"><a href="#cb122-260" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">value =</span> df_rel<span class="sc">$</span>call_hours)</span>
<span id="cb122-261"><a href="#cb122-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-262"><a href="#cb122-262" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb122-263"><a href="#cb122-263" aria-hidden="true" tabindex="-1"></a>df_rel_ig_call</span>
<span id="cb122-264"><a href="#cb122-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-265"><a href="#cb122-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-266"><a href="#cb122-266" aria-hidden="true" tabindex="-1"></a>Similar to the previous case, a new edge attribute called 'donations' have been added denoted by 'donations (e/n)'.</span>
<span id="cb122-267"><a href="#cb122-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-268"><a href="#cb122-268" aria-hidden="true" tabindex="-1"></a><span class="fu">### One-shot way to add attributes</span></span>
<span id="cb122-269"><a href="#cb122-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-270"><a href="#cb122-270" aria-hidden="true" tabindex="-1"></a>We can use the <span class="in">`graph_from_data_frame()`</span> function from the <span class="in">`{igraph}`</span> package to create an igraph object directly if we have the vertex and edge information as separate dataframes. In the function arguments, the <span class="in">`d`</span> parameter takes the edge list dataframe, where the first two columns contain the edges and the third column represents the edge attribute. Similarly, the vertices parameter takes the dataframe for vertex attributes, where the first column represents the vertices, and the remaining columns represent the vertex attributes.</span>
<span id="cb122-271"><a href="#cb122-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-272"><a href="#cb122-272" aria-hidden="true" tabindex="-1"></a>In our case, we can use the <span class="in">`df_rel`</span> dataframe for the d parameter, where the first two columns represent the edges, and the third column represents the call hours attribute. For the vertices parameter, we can use the <span class="in">`df_names`</span> dataframe, where the first column represents the vertices (person names), and the second column represents the vertex attribute (gender). By using <span class="in">`graph_from_data_frame()`</span> function, the vertex and edge attributes will be added to the igraph object automatically.</span>
<span id="cb122-273"><a href="#cb122-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-276"><a href="#cb122-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-277"><a href="#cb122-277" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-278"><a href="#cb122-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-279"><a href="#cb122-279" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding the attributes</span></span>
<span id="cb122-280"><a href="#cb122-280" aria-hidden="true" tabindex="-1"></a>drug_ig_complete <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(<span class="at">d =</span> df_rel, <span class="at">vertices =</span> df_names,</span>
<span id="cb122-281"><a href="#cb122-281" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">directed =</span> F)</span>
<span id="cb122-282"><a href="#cb122-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-283"><a href="#cb122-283" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the igraph object</span></span>
<span id="cb122-284"><a href="#cb122-284" aria-hidden="true" tabindex="-1"></a>drug_ig_complete</span>
<span id="cb122-285"><a href="#cb122-285" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-286"><a href="#cb122-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-287"><a href="#cb122-287" aria-hidden="true" tabindex="-1"></a>We can also use the functions; <span class="in">`vertex_attr()`</span> to view the vertex attributes and <span class="in">`edge_attr()`</span> to view edge attributes.</span>
<span id="cb122-288"><a href="#cb122-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-291"><a href="#cb122-291" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-292"><a href="#cb122-292" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing vertex attribute</span></span>
<span id="cb122-293"><a href="#cb122-293" aria-hidden="true" tabindex="-1"></a><span class="fu">vertex_attr</span>(drug_ig_complete)</span>
<span id="cb122-294"><a href="#cb122-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-295"><a href="#cb122-295" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing edge attribute</span></span>
<span id="cb122-296"><a href="#cb122-296" aria-hidden="true" tabindex="-1"></a><span class="fu">edge_attr</span>(drug_ig_complete)</span>
<span id="cb122-297"><a href="#cb122-297" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-298"><a href="#cb122-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-299"><a href="#cb122-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-300"><a href="#cb122-300" aria-hidden="true" tabindex="-1"></a><span class="fu">## Filtering attributes</span></span>
<span id="cb122-301"><a href="#cb122-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-302"><a href="#cb122-302" aria-hidden="true" tabindex="-1"></a>With different attributes in the network, we can use different filters and see the data differently. Suppose we can want to see what all edges include "John".</span>
<span id="cb122-303"><a href="#cb122-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-306"><a href="#cb122-306" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-307"><a href="#cb122-307" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing all friends of John</span></span>
<span id="cb122-308"><a href="#cb122-308" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(drug_ig_complete)[[<span class="fu">.inc</span>(<span class="st">'John'</span>)]]</span>
<span id="cb122-309"><a href="#cb122-309" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-310"><a href="#cb122-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-311"><a href="#cb122-311" aria-hidden="true" tabindex="-1"></a>The output shows all friends of John.</span>
<span id="cb122-312"><a href="#cb122-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-313"><a href="#cb122-313" aria-hidden="true" tabindex="-1"></a>Let us also check which friends call for more than 5 hours.</span>
<span id="cb122-314"><a href="#cb122-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-317"><a href="#cb122-317" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-318"><a href="#cb122-318" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing relationships with call hours of more than 5 hours</span></span>
<span id="cb122-319"><a href="#cb122-319" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(drug_ig_complete)[[call_hours <span class="sc">&gt;</span> <span class="dv">5</span>]]</span>
<span id="cb122-320"><a href="#cb122-320" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-321"><a href="#cb122-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-322"><a href="#cb122-322" aria-hidden="true" tabindex="-1"></a>There are 12 friendships where people call each other for more than 5 hours.</span>
<span id="cb122-323"><a href="#cb122-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-324"><a href="#cb122-324" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visualizing the attributes</span></span>
<span id="cb122-325"><a href="#cb122-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-326"><a href="#cb122-326" aria-hidden="true" tabindex="-1"></a>There are various ways to visualize both vertex and edge attributes in a network. For numerical attributes, we can change the size of the vertices and the width of the edges. For categorical attributes, we can change the color and shape of the vertices, and the line type and color of the edges.</span>
<span id="cb122-327"><a href="#cb122-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-328"><a href="#cb122-328" aria-hidden="true" tabindex="-1"></a><span class="al">![Different ways to visualize network attributes](images/network_attributes.jpg)</span></span>
<span id="cb122-329"><a href="#cb122-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-330"><a href="#cb122-330" aria-hidden="true" tabindex="-1"></a><span class="fu">### Vertex attributes</span></span>
<span id="cb122-331"><a href="#cb122-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-332"><a href="#cb122-332" aria-hidden="true" tabindex="-1"></a>With different attributes, we can also visualize them in the network graph in different ways. In the code given below, we assign color values to each of the vertices in the network depending on their gender. Here females will be coded as red and males as blue.</span>
<span id="cb122-333"><a href="#cb122-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-336"><a href="#cb122-336" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-337"><a href="#cb122-337" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting vertex color to gender</span></span>
<span id="cb122-338"><a href="#cb122-338" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(drug_ig_complete)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">V</span>(drug_ig_complete)<span class="sc">$</span>gender <span class="sc">==</span> <span class="st">'F'</span>, <span class="st">"red"</span>, <span class="st">"blue"</span>)</span>
<span id="cb122-339"><a href="#cb122-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-340"><a href="#cb122-340" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the network</span></span>
<span id="cb122-341"><a href="#cb122-341" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>)</span>
<span id="cb122-342"><a href="#cb122-342" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-343"><a href="#cb122-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-344"><a href="#cb122-344" aria-hidden="true" tabindex="-1"></a><span class="fu">### Edge attributes</span></span>
<span id="cb122-345"><a href="#cb122-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-346"><a href="#cb122-346" aria-hidden="true" tabindex="-1"></a>Edge attributes can be visualized in the network by changing the line type, color or by changing the width. In the code given below, we change the line width depending on the call hours between vertices (or friends).</span>
<span id="cb122-347"><a href="#cb122-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-350"><a href="#cb122-350" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-351"><a href="#cb122-351" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracting call_hours</span></span>
<span id="cb122-352"><a href="#cb122-352" aria-hidden="true" tabindex="-1"></a>call_hours <span class="ot">&lt;-</span> <span class="fu">E</span>(drug_ig_complete)<span class="sc">$</span>call_hours</span>
<span id="cb122-353"><a href="#cb122-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-354"><a href="#cb122-354" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the network</span></span>
<span id="cb122-355"><a href="#cb122-355" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-356"><a href="#cb122-356" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours)</span>
<span id="cb122-357"><a href="#cb122-357" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-358"><a href="#cb122-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-359"><a href="#cb122-359" aria-hidden="true" tabindex="-1"></a>In the above graph, the line width is directly proportional to the call hours between the vertices. Higher line width corresponds to a greater number of call hours between friends.</span>
<span id="cb122-360"><a href="#cb122-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-361"><a href="#cb122-361" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network Visualizations</span></span>
<span id="cb122-362"><a href="#cb122-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-363"><a href="#cb122-363" aria-hidden="true" tabindex="-1"></a>Just like how we can customize different network attributes, we can also change the way our network is visualized based on our data. For instance, if we are interested in sequential events or relationships between family members, then visualizing our network in a tree form would be better than the normal way. The <span class="in">`layout`</span> argument in the <span class="in">`plot()`</span> function can take different types of layout functions given in the <span class="in">`{igraph}`</span> package, providing us with a range of ways to visualize our networks. To create a tree network, we can use the function <span class="in">`layout_as_tree()`</span>. Below are some popular ways to visualize networks.</span>
<span id="cb122-364"><a href="#cb122-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-365"><a href="#cb122-365" aria-hidden="true" tabindex="-1"></a>::: {.panel-tabset}</span>
<span id="cb122-366"><a href="#cb122-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-367"><a href="#cb122-367" aria-hidden="true" tabindex="-1"></a><span class="fu"># Tree-like layout</span></span>
<span id="cb122-368"><a href="#cb122-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-369"><a href="#cb122-369" aria-hidden="true" tabindex="-1"></a>Good for showing hierarchical relations.</span>
<span id="cb122-370"><a href="#cb122-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-373"><a href="#cb122-373" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-374"><a href="#cb122-374" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in tree form</span></span>
<span id="cb122-375"><a href="#cb122-375" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-376"><a href="#cb122-376" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_as_tree</span>(drug_ig_complete))</span>
<span id="cb122-377"><a href="#cb122-377" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-378"><a href="#cb122-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-379"><a href="#cb122-379" aria-hidden="true" tabindex="-1"></a><span class="fu"># Circle</span></span>
<span id="cb122-380"><a href="#cb122-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-381"><a href="#cb122-381" aria-hidden="true" tabindex="-1"></a>Place vertices on a circle, in the order of their vertex ids.</span>
<span id="cb122-382"><a href="#cb122-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-385"><a href="#cb122-385" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-386"><a href="#cb122-386" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in circle form</span></span>
<span id="cb122-387"><a href="#cb122-387" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-388"><a href="#cb122-388" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_in_circle</span>(drug_ig_complete))</span>
<span id="cb122-389"><a href="#cb122-389" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-390"><a href="#cb122-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-391"><a href="#cb122-391" aria-hidden="true" tabindex="-1"></a><span class="fu"># DrL graph layout </span></span>
<span id="cb122-392"><a href="#cb122-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-393"><a href="#cb122-393" aria-hidden="true" tabindex="-1"></a>DrL is a force-directed graph layout toolbox focused on real-world large-scale graphs.</span>
<span id="cb122-394"><a href="#cb122-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-397"><a href="#cb122-397" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-398"><a href="#cb122-398" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in DrL graph layout</span></span>
<span id="cb122-399"><a href="#cb122-399" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-400"><a href="#cb122-400" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_with_drl</span>(drug_ig_complete))</span>
<span id="cb122-401"><a href="#cb122-401" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-402"><a href="#cb122-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-403"><a href="#cb122-403" aria-hidden="true" tabindex="-1"></a><span class="fu"># Fruchterman-Reingold layout</span></span>
<span id="cb122-404"><a href="#cb122-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-405"><a href="#cb122-405" aria-hidden="true" tabindex="-1"></a>Place vertices on the plane using the force-directed layout algorithm by Fruchterman and Reingold.</span>
<span id="cb122-406"><a href="#cb122-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-409"><a href="#cb122-409" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-410"><a href="#cb122-410" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in Fruchterman-Reingold graph layout</span></span>
<span id="cb122-411"><a href="#cb122-411" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-412"><a href="#cb122-412" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_with_fr</span>(drug_ig_complete))</span>
<span id="cb122-413"><a href="#cb122-413" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-414"><a href="#cb122-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-415"><a href="#cb122-415" aria-hidden="true" tabindex="-1"></a><span class="fu"># Simple grid layout</span></span>
<span id="cb122-416"><a href="#cb122-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-417"><a href="#cb122-417" aria-hidden="true" tabindex="-1"></a>This layout places vertices on a rectangular grid, in two or three dimensions.</span>
<span id="cb122-418"><a href="#cb122-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-421"><a href="#cb122-421" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-422"><a href="#cb122-422" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in grid layout</span></span>
<span id="cb122-423"><a href="#cb122-423" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-424"><a href="#cb122-424" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_on_grid</span>(drug_ig_complete))</span>
<span id="cb122-425"><a href="#cb122-425" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-426"><a href="#cb122-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-427"><a href="#cb122-427" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb122-428"><a href="#cb122-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-429"><a href="#cb122-429" aria-hidden="true" tabindex="-1"></a>Alternatively, if we are unsure of which layout is best for the network at hand, we can use the function <span class="in">`layout_nicely()`</span> which will assign the best layout automatically.</span>
<span id="cb122-430"><a href="#cb122-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-433"><a href="#cb122-433" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-434"><a href="#cb122-434" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the graph in tree form</span></span>
<span id="cb122-435"><a href="#cb122-435" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(drug_ig_complete, <span class="at">vertex.label.color =</span> <span class="st">"black"</span>, <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-436"><a href="#cb122-436" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.width =</span> call_hours, <span class="at">layout =</span> <span class="fu">layout_nicely</span>(drug_ig_complete))</span>
<span id="cb122-437"><a href="#cb122-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-438"><a href="#cb122-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-439"><a href="#cb122-439" aria-hidden="true" tabindex="-1"></a><span class="fu">## Directed networks</span></span>
<span id="cb122-440"><a href="#cb122-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-441"><a href="#cb122-441" aria-hidden="true" tabindex="-1"></a>Network graphs can be either undirected or directed. Undirected graphs represent relationships between vertices as simply existing between them, whereas directed graphs indicate that the relationships have a direction. Examples of directed networks include disease outbreak data, family relationships, and school friendship networks.</span>
<span id="cb122-442"><a href="#cb122-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-443"><a href="#cb122-443" aria-hidden="true" tabindex="-1"></a>Let's create a dummy dataset to illustrate directed networks. We'll generate data on a disease outbreak that occurred in a community of 20 people.</span>
<span id="cb122-444"><a href="#cb122-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-447"><a href="#cb122-447" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-448"><a href="#cb122-448" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb122-449"><a href="#cb122-449" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: Code for making the dummy data</span></span>
<span id="cb122-450"><a href="#cb122-450" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-451"><a href="#cb122-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-452"><a href="#cb122-452" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb122-453"><a href="#cb122-453" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb122-454"><a href="#cb122-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-455"><a href="#cb122-455" aria-hidden="true" tabindex="-1"></a><span class="co"># create a data frame with two columns to store the information about the spread of the disease</span></span>
<span id="cb122-456"><a href="#cb122-456" aria-hidden="true" tabindex="-1"></a>infection_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Infected=</span><span class="fu">character</span>(), <span class="at">Infected_By=</span><span class="fu">character</span>(), <span class="at">stringsAsFactors=</span><span class="cn">FALSE</span>)</span>
<span id="cb122-457"><a href="#cb122-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-458"><a href="#cb122-458" aria-hidden="true" tabindex="-1"></a><span class="co"># set the number of infected people</span></span>
<span id="cb122-459"><a href="#cb122-459" aria-hidden="true" tabindex="-1"></a>num_infected <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb122-460"><a href="#cb122-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-461"><a href="#cb122-461" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the first infected person</span></span>
<span id="cb122-462"><a href="#cb122-462" aria-hidden="true" tabindex="-1"></a>infected <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Patient Zero"</span>)</span>
<span id="cb122-463"><a href="#cb122-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-464"><a href="#cb122-464" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop over the remaining infected people and add them to the data frame</span></span>
<span id="cb122-465"><a href="#cb122-465" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>num_infected) {</span>
<span id="cb122-466"><a href="#cb122-466" aria-hidden="true" tabindex="-1"></a>  <span class="co"># randomly choose the person infected by the current infected person</span></span>
<span id="cb122-467"><a href="#cb122-467" aria-hidden="true" tabindex="-1"></a>  infected_by <span class="ot">&lt;-</span> <span class="fu">sample</span>(infected, <span class="dv">1</span>)</span>
<span id="cb122-468"><a href="#cb122-468" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb122-469"><a href="#cb122-469" aria-hidden="true" tabindex="-1"></a>  <span class="co"># add the currently infected person and the person infected by them to the data frame</span></span>
<span id="cb122-470"><a href="#cb122-470" aria-hidden="true" tabindex="-1"></a>  infection_df <span class="ot">&lt;-</span> <span class="fu">rbind</span>(infection_df, <span class="fu">data.frame</span>(<span class="at">Infected=</span><span class="fu">paste</span>(<span class="st">"Person"</span>, i),</span>
<span id="cb122-471"><a href="#cb122-471" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">Infected_By=</span>infected_by, <span class="at">stringsAsFactors=</span><span class="cn">FALSE</span>))</span>
<span id="cb122-472"><a href="#cb122-472" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb122-473"><a href="#cb122-473" aria-hidden="true" tabindex="-1"></a>  <span class="co"># add the currently infected person to the list of infected people</span></span>
<span id="cb122-474"><a href="#cb122-474" aria-hidden="true" tabindex="-1"></a>  infected <span class="ot">&lt;-</span> <span class="fu">c</span>(infected, <span class="fu">paste</span>(<span class="st">"Person"</span>, i))</span>
<span id="cb122-475"><a href="#cb122-475" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb122-476"><a href="#cb122-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-477"><a href="#cb122-477" aria-hidden="true" tabindex="-1"></a><span class="co"># Interchanging the columns</span></span>
<span id="cb122-478"><a href="#cb122-478" aria-hidden="true" tabindex="-1"></a>infection_df <span class="ot">&lt;-</span> infection_df[, <span class="fu">c</span>(<span class="st">"Infected_By"</span>, <span class="st">"Infected"</span>)]</span>
<span id="cb122-479"><a href="#cb122-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-480"><a href="#cb122-480" aria-hidden="true" tabindex="-1"></a><span class="co"># print the first few rows of the resulting data frame</span></span>
<span id="cb122-481"><a href="#cb122-481" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(infection_df)</span>
<span id="cb122-482"><a href="#cb122-482" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-483"><a href="#cb122-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-484"><a href="#cb122-484" aria-hidden="true" tabindex="-1"></a>The dataframe <span class="in">`infection_df`</span> contains data on 21 individuals (20 people and 1 patient zero). The infection starts with patient zero, which then spreads across the community. The dataframe has two columns: "Infected_By" indicates the person who is transmitting the disease, and "Infected" shows the person who is getting infected by that transmission.</span>
<span id="cb122-485"><a href="#cb122-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-486"><a href="#cb122-486" aria-hidden="true" tabindex="-1"></a>Now, let's plot the above dataframe as a network graph.</span>
<span id="cb122-487"><a href="#cb122-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-490"><a href="#cb122-490" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-491"><a href="#cb122-491" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-492"><a href="#cb122-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-493"><a href="#cb122-493" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-494"><a href="#cb122-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-495"><a href="#cb122-495" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb122-496"><a href="#cb122-496" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb122-497"><a href="#cb122-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-498"><a href="#cb122-498" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the graph</span></span>
<span id="cb122-499"><a href="#cb122-499" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph, <span class="at">vertex.label.color=</span><span class="st">"black"</span>, <span class="at">vertex.size=</span><span class="dv">10</span>, <span class="at">vertex.label.cex=</span><span class="fl">0.7</span>,</span>
<span id="cb122-500"><a href="#cb122-500" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size=</span><span class="fl">0.5</span>, <span class="at">main=</span><span class="st">"Disease Transmission Network"</span>)</span>
<span id="cb122-501"><a href="#cb122-501" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-502"><a href="#cb122-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-503"><a href="#cb122-503" aria-hidden="true" tabindex="-1"></a>A notable difference from earlier graphs we have seen is that the edges now have an arrowhead indicating their direction. In the graph, the central node is "Patient Zero", who is the first infected person in the community. The vertex "Patient Zero" has two outgoing edges, one going to "Person 1" and the other to "Person 2". The arrowheads navigate us to show how the infection starting from "Patient Zero" infected the whole community. The <span class="in">`directed=TRUE`</span> argument in the <span class="in">`graph_from_data_frame()`</span> function tells R to create a directed igraph object. We can also check if a network is directed by using the <span class="in">`is.directed()`</span> function.</span>
<span id="cb122-504"><a href="#cb122-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-507"><a href="#cb122-507" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-508"><a href="#cb122-508" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-509"><a href="#cb122-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-510"><a href="#cb122-510" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb122-511"><a href="#cb122-511" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb122-512"><a href="#cb122-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-513"><a href="#cb122-513" aria-hidden="true" tabindex="-1"></a><span class="co"># print output</span></span>
<span id="cb122-514"><a href="#cb122-514" aria-hidden="true" tabindex="-1"></a>graph</span>
<span id="cb122-515"><a href="#cb122-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-516"><a href="#cb122-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-517"><a href="#cb122-517" aria-hidden="true" tabindex="-1"></a>In the first line of the output, 'DN' stands for 'Directed Network', for undirected networks it will be 'UN' which we have seen before. We can also use the function <span class="in">`is.directed()`</span> to check if the network is directed.</span>
<span id="cb122-518"><a href="#cb122-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-521"><a href="#cb122-521" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-522"><a href="#cb122-522" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-523"><a href="#cb122-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-524"><a href="#cb122-524" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb122-525"><a href="#cb122-525" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb122-526"><a href="#cb122-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-527"><a href="#cb122-527" aria-hidden="true" tabindex="-1"></a><span class="co"># checking if it's directed or not</span></span>
<span id="cb122-528"><a href="#cb122-528" aria-hidden="true" tabindex="-1"></a><span class="fu">is.directed</span>(graph)</span>
<span id="cb122-529"><a href="#cb122-529" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-530"><a href="#cb122-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-531"><a href="#cb122-531" aria-hidden="true" tabindex="-1"></a><span class="fu">### Identifying edges</span></span>
<span id="cb122-532"><a href="#cb122-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-533"><a href="#cb122-533" aria-hidden="true" tabindex="-1"></a>Suppose we want to see if there is a disease transmission between person 2 and person 10. To check this we can use the following code;</span>
<span id="cb122-534"><a href="#cb122-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-537"><a href="#cb122-537" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-538"><a href="#cb122-538" aria-hidden="true" tabindex="-1"></a><span class="co"># checking if an edge exists between person 2 and person 10</span></span>
<span id="cb122-539"><a href="#cb122-539" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">'Person 2'</span>, <span class="st">'Person 10'</span>]</span>
<span id="cb122-540"><a href="#cb122-540" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-541"><a href="#cb122-541" aria-hidden="true" tabindex="-1"></a>The function returned 0, this means that there is no edge between the vertices that we were interested in. The function returns 1 if there exists an edge.</span>
<span id="cb122-542"><a href="#cb122-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-543"><a href="#cb122-543" aria-hidden="true" tabindex="-1"></a>We can also see which edges go out from a vertex and go in into the vertex using the <span class="in">`incident()`</span> function.</span>
<span id="cb122-544"><a href="#cb122-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-547"><a href="#cb122-547" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-548"><a href="#cb122-548" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edged going out from patient zero</span></span>
<span id="cb122-549"><a href="#cb122-549" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"out"</span>))</span>
<span id="cb122-550"><a href="#cb122-550" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-551"><a href="#cb122-551" aria-hidden="true" tabindex="-1"></a>From the output, we can see that patient zero infects person 1 and person 2.</span>
<span id="cb122-552"><a href="#cb122-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-553"><a href="#cb122-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-556"><a href="#cb122-556" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-557"><a href="#cb122-557" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edges coming into person 3</span></span>
<span id="cb122-558"><a href="#cb122-558" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Person 3'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"in"</span>))</span>
<span id="cb122-559"><a href="#cb122-559" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-560"><a href="#cb122-560" aria-hidden="true" tabindex="-1"></a>From the output, we can see that person 3 was infected by person 2.</span>
<span id="cb122-561"><a href="#cb122-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-564"><a href="#cb122-564" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-565"><a href="#cb122-565" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all edges connected to person 5</span></span>
<span id="cb122-566"><a href="#cb122-566" aria-hidden="true" tabindex="-1"></a><span class="fu">incident</span>(graph, <span class="st">'Person 5'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))</span>
<span id="cb122-567"><a href="#cb122-567" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-568"><a href="#cb122-568" aria-hidden="true" tabindex="-1"></a>From the output we can see that person 5 was infected by person 2 and thereafter person 5 goes on to infect person 8 and person 11.</span>
<span id="cb122-569"><a href="#cb122-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-570"><a href="#cb122-570" aria-hidden="true" tabindex="-1"></a>We can also use the <span class="in">`head_of()`</span> function to return the set of vertices that are at the beginning of the edges in the input. It gives the list of people who infected others.</span>
<span id="cb122-571"><a href="#cb122-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-574"><a href="#cb122-574" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-575"><a href="#cb122-575" aria-hidden="true" tabindex="-1"></a><span class="co"># printing all vertices that are connected to an edge</span></span>
<span id="cb122-576"><a href="#cb122-576" aria-hidden="true" tabindex="-1"></a><span class="fu">head_of</span>(graph, <span class="fu">E</span>(graph))</span>
<span id="cb122-577"><a href="#cb122-577" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-578"><a href="#cb122-578" aria-hidden="true" tabindex="-1"></a>Here, patient zero is not included in the output because it is not connected to any edges in the graph. The <span class="in">`head_of()`</span> function returns only the vertices that are connected to edges in the graph, and since patient zero does not have any outgoing edges, it is not included in the output.</span>
<span id="cb122-579"><a href="#cb122-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-580"><a href="#cb122-580" aria-hidden="true" tabindex="-1"></a><span class="fu">### Identifying the neighbors</span></span>
<span id="cb122-581"><a href="#cb122-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-582"><a href="#cb122-582" aria-hidden="true" tabindex="-1"></a>To track the spread of a pandemic in a small community, we need to identify the individuals who were infected by patient zero. This can be accomplished by identifying the immediate neighbors of patient zero using the <span class="in">`neighbors()`</span> function.</span>
<span id="cb122-583"><a href="#cb122-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-584"><a href="#cb122-584" aria-hidden="true" tabindex="-1"></a>Here's an example of how we can find the infected neighbors in R using the <span class="in">`neighbors()`</span> function:</span>
<span id="cb122-585"><a href="#cb122-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-588"><a href="#cb122-588" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-589"><a href="#cb122-589" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the neighbors of patient zero</span></span>
<span id="cb122-590"><a href="#cb122-590" aria-hidden="true" tabindex="-1"></a><span class="fu">neighbors</span>(graph, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))</span>
<span id="cb122-591"><a href="#cb122-591" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-592"><a href="#cb122-592" aria-hidden="true" tabindex="-1"></a>We can also see which neighbors are common for a particular vertex using the <span class="in">`intersect()`</span> function.</span>
<span id="cb122-593"><a href="#cb122-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-596"><a href="#cb122-596" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-597"><a href="#cb122-597" aria-hidden="true" tabindex="-1"></a><span class="co"># finding neighbors of person 1 </span></span>
<span id="cb122-598"><a href="#cb122-598" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">neighbors</span>(graph, <span class="st">'Person 1'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span>
<span id="cb122-599"><a href="#cb122-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-600"><a href="#cb122-600" aria-hidden="true" tabindex="-1"></a><span class="co"># finding neighbors of person 2</span></span>
<span id="cb122-601"><a href="#cb122-601" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">neighbors</span>(graph, <span class="st">'Person 2'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span>
<span id="cb122-602"><a href="#cb122-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-603"><a href="#cb122-603" aria-hidden="true" tabindex="-1"></a><span class="co"># finding common neighbors between person 1 and person 2</span></span>
<span id="cb122-604"><a href="#cb122-604" aria-hidden="true" tabindex="-1"></a><span class="fu">intersection</span>(x,y)</span>
<span id="cb122-605"><a href="#cb122-605" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-606"><a href="#cb122-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-607"><a href="#cb122-607" aria-hidden="true" tabindex="-1"></a><span class="fu">### Path length (Geodesic distance)</span></span>
<span id="cb122-608"><a href="#cb122-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-609"><a href="#cb122-609" aria-hidden="true" tabindex="-1"></a>A measure to see how well a network is connected is to look at the length of the edges between all pairs of vertices. The length between a vertex and its immediate neighbor will be 1 and this is called path length or also known as geodesic distance. In our network graph, from patient zero to person 1, one connection is required to traverse, which means that the path length between them is 1. Between person 7 and patient zero the path length is 2.</span>
<span id="cb122-610"><a href="#cb122-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-613"><a href="#cb122-613" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-614"><a href="#cb122-614" aria-hidden="true" tabindex="-1"></a><span class="co"># create a graph object from the dataframe</span></span>
<span id="cb122-615"><a href="#cb122-615" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(infection_df, <span class="at">directed=</span><span class="cn">TRUE</span>)</span>
<span id="cb122-616"><a href="#cb122-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-617"><a href="#cb122-617" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the graph</span></span>
<span id="cb122-618"><a href="#cb122-618" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph, <span class="at">vertex.label.color=</span><span class="st">"black"</span>, <span class="at">vertex.size=</span><span class="dv">10</span>, <span class="at">vertex.label.cex=</span><span class="fl">0.7</span>,</span>
<span id="cb122-619"><a href="#cb122-619" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size=</span><span class="fl">0.5</span>, <span class="at">main=</span><span class="st">"Disease Transmission Network"</span>)</span>
<span id="cb122-620"><a href="#cb122-620" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-621"><a href="#cb122-621" aria-hidden="true" tabindex="-1"></a>A good way to see how deep the infection has traversed, we have to see the longest path in the network. This longest path is called the diameter of the network. To get the diameter of the network we can use the function <span class="in">`farthest_vertices()`</span></span>
<span id="cb122-622"><a href="#cb122-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-625"><a href="#cb122-625" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-626"><a href="#cb122-626" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the longest path in the network</span></span>
<span id="cb122-627"><a href="#cb122-627" aria-hidden="true" tabindex="-1"></a><span class="fu">farthest_vertices</span>(graph)</span>
<span id="cb122-628"><a href="#cb122-628" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-629"><a href="#cb122-629" aria-hidden="true" tabindex="-1"></a>To see how the connections between patient zero and person 12 make up the longest path in the network we can use the function <span class="in">`get_diameter()`</span></span>
<span id="cb122-630"><a href="#cb122-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-633"><a href="#cb122-633" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-634"><a href="#cb122-634" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the longest path in the network</span></span>
<span id="cb122-635"><a href="#cb122-635" aria-hidden="true" tabindex="-1"></a><span class="fu">get_diameter</span>(graph)</span>
<span id="cb122-636"><a href="#cb122-636" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-637"><a href="#cb122-637" aria-hidden="true" tabindex="-1"></a>To calculate the geodesic distances of all vertices from a particular vertex, we can use the function <span class="in">`distances()`</span>.</span>
<span id="cb122-638"><a href="#cb122-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-641"><a href="#cb122-641" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-642"><a href="#cb122-642" aria-hidden="true" tabindex="-1"></a><span class="co"># finding geodesic distances of all vertices from the vertex 'Patient Zero'</span></span>
<span id="cb122-643"><a href="#cb122-643" aria-hidden="true" tabindex="-1"></a><span class="fu">distances</span>(graph, <span class="st">"Patient Zero"</span>)</span>
<span id="cb122-644"><a href="#cb122-644" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-645"><a href="#cb122-645" aria-hidden="true" tabindex="-1"></a>From the output, we can see how distance each vertex is away from patient zero. Person 1 and Person 2 seem to be immediate targets of disease transmission starting from patient zero and persons 12,13,14 and person 17 were the last people to be infected in the whole community.</span>
<span id="cb122-646"><a href="#cb122-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-647"><a href="#cb122-647" aria-hidden="true" tabindex="-1"></a>We can also identify vertices that are reachable with N steps from a vertex of interest. Suppose we want to know vertices from patient zero that are reachable within 2 connections or 2 steps. We can use the <span class="in">`ego()`</span> function for this task.</span>
<span id="cb122-648"><a href="#cb122-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-651"><a href="#cb122-651" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-652"><a href="#cb122-652" aria-hidden="true" tabindex="-1"></a><span class="co"># finding vertices that are at min. 2 edges away from patient zero</span></span>
<span id="cb122-653"><a href="#cb122-653" aria-hidden="true" tabindex="-1"></a><span class="fu">ego</span>(graph, <span class="dv">2</span>, <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">'all'</span>))</span>
<span id="cb122-654"><a href="#cb122-654" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-655"><a href="#cb122-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-656"><a href="#cb122-656" aria-hidden="true" tabindex="-1"></a>Let us plot the network to visualize how far each vertex is from 'Patient Zero'. First we use <span class="in">`make_ego_graph()`</span> function to get a sub-graph containing all neighbors of Patient Zero which is reachable within the diameter of the network. This essentially includes all vertices that are connected to Patient Zero. Then we calculate the distances of vertices from Patient Zero. The diameter of this network is 4, but we add 4+1 colors, as 'Patient Zero' has zero distance, we suggest 5 colors so that 'Patient Zero' has its color. In the final plot, we have vertex labels to denote the geodesic distances from Patient Zero.</span>
<span id="cb122-657"><a href="#cb122-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-660"><a href="#cb122-660" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-661"><a href="#cb122-661" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb122-662"><a href="#cb122-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-663"><a href="#cb122-663" aria-hidden="true" tabindex="-1"></a><span class="co"># Make an ego graph</span></span>
<span id="cb122-664"><a href="#cb122-664" aria-hidden="true" tabindex="-1"></a>graph_ego <span class="ot">&lt;-</span> <span class="fu">make_ego_graph</span>(graph, <span class="fu">diameter</span>(graph), <span class="at">nodes =</span> <span class="st">'Patient Zero'</span>, <span class="at">mode =</span> <span class="fu">c</span>(<span class="st">"all"</span>))[[<span class="dv">1</span>]]</span>
<span id="cb122-665"><a href="#cb122-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-666"><a href="#cb122-666" aria-hidden="true" tabindex="-1"></a><span class="co"># Get a vector of geodesic distances of all vertices from vertex Patient Zero </span></span>
<span id="cb122-667"><a href="#cb122-667" aria-hidden="true" tabindex="-1"></a>dists <span class="ot">&lt;-</span> <span class="fu">distances</span>(graph_ego, <span class="st">"Patient Zero"</span>)</span>
<span id="cb122-668"><a href="#cb122-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-669"><a href="#cb122-669" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a color palette of length equal to the maximal geodesic distance plus one.</span></span>
<span id="cb122-670"><a href="#cb122-670" aria-hidden="true" tabindex="-1"></a>colors <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"black"</span>, <span class="st">"red"</span>, <span class="st">"orange"</span>, <span class="st">"blue"</span>, <span class="st">"dodgerblue"</span>)</span>
<span id="cb122-671"><a href="#cb122-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-672"><a href="#cb122-672" aria-hidden="true" tabindex="-1"></a><span class="co"># Set color attribute to vertices of network graph_ego</span></span>
<span id="cb122-673"><a href="#cb122-673" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(graph_ego)<span class="sc">$</span>color <span class="ot">&lt;-</span> colors[dists<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb122-674"><a href="#cb122-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-675"><a href="#cb122-675" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the network based on geodesic distance from patient zero.</span></span>
<span id="cb122-676"><a href="#cb122-676" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph_ego, </span>
<span id="cb122-677"><a href="#cb122-677" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label =</span> dists, </span>
<span id="cb122-678"><a href="#cb122-678" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.color =</span> <span class="st">"white"</span>,</span>
<span id="cb122-679"><a href="#cb122-679" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.cex =</span> .<span class="dv">6</span>,</span>
<span id="cb122-680"><a href="#cb122-680" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.color =</span> <span class="st">'black'</span>,</span>
<span id="cb122-681"><a href="#cb122-681" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.size =</span> <span class="dv">15</span>,</span>
<span id="cb122-682"><a href="#cb122-682" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.arrow.size =</span> .<span class="dv">05</span>,</span>
<span id="cb122-683"><a href="#cb122-683" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Geodesic Distances from Patient Zero"</span></span>
<span id="cb122-684"><a href="#cb122-684" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-685"><a href="#cb122-685" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-686"><a href="#cb122-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-687"><a href="#cb122-687" aria-hidden="true" tabindex="-1"></a><span class="fu">## Measures of network structure</span></span>
<span id="cb122-688"><a href="#cb122-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-689"><a href="#cb122-689" aria-hidden="true" tabindex="-1"></a><span class="fu">### Degree</span></span>
<span id="cb122-690"><a href="#cb122-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-691"><a href="#cb122-691" aria-hidden="true" tabindex="-1"></a>Degree describes how many edges a vertex has. In undirected networks, the degree of a vertex is simply the sum of edges connecting that vertex. But for directed networks, since we have some edges going out from a vertex and some edges going into the same vertex, we essentially have out-degrees and in-degrees. The figure given below illustrates this.</span>
<span id="cb122-692"><a href="#cb122-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-693"><a href="#cb122-693" aria-hidden="true" tabindex="-1"></a><span class="al">![In-degrees and Out-degrees](images/degree.png)</span></span>
<span id="cb122-694"><a href="#cb122-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-695"><a href="#cb122-695" aria-hidden="true" tabindex="-1"></a>Vertices with a high number of connections or with a high degree can be important. We can check the degrees of all vertices with the <span class="in">`degree()`</span> function.</span>
<span id="cb122-696"><a href="#cb122-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-699"><a href="#cb122-699" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-700"><a href="#cb122-700" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the degrees of all vertices in the network</span></span>
<span id="cb122-701"><a href="#cb122-701" aria-hidden="true" tabindex="-1"></a><span class="fu">degree</span>(graph, <span class="at">mode =</span> (<span class="st">'all'</span>))</span>
<span id="cb122-702"><a href="#cb122-702" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-703"><a href="#cb122-703" aria-hidden="true" tabindex="-1"></a>From the results we can see that person 2 and person 1 have high degrees which suggests that they are important in the network. Essentially, person 1 and person 2 jump-started the infection in the community.</span>
<span id="cb122-704"><a href="#cb122-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-705"><a href="#cb122-705" aria-hidden="true" tabindex="-1"></a><span class="fu">### Betweenness</span></span>
<span id="cb122-706"><a href="#cb122-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-707"><a href="#cb122-707" aria-hidden="true" tabindex="-1"></a>This is an index of how frequently the vertex lies on the shortest paths between any two vertices in the network. It can be thought of as how critical the vertex is to the flow of information through a network. Individuals with high betweenness are key bridges between different parts of a network. We can calculate the betweenness of each vertices using the <span class="in">`betweenness()`</span> function.</span>
<span id="cb122-708"><a href="#cb122-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-711"><a href="#cb122-711" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-712"><a href="#cb122-712" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the betweenness of all vertices in the network</span></span>
<span id="cb122-713"><a href="#cb122-713" aria-hidden="true" tabindex="-1"></a><span class="fu">betweenness</span>(graph, <span class="at">directed =</span> T)</span>
<span id="cb122-714"><a href="#cb122-714" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-715"><a href="#cb122-715" aria-hidden="true" tabindex="-1"></a>From the output, person 2 has the most number of nodes branching outwards followed by person 1 and person 5. This might suggest that person 1, person 2, and person 5 might be playing an important role in spreading the disease.</span>
<span id="cb122-716"><a href="#cb122-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-717"><a href="#cb122-717" aria-hidden="true" tabindex="-1"></a>We can also use the <span class="in">`nromalized = T`</span> argument to get the normalized betweenness values.</span>
<span id="cb122-718"><a href="#cb122-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-721"><a href="#cb122-721" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-722"><a href="#cb122-722" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the betweenness of all vertices in the network</span></span>
<span id="cb122-723"><a href="#cb122-723" aria-hidden="true" tabindex="-1"></a><span class="fu">betweenness</span>(graph, <span class="at">directed =</span> T, <span class="at">normalized =</span> T)</span>
<span id="cb122-724"><a href="#cb122-724" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-725"><a href="#cb122-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-726"><a href="#cb122-726" aria-hidden="true" tabindex="-1"></a><span class="fu">### Eigenvector centrality</span></span>
<span id="cb122-727"><a href="#cb122-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-728"><a href="#cb122-728" aria-hidden="true" tabindex="-1"></a>Centrality is a measure of an individual vertexe's structural importance in a group based on its network position. Vertices with high eigenvector centrality are those that are connected to many other vertices but also to vertices that are themselves highly connected to other vertices. Eigenvector centrality can be calculated using the function <span class="in">`eigen_centrality()`</span>. The function returns many other values also, but for now we are just focusing on the centrality value which is saved as <span class="in">`vector`</span> in the output.</span>
<span id="cb122-729"><a href="#cb122-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-732"><a href="#cb122-732" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-733"><a href="#cb122-733" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the eigenvector centrality of all vertices in the network</span></span>
<span id="cb122-734"><a href="#cb122-734" aria-hidden="true" tabindex="-1"></a><span class="fu">eigen_centrality</span>(graph)<span class="sc">$</span>vector</span>
<span id="cb122-735"><a href="#cb122-735" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-736"><a href="#cb122-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-737"><a href="#cb122-737" aria-hidden="true" tabindex="-1"></a>Here in the output, Person 1,2,5, and patient zero are highly influential vertices in the network.</span>
<span id="cb122-738"><a href="#cb122-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-739"><a href="#cb122-739" aria-hidden="true" tabindex="-1"></a>We can also plot the network with eigenvector centrality as a vertex size attribute.</span>
<span id="cb122-740"><a href="#cb122-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-743"><a href="#cb122-743" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-744"><a href="#cb122-744" aria-hidden="true" tabindex="-1"></a><span class="co"># Saving eigenvector centrality values</span></span>
<span id="cb122-745"><a href="#cb122-745" aria-hidden="true" tabindex="-1"></a>graph_eigen_vector <span class="ot">&lt;-</span> <span class="fu">eigen_centrality</span>(graph)<span class="sc">$</span>vector</span>
<span id="cb122-746"><a href="#cb122-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-747"><a href="#cb122-747" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting the network</span></span>
<span id="cb122-748"><a href="#cb122-748" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(graph,</span>
<span id="cb122-749"><a href="#cb122-749" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.color =</span> <span class="st">"black"</span>,</span>
<span id="cb122-750"><a href="#cb122-750" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.label.cex =</span> <span class="fl">0.6</span>,</span>
<span id="cb122-751"><a href="#cb122-751" aria-hidden="true" tabindex="-1"></a>     <span class="at">vertex.size =</span> <span class="dv">25</span><span class="sc">*</span>(graph_eigen_vector),</span>
<span id="cb122-752"><a href="#cb122-752" aria-hidden="true" tabindex="-1"></a>     <span class="at">edge.color =</span> <span class="st">'grey'</span>,</span>
<span id="cb122-753"><a href="#cb122-753" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Disease Outbreak Network"</span>)</span>
<span id="cb122-754"><a href="#cb122-754" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-755"><a href="#cb122-755" aria-hidden="true" tabindex="-1"></a><span class="fu">### Density</span></span>
<span id="cb122-756"><a href="#cb122-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-757"><a href="#cb122-757" aria-hidden="true" tabindex="-1"></a>Density is the simplest way of measuring the overall structure of the network. Density is the proportion of edges that do exist in a network out of all those that potentially could exist between every pair of vertices in the network. A density value of 1 would suggest all possible vertices are present in the network, which would also mean that the network is highly interconnected. To calculate the density we use the function <span class="in">`edge_density()`</span>.</span>
<span id="cb122-758"><a href="#cb122-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-761"><a href="#cb122-761" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-762"><a href="#cb122-762" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the density of the network</span></span>
<span id="cb122-763"><a href="#cb122-763" aria-hidden="true" tabindex="-1"></a><span class="fu">edge_density</span>(graph)</span>
<span id="cb122-764"><a href="#cb122-764" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-765"><a href="#cb122-765" aria-hidden="true" tabindex="-1"></a>The value ~ 0.05 (approximately) suggests that 5% of the total possible vertices are present in our network.</span>
<span id="cb122-766"><a href="#cb122-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-767"><a href="#cb122-767" aria-hidden="true" tabindex="-1"></a><span class="fu">### Average path length</span></span>
<span id="cb122-768"><a href="#cb122-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-769"><a href="#cb122-769" aria-hidden="true" tabindex="-1"></a>The average path length is the mean of the lengths of the shortest paths between all pairs of vertices in the network. We can use the function <span class="in">`mean_distance()`</span> to the graph and instruct the function whether the graph is undirected or directed to find the value. Lower values of average path length suggest that the network is highly interconnected.</span>
<span id="cb122-770"><a href="#cb122-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-773"><a href="#cb122-773" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-774"><a href="#cb122-774" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the average path length of the network</span></span>
<span id="cb122-775"><a href="#cb122-775" aria-hidden="true" tabindex="-1"></a><span class="fu">mean_distance</span>(graph, <span class="at">directed =</span> T)</span>
<span id="cb122-776"><a href="#cb122-776" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-777"><a href="#cb122-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-778"><a href="#cb122-778" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network randomization test</span></span>
<span id="cb122-779"><a href="#cb122-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-780"><a href="#cb122-780" aria-hidden="true" tabindex="-1"></a>So far, we have seen the different kinds of measures used to determine the overall structure of the network. To check if the obtained value is unique to the network data at hand, we randomize our network data and calculate measures of network structure and compare them with the real values. To randomize our network, we use the function <span class="in">`erdos.renyi.game()`</span>, which uses a particular algorithm to generate networks with a set probability of creating edges between the vertices in the network.</span>
<span id="cb122-781"><a href="#cb122-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-784"><a href="#cb122-784" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-785"><a href="#cb122-785" aria-hidden="true" tabindex="-1"></a><span class="co"># generating a random network graph</span></span>
<span id="cb122-786"><a href="#cb122-786" aria-hidden="true" tabindex="-1"></a><span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph), <span class="at">type =</span> <span class="st">'gnp'</span>)</span>
<span id="cb122-787"><a href="#cb122-787" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-788"><a href="#cb122-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-789"><a href="#cb122-789" aria-hidden="true" tabindex="-1"></a>Here we specify the number of vertices (given by <span class="in">`n = gorder(graph)`</span>) and the probability of a given edge being connected between any two vertices, given by the argument <span class="in">`p.or.m = edge_density(graph)`</span>. The <span class="in">`type = 'gnp'`</span> argument tells R that the graph has ‘n’ vertices, and for each edge, the probability that it is present in the graph is ‘p’.</span>
<span id="cb122-790"><a href="#cb122-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-791"><a href="#cb122-791" aria-hidden="true" tabindex="-1"></a>Let us calculate the average path length for this randomized network that we just created.</span>
<span id="cb122-792"><a href="#cb122-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-795"><a href="#cb122-795" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-796"><a href="#cb122-796" aria-hidden="true" tabindex="-1"></a><span class="co"># setting seed for reproducibility</span></span>
<span id="cb122-797"><a href="#cb122-797" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb122-798"><a href="#cb122-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-799"><a href="#cb122-799" aria-hidden="true" tabindex="-1"></a><span class="co"># generating a random network graph</span></span>
<span id="cb122-800"><a href="#cb122-800" aria-hidden="true" tabindex="-1"></a>random_graph <span class="ot">&lt;-</span> <span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph), <span class="at">type =</span> <span class="st">'gnp'</span>)</span>
<span id="cb122-801"><a href="#cb122-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-802"><a href="#cb122-802" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the average length of the random network</span></span>
<span id="cb122-803"><a href="#cb122-803" aria-hidden="true" tabindex="-1"></a><span class="fu">mean_distance</span>(random_graph)</span>
<span id="cb122-804"><a href="#cb122-804" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-805"><a href="#cb122-805" aria-hidden="true" tabindex="-1"></a>From the result, we can see that the average path length is slightly less than our original average path length. However, this is not enough to conclude that the original value we got is different from the random value. Therefore, let us repeat this randomization 1000 times, calculate the average path length each time, and check how many networks are greater or lesser than the average path length we originally calculated. This way, we can confidently say whether our original value is particularly different from that of the random values. This process is called a network randomization test. In summary, a randomization test tells us whether the features of our original network are particularly unusual or not.</span>
<span id="cb122-806"><a href="#cb122-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-807"><a href="#cb122-807" aria-hidden="true" tabindex="-1"></a>So the pipeline that we will be following for network randomization is the following:</span>
<span id="cb122-808"><a href="#cb122-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-811"><a href="#cb122-811" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb122-812"><a href="#cb122-812" aria-hidden="true" tabindex="-1"></a>%<span class="dt">%</span>{init: {<span class="ot">'</span><span class="ss">theme</span><span class="ot">'</span>: <span class="ot">'</span><span class="ss">default</span><span class="ot">'</span>}}%%</span>
<span id="cb122-813"><a href="#cb122-813" aria-hidden="true" tabindex="-1"></a>graph TD</span>
<span id="cb122-814"><a href="#cb122-814" aria-hidden="true" tabindex="-1"></a>    A[Generating <span class="dv">1000</span> random networks with the same number of vertices <span class="ot">and</span> with a similar edge density as that of the original network]</span>
<span id="cb122-815"><a href="#cb122-815" aria-hidden="true" tabindex="-1"></a>    B[Calculate the average path <span class="fu">length</span> of the original network]</span>
<span id="cb122-816"><a href="#cb122-816" aria-hidden="true" tabindex="-1"></a>    C[Calculate the average path <span class="fu">length</span> <span class="kw">for</span> all <span class="dv">1000</span> randomly generated networks]</span>
<span id="cb122-817"><a href="#cb122-817" aria-hidden="true" tabindex="-1"></a>    D[Determine how many random networks are greater than <span class="ot">or</span> <span class="kw">less</span> than the average path <span class="fu">length</span> of the original network]</span>
<span id="cb122-818"><a href="#cb122-818" aria-hidden="true" tabindex="-1"></a>    A--&gt;B</span>
<span id="cb122-819"><a href="#cb122-819" aria-hidden="true" tabindex="-1"></a>    B--&gt;C</span>
<span id="cb122-820"><a href="#cb122-820" aria-hidden="true" tabindex="-1"></a>    C--&gt;D</span>
<span id="cb122-821"><a href="#cb122-821" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-822"><a href="#cb122-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-823"><a href="#cb122-823" aria-hidden="true" tabindex="-1"></a>Now let us calculate generate and calculate the average path length for 1000 random networks. We are using the <span class="in">`graph`</span> igraph object which we created last time.</span>
<span id="cb122-824"><a href="#cb122-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-827"><a href="#cb122-827" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-828"><a href="#cb122-828" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-829"><a href="#cb122-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-830"><a href="#cb122-830" aria-hidden="true" tabindex="-1"></a><span class="co"># set seed for reproducibility</span></span>
<span id="cb122-831"><a href="#cb122-831" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb122-832"><a href="#cb122-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-833"><a href="#cb122-833" aria-hidden="true" tabindex="-1"></a><span class="co"># generating an empty list with 1000 entries</span></span>
<span id="cb122-834"><a href="#cb122-834" aria-hidden="true" tabindex="-1"></a>list_empty <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="st">'list'</span>, <span class="dv">1000</span>) <span class="co"># &lt;1&gt;</span></span>
<span id="cb122-835"><a href="#cb122-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-836"><a href="#cb122-836" aria-hidden="true" tabindex="-1"></a><span class="co"># generating 1000 random networks and saving them in the empty list</span></span>
<span id="cb122-837"><a href="#cb122-837" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>){ <span class="co"># &lt;2&gt;</span></span>
<span id="cb122-838"><a href="#cb122-838" aria-hidden="true" tabindex="-1"></a>  list_empty[[i]] <span class="ot">&lt;-</span> <span class="fu">erdos.renyi.game</span>(<span class="at">n =</span> <span class="fu">gorder</span>(graph), <span class="at">p.or.m =</span> <span class="fu">edge_density</span>(graph),</span>
<span id="cb122-839"><a href="#cb122-839" aria-hidden="true" tabindex="-1"></a>                              <span class="at">type =</span> <span class="st">"gnp"</span>)</span>
<span id="cb122-840"><a href="#cb122-840" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb122-841"><a href="#cb122-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-842"><a href="#cb122-842" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the average path length of 1000 random graphs</span></span>
<span id="cb122-843"><a href="#cb122-843" aria-hidden="true" tabindex="-1"></a>list_empty_avg_path <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">lapply</span>(list_empty, mean_distance, <span class="at">directed =</span> T)) <span class="co"># &lt;3&gt;</span></span>
<span id="cb122-844"><a href="#cb122-844" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-845"><a href="#cb122-845" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>First we generate an empty list with 1000 <span class="in">`NULL`</span> entries which we will be using to store our 1000 random networks.</span>
<span id="cb122-846"><a href="#cb122-846" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The for loop generates 1000 random networks using the Erdős-Rényi model with the same number of vertices and edge density as the original network (which is got from the <span class="in">`graph`</span> object, which we had saved earlier). The networks are then saved in the empty list created in the previous step.</span>
<span id="cb122-847"><a href="#cb122-847" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>This line uses the <span class="in">`lapply()`</span> function to apply the <span class="in">`mean_distance()`</span> function to each element in the <span class="in">`list_empty`</span> list, which calculates the average path length for each of the 1000 random networks. The <span class="in">`unlist()`</span> function is used to convert the resulting list of average path lengths into a vector.</span>
<span id="cb122-848"><a href="#cb122-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-851"><a href="#cb122-851" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-852"><a href="#cb122-852" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the distribution of average path lengths</span></span>
<span id="cb122-853"><a href="#cb122-853" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(list_empty_avg_path) </span>
<span id="cb122-854"><a href="#cb122-854" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="fu">average.path.length</span>(graph, <span class="at">directed =</span> T), <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">lty =</span> <span class="dv">3</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span>
<span id="cb122-855"><a href="#cb122-855" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-856"><a href="#cb122-856" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the proportion of graphs with an average path length lower than our observed</span></span>
<span id="cb122-857"><a href="#cb122-857" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(list_empty_avg_path <span class="sc">&lt;</span> <span class="fu">average.path.length</span>(graph, <span class="at">directed =</span> T)) <span class="co"># &lt;4&gt;</span></span>
<span id="cb122-858"><a href="#cb122-858" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-859"><a href="#cb122-859" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>The above code generates a histogram of the distribution of average path lengths for the 1000 random networks using the <span class="in">`hist()`</span> function. The second line adds a vertical line at the average path length of the original network using the <span class="in">`abline()`</span> function. Finally, the last line calculates the proportion of random networks that have an average path length less than that of the original network using the <span class="in">`mean()`</span> function. The comparison is done using the <span class="in">`&lt;`</span> operator and the <span class="in">`average.path.length()`</span> function calculates the average path length of the original network.</span>
<span id="cb122-860"><a href="#cb122-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-861"><a href="#cb122-861" aria-hidden="true" tabindex="-1"></a>From the histogram we can see that our original average path length, which is represented as a red dotted vertical line lies among the randomly generate list average path length. The high interconnectedness we observe in our original data may be due to random chance alone.</span>
<span id="cb122-862"><a href="#cb122-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-863"><a href="#cb122-863" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network substructures</span></span>
<span id="cb122-864"><a href="#cb122-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-865"><a href="#cb122-865" aria-hidden="true" tabindex="-1"></a>Until now we have looked at features that describe the network structure. In this section, we will learn about microstructural features of social networks that can be informative as to how a network functions.</span>
<span id="cb122-866"><a href="#cb122-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-867"><a href="#cb122-867" aria-hidden="true" tabindex="-1"></a><span class="fu">### Triangles (triads)</span></span>
<span id="cb122-868"><a href="#cb122-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-869"><a href="#cb122-869" aria-hidden="true" tabindex="-1"></a>In a network, a triangle is a collection of three nodes (or vertices) that are all connected. A high number of triangles in a network indicates that nodes tend to be highly interconnected, forming dense clusters or communities. In contrast, a low number of triangles suggests that nodes are more sparsely connected and less likely to form tightly-knit groups.</span>
<span id="cb122-870"><a href="#cb122-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-871"><a href="#cb122-871" aria-hidden="true" tabindex="-1"></a>We can use the function <span class="in">`triangles()`</span> to show all the triangles in the network. Let us the <span class="in">`df_rel_ig`</span> igraph object that we created at the beginning of this tutorial.</span>
<span id="cb122-872"><a href="#cb122-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-875"><a href="#cb122-875" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-876"><a href="#cb122-876" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the network</span></span>
<span id="cb122-877"><a href="#cb122-877" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig)</span>
<span id="cb122-878"><a href="#cb122-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-879"><a href="#cb122-879" aria-hidden="true" tabindex="-1"></a><span class="co"># show all triangles in the network.</span></span>
<span id="cb122-880"><a href="#cb122-880" aria-hidden="true" tabindex="-1"></a><span class="fu">matrix</span>(<span class="fu">triangles</span>(df_rel_ig), <span class="at">nrow =</span> <span class="dv">3</span>)</span>
<span id="cb122-881"><a href="#cb122-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-882"><a href="#cb122-882" aria-hidden="true" tabindex="-1"></a><span class="co"># counting triangles with Isabelle as the vertex</span></span>
<span id="cb122-883"><a href="#cb122-883" aria-hidden="true" tabindex="-1"></a><span class="fu">count_triangles</span>(df_rel_ig, <span class="at">vids=</span> <span class="st">'Isabelle'</span>)</span>
<span id="cb122-884"><a href="#cb122-884" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-885"><a href="#cb122-885" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-886"><a href="#cb122-886" aria-hidden="true" tabindex="-1"></a>There are 3 triangles with Isabelle as the vertex.</span>
<span id="cb122-887"><a href="#cb122-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-888"><a href="#cb122-888" aria-hidden="true" tabindex="-1"></a><span class="fu">### Transitivity</span></span>
<span id="cb122-889"><a href="#cb122-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-890"><a href="#cb122-890" aria-hidden="true" tabindex="-1"></a>The number of triangles in a network can be quantified using a metric called the clustering coefficient (transitivity). The clustering coefficient of a node is defined as the fraction of pairs of the node's neighbors that are connected by an edge.</span>
<span id="cb122-891"><a href="#cb122-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-892"><a href="#cb122-892" aria-hidden="true" tabindex="-1"></a>Global transitivity (also known as the global clustering coefficient) is a measure of the proportion of triangles in the entire network. It is the ratio of the total number of triangles in a network to the total number of possible triangles. High global transitivity indicates that the nodes in the network are highly interconnected, forming tightly-knit clusters.</span>
<span id="cb122-893"><a href="#cb122-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-894"><a href="#cb122-894" aria-hidden="true" tabindex="-1"></a>To calculate the global transitivity, we can use the function <span class="in">`transitivity()`</span></span>
<span id="cb122-895"><a href="#cb122-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-898"><a href="#cb122-898" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-899"><a href="#cb122-899" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculating global transitivity </span></span>
<span id="cb122-900"><a href="#cb122-900" aria-hidden="true" tabindex="-1"></a><span class="fu">transitivity</span>(df_rel_ig)</span>
<span id="cb122-901"><a href="#cb122-901" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-902"><a href="#cb122-902" aria-hidden="true" tabindex="-1"></a>The value 0.32 means that 32% of the total possible triangles are represented in the given network.</span>
<span id="cb122-903"><a href="#cb122-903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-904"><a href="#cb122-904" aria-hidden="true" tabindex="-1"></a>Local transitivity (also known as local clustering coefficient) is a measure of the transitivity of individual nodes or small groups of nodes in the network. It is the proportion of triangles that exist among the neighbors of a given node to the total number of possible triangles among those neighbors. A high local transitivity indicates that a node's neighbors are highly interconnected, forming a cluster or clique, while a low local transitivity suggests that the node's neighbors are not well-connected to each other.</span>
<span id="cb122-905"><a href="#cb122-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-906"><a href="#cb122-906" aria-hidden="true" tabindex="-1"></a>To calculate the local transitivity, we again use the function <span class="in">`transitivity()`</span> but also include the following arguments to specify the individual vertex (<span class="in">`vids = `</span>) and also specify that we want to calculate the local transitivity (<span class="in">`type = 'local'`</span>)</span>
<span id="cb122-907"><a href="#cb122-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-910"><a href="#cb122-910" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-911"><a href="#cb122-911" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating local transitivity around Isabelle</span></span>
<span id="cb122-912"><a href="#cb122-912" aria-hidden="true" tabindex="-1"></a><span class="fu">transitivity</span>(df_rel_ig, <span class="at">vids =</span> <span class="st">'Isabelle'</span>, <span class="at">type =</span> <span class="st">'local'</span>)</span>
<span id="cb122-913"><a href="#cb122-913" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-914"><a href="#cb122-914" aria-hidden="true" tabindex="-1"></a>The value 0.3 means that, 30% of the total possible triangles with Isabelle as a vertex is represented in the given network.</span>
<span id="cb122-915"><a href="#cb122-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-916"><a href="#cb122-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-917"><a href="#cb122-917" aria-hidden="true" tabindex="-1"></a>In summary, global transitivity measures the extent of clustering in the entire network, while local transitivity measures the extent of clustering around individual nodes or small groups of nodes in the network.</span>
<span id="cb122-918"><a href="#cb122-918" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-919"><a href="#cb122-919" aria-hidden="true" tabindex="-1"></a><span class="fu">### Cliques</span></span>
<span id="cb122-920"><a href="#cb122-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-921"><a href="#cb122-921" aria-hidden="true" tabindex="-1"></a>A clique is a subset of nodes in a network where each node is directly connected to every other node in the subset. In other words, a clique is a fully connected subgraph, where every node in the subset has a direct edge to every other node in the subset.</span>
<span id="cb122-922"><a href="#cb122-922" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-923"><a href="#cb122-923" aria-hidden="true" tabindex="-1"></a>We can use the <span class="in">`largest_cliques()`</span> function to find the largest clique in the network</span>
<span id="cb122-924"><a href="#cb122-924" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-927"><a href="#cb122-927" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-928"><a href="#cb122-928" aria-hidden="true" tabindex="-1"></a><span class="co"># finding the largest clique in the network</span></span>
<span id="cb122-929"><a href="#cb122-929" aria-hidden="true" tabindex="-1"></a><span class="fu">largest_cliques</span>(df_rel_ig)</span>
<span id="cb122-930"><a href="#cb122-930" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-931"><a href="#cb122-931" aria-hidden="true" tabindex="-1"></a>There are 7 cliques tied with 3 vertices.</span>
<span id="cb122-932"><a href="#cb122-932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-933"><a href="#cb122-933" aria-hidden="true" tabindex="-1"></a>We can use <span class="in">`max_cliques()`</span> function to showcase the biggest cliques for each number of vertexes (min. 2 vertices are required for a clique) </span>
<span id="cb122-934"><a href="#cb122-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-937"><a href="#cb122-937" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-938"><a href="#cb122-938" aria-hidden="true" tabindex="-1"></a><span class="co"># finding maximum cliques</span></span>
<span id="cb122-939"><a href="#cb122-939" aria-hidden="true" tabindex="-1"></a><span class="fu">max_cliques</span>(df_rel_ig)</span>
<span id="cb122-940"><a href="#cb122-940" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-941"><a href="#cb122-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-942"><a href="#cb122-942" aria-hidden="true" tabindex="-1"></a><span class="al">![Network substructures](images/network_structure.png)</span></span>
<span id="cb122-943"><a href="#cb122-943" aria-hidden="true" tabindex="-1"></a>The figure given above illustrates a network featuring both closed and open triangles. In the figure, A-K-F, A-K-B, E-G-L are some of the closed triangles in the networks, similarly, J-H-I, E-G-J, E-A-H are open triangles with only two edges, H-I,C and F-C,H are open triangles with only one edge and E,J,I and H,E,C are some of the open triangles with no edges. Here A-C-F-K forms a clique. It should also be noted that a clique of size 3 (3 vertices) is a triangle.</span>
<span id="cb122-944"><a href="#cb122-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-945"><a href="#cb122-945" aria-hidden="true" tabindex="-1"></a><span class="fu">## Identifying special relationships</span></span>
<span id="cb122-946"><a href="#cb122-946" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-947"><a href="#cb122-947" aria-hidden="true" tabindex="-1"></a>In this section, we will further explore the partitioning of networks into sub-networks and determine which vertices are more highly related to one another than others. We will also develop visualization methods by creating three-dimensional visualizations.</span>
<span id="cb122-948"><a href="#cb122-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-949"><a href="#cb122-949" aria-hidden="true" tabindex="-1"></a><span class="fu">### Assortativity</span></span>
<span id="cb122-950"><a href="#cb122-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-951"><a href="#cb122-951" aria-hidden="true" tabindex="-1"></a>Let us take our initial dataset. In this dataset, we have illustrated the relationships between 20 people. One of the interesting questions that we can ask about this network is whether individuals preferably make friends with the same gender or with their same age groups. This is determined by the measure called 'Assortativity'. Assortativity in network analysis refers to the tendency of nodes in a network to be connected to other nodes with similar properties or characteristics. In other words, nodes in an assortative network tend to be connected to other nodes that are like them in some way, such as having similar degrees, attributes, or other characteristics. In our networks, people might be preferably chosen to be in a relationship with other people who are of the same gender or age group.</span>
<span id="cb122-952"><a href="#cb122-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-953"><a href="#cb122-953" aria-hidden="true" tabindex="-1"></a>The function to calculate the assortativity of a network is <span class="in">`assortativity()`</span>. This function takes in two arguments, first is the igraph object and second is the attribute that is common among the vertices. In our dataset, let us use gender as the common attribute. If the common attribute is numeric, then we can directly input the values, but if it's categorical we have to first change it into numeric factor. In our case, we have to change the values of M and F to 0 and 1.</span>
<span id="cb122-954"><a href="#cb122-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-957"><a href="#cb122-957" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-958"><a href="#cb122-958" aria-hidden="true" tabindex="-1"></a><span class="co"># setting gender as the vertex attribute</span></span>
<span id="cb122-959"><a href="#cb122-959" aria-hidden="true" tabindex="-1"></a>df_rel_ig_gender <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig, <span class="st">"gender"</span>, <span class="at">value =</span> df_names<span class="sc">$</span>gender)</span>
<span id="cb122-960"><a href="#cb122-960" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-961"><a href="#cb122-961" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting our network</span></span>
<span id="cb122-962"><a href="#cb122-962" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(df_rel_ig_gender)</span>
<span id="cb122-963"><a href="#cb122-963" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-964"><a href="#cb122-964" aria-hidden="true" tabindex="-1"></a><span class="co"># converting gender values to numeric values</span></span>
<span id="cb122-965"><a href="#cb122-965" aria-hidden="true" tabindex="-1"></a>gender_value <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">factor</span>(<span class="fu">V</span>(df_rel_ig_gender)<span class="sc">$</span>gender))</span>
<span id="cb122-966"><a href="#cb122-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-967"><a href="#cb122-967" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the assortativity</span></span>
<span id="cb122-968"><a href="#cb122-968" aria-hidden="true" tabindex="-1"></a><span class="fu">assortativity</span>(df_rel_ig_gender, gender_value)</span>
<span id="cb122-969"><a href="#cb122-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-970"><a href="#cb122-970" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-971"><a href="#cb122-971" aria-hidden="true" tabindex="-1"></a>Assortativity value ranges from -1 to 1. A value of -1 means that the vertices actively avoid forming relationships with similar vertices, 0 means that the vertices have no preferences in making connections and 1 means that the vertices actively like to form relationships with similar vertices. Here, we have a value of -0.1 which is approximately close to zero, which means the vertices form relationships with each other irrespective of their gender.</span>
<span id="cb122-972"><a href="#cb122-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-973"><a href="#cb122-973" aria-hidden="true" tabindex="-1"></a><span class="fu">### Assortativity degree</span></span>
<span id="cb122-974"><a href="#cb122-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-975"><a href="#cb122-975" aria-hidden="true" tabindex="-1"></a>Another similar value is the assortativity degree. It refers to the extent to which nodes in a network tend to be connected to other nodes with similar degrees. It measures the correlation between the degrees of connected nodes in a network and can be quantified using the degree assortativity coefficient.</span>
<span id="cb122-976"><a href="#cb122-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-977"><a href="#cb122-977" aria-hidden="true" tabindex="-1"></a>The degree assortativity coefficient ranges from -1 to 1, with values close to 1 indicating a highly assortative network, where nodes with high degrees tend to be connected to other nodes with high degrees, and nodes with low degrees tend to be connected to other nodes with low degrees. Values close to -1 indicate a disassortative network, where high-degree nodes tend to be connected to low-degree nodes and vice versa. Finally, a value close to 0 indicates a random network, where there is no particular correlation between the degrees of connected nodes.</span>
<span id="cb122-978"><a href="#cb122-978" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-979"><a href="#cb122-979" aria-hidden="true" tabindex="-1"></a>We can use the function <span class="in">`assortativity.degree()`</span> to calculate the assortativity degree.</span>
<span id="cb122-980"><a href="#cb122-980" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-983"><a href="#cb122-983" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-984"><a href="#cb122-984" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the assortativity degree</span></span>
<span id="cb122-985"><a href="#cb122-985" aria-hidden="true" tabindex="-1"></a><span class="fu">assortativity.degree</span>(df_rel_ig_gender, <span class="at">directed =</span> F)</span>
<span id="cb122-986"><a href="#cb122-986" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-987"><a href="#cb122-987" aria-hidden="true" tabindex="-1"></a>We have a value of 0.01 which is again close to 0, which means that the vertices in our network do not care about the degree of other vertices while forming connections.</span>
<span id="cb122-988"><a href="#cb122-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-989"><a href="#cb122-989" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reciprocity</span></span>
<span id="cb122-990"><a href="#cb122-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-991"><a href="#cb122-991" aria-hidden="true" tabindex="-1"></a>Reciprocity in networks refers to the extent to which pairs of nodes in a network have mutual connections. In other words, if node A is connected to node B and node B is also connected to node A, then there is reciprocity between the two nodes.</span>
<span id="cb122-992"><a href="#cb122-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-993"><a href="#cb122-993" aria-hidden="true" tabindex="-1"></a>Reciprocity can be measured using the reciprocity coefficient, which is the ratio of the number of reciprocated edges (i.e., edges that connect two nodes that are mutually connected) to the total number of edges in the network. The reciprocity coefficient ranges from 0 to 1, with higher values indicating a greater degree of reciprocity in the network.</span>
<span id="cb122-994"><a href="#cb122-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-995"><a href="#cb122-995" aria-hidden="true" tabindex="-1"></a>Reciprocity is an important concept in network analysis because it can have significant implications for the structure and dynamics of networks. Networks with high levels of reciprocity tend to have stronger ties between nodes and be more densely connected, while networks with low levels of reciprocity tend to be more sparsely connected and have weaker ties between nodes.</span>
<span id="cb122-996"><a href="#cb122-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-997"><a href="#cb122-997" aria-hidden="true" tabindex="-1"></a>Reciprocity can be calculated using the function <span class="in">`reciprocity()`</span>.</span>
<span id="cb122-998"><a href="#cb122-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1001"><a href="#cb122-1001" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1002"><a href="#cb122-1002" aria-hidden="true" tabindex="-1"></a><span class="co"># calculating the reciprocity</span></span>
<span id="cb122-1003"><a href="#cb122-1003" aria-hidden="true" tabindex="-1"></a><span class="fu">reciprocity</span>(df_rel_ig_gender)</span>
<span id="cb122-1004"><a href="#cb122-1004" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1005"><a href="#cb122-1005" aria-hidden="true" tabindex="-1"></a>Since our original graph object is undirected, we get the value 1.</span>
<span id="cb122-1006"><a href="#cb122-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1007"><a href="#cb122-1007" aria-hidden="true" tabindex="-1"></a><span class="fu">## Community detection</span></span>
<span id="cb122-1008"><a href="#cb122-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1009"><a href="#cb122-1009" aria-hidden="true" tabindex="-1"></a>Networks sometimes form clusters or communities where a group of vertices with similar attributes form close connections compared to others. This is referred to as community defection. Community detection in network analysis refers to the process of identifying groups or clusters of nodes that are densely connected within a larger network. These groups are often referred to as communities, clusters, or modules, and can provide insights into the organization and function of the network.</span>
<span id="cb122-1010"><a href="#cb122-1010" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1011"><a href="#cb122-1011" aria-hidden="true" tabindex="-1"></a>There are many algorithms to identify communities in a network. We will be looking at two of them; greedy optimization algorithm (<span class="in">`cluster_fast_greedy()`</span>) and Girvan-Newman algorithm (<span class="in">`cluster_edge_betweenness()`</span>).</span>
<span id="cb122-1012"><a href="#cb122-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1013"><a href="#cb122-1013" aria-hidden="true" tabindex="-1"></a>The greedy optimization algorithm iteratively merges nodes or communities in the network to maximize the modularity of the resulting partition. Modularity is a measure of the density of edges within communities compared to the expected density of edges in a randomized network. Maximizing modularity is a common criterion for community detection in networks because it reflects the degree to which the network is organized into cohesive and densely connected communities. The greedy optimization algorithm starts with each node in its community and iteratively merges the most similar communities until the modularity of the resulting partition can no longer be increased.</span>
<span id="cb122-1014"><a href="#cb122-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1015"><a href="#cb122-1015" aria-hidden="true" tabindex="-1"></a>The Girvan-Newman algorithm iteratively removes the edges with the highest betweenness centrality in the network, which are the edges that are most frequently traversed by the shortest paths between pairs of nodes in the network. The removal of these edges gradually breaks the network into smaller and smaller clusters or communities. It is widely used for community detection in complex networks because it is relatively fast and can detect communities of varying sizes and shapes.</span>
<span id="cb122-1016"><a href="#cb122-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1017"><a href="#cb122-1017" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fast-greedy community detection</span></span>
<span id="cb122-1018"><a href="#cb122-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1019"><a href="#cb122-1019" aria-hidden="true" tabindex="-1"></a>Using the <span class="in">`cluster_fast_greedy()`</span> function let us find if there exist any communities in our dataset <span class="in">`df_rel_ig_gender`</span></span>
<span id="cb122-1020"><a href="#cb122-1020" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1023"><a href="#cb122-1023" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1024"><a href="#cb122-1024" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-1025"><a href="#cb122-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1026"><a href="#cb122-1026" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform fast-greedy community detection on the network graph</span></span>
<span id="cb122-1027"><a href="#cb122-1027" aria-hidden="true" tabindex="-1"></a>fg <span class="ot">=</span> <span class="fu">cluster_fast_greedy</span>(df_rel_ig_gender)</span>
<span id="cb122-1028"><a href="#cb122-1028" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1029"><a href="#cb122-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1030"><a href="#cb122-1030" aria-hidden="true" tabindex="-1"></a>Using the <span class="in">`sizes()`</span> function, we can see the number of members in each of the communities.</span>
<span id="cb122-1031"><a href="#cb122-1031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1034"><a href="#cb122-1034" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1035"><a href="#cb122-1035" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine the sizes of each community</span></span>
<span id="cb122-1036"><a href="#cb122-1036" aria-hidden="true" tabindex="-1"></a><span class="fu">sizes</span>(fg)</span>
<span id="cb122-1037"><a href="#cb122-1037" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1038"><a href="#cb122-1038" aria-hidden="true" tabindex="-1"></a>The output shows that Community 1 has 6 members and Community 2 has 4 members.</span>
<span id="cb122-1039"><a href="#cb122-1039" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1040"><a href="#cb122-1040" aria-hidden="true" tabindex="-1"></a>The <span class="in">`membership()`</span> function shows to which community each of the members belongs to.</span>
<span id="cb122-1041"><a href="#cb122-1041" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1044"><a href="#cb122-1044" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1045"><a href="#cb122-1045" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine which individuals belong to which community</span></span>
<span id="cb122-1046"><a href="#cb122-1046" aria-hidden="true" tabindex="-1"></a><span class="fu">membership</span>(fg)</span>
<span id="cb122-1047"><a href="#cb122-1047" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1048"><a href="#cb122-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1049"><a href="#cb122-1049" aria-hidden="true" tabindex="-1"></a>To plot the community structure, we can simply use input from the 'communities' object that we have created using the algorithm function.</span>
<span id="cb122-1050"><a href="#cb122-1050" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1053"><a href="#cb122-1053" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1054"><a href="#cb122-1054" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the community structure of the network</span></span>
<span id="cb122-1055"><a href="#cb122-1055" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fg, df_rel_ig_gender)</span>
<span id="cb122-1056"><a href="#cb122-1056" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1057"><a href="#cb122-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1058"><a href="#cb122-1058" aria-hidden="true" tabindex="-1"></a><span class="fu">### Edge-betweenness community detection</span></span>
<span id="cb122-1059"><a href="#cb122-1059" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1060"><a href="#cb122-1060" aria-hidden="true" tabindex="-1"></a>Similar to the earlier case, we use the <span class="in">`cluster_edge_betweenness ()`</span> function to find the communities in our dataset <span class="in">`df_rel_ig_gender`</span>.</span>
<span id="cb122-1061"><a href="#cb122-1061" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1064"><a href="#cb122-1064" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1065"><a href="#cb122-1065" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: true</span></span>
<span id="cb122-1066"><a href="#cb122-1066" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1067"><a href="#cb122-1067" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform edge-betweenness community detection on the network graph</span></span>
<span id="cb122-1068"><a href="#cb122-1068" aria-hidden="true" tabindex="-1"></a>eb <span class="ot">=</span> <span class="fu">cluster_edge_betweenness</span>(df_rel_ig_gender)</span>
<span id="cb122-1069"><a href="#cb122-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1070"><a href="#cb122-1070" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine sizes of each community</span></span>
<span id="cb122-1071"><a href="#cb122-1071" aria-hidden="true" tabindex="-1"></a><span class="fu">sizes</span>(eb)</span>
<span id="cb122-1072"><a href="#cb122-1072" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1073"><a href="#cb122-1073" aria-hidden="true" tabindex="-1"></a>The output shows that Community 1 has 3 members community 2 has 2 members and Community 3 has 5 members.</span>
<span id="cb122-1074"><a href="#cb122-1074" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1077"><a href="#cb122-1077" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1078"><a href="#cb122-1078" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine which individuals belong to which community</span></span>
<span id="cb122-1079"><a href="#cb122-1079" aria-hidden="true" tabindex="-1"></a><span class="fu">membership</span>(eb)</span>
<span id="cb122-1080"><a href="#cb122-1080" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1081"><a href="#cb122-1081" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1082"><a href="#cb122-1082" aria-hidden="true" tabindex="-1"></a>Let us now compare both graphs.</span>
<span id="cb122-1083"><a href="#cb122-1083" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1086"><a href="#cb122-1086" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1087"><a href="#cb122-1087" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting both graphs side-wise</span></span>
<span id="cb122-1088"><a href="#cb122-1088" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb122-1089"><a href="#cb122-1089" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fg, df_rel_ig_gender, <span class="at">main=</span> <span class="st">"Fast-greedy"</span>)</span>
<span id="cb122-1090"><a href="#cb122-1090" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(eb, df_rel_ig_gender, <span class="at">main=</span> <span class="st">"Edge-betweenness"</span>)</span>
<span id="cb122-1091"><a href="#cb122-1091" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1092"><a href="#cb122-1092" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1093"><a href="#cb122-1093" aria-hidden="true" tabindex="-1"></a>In general, the cluster-fast greedy algorithm is faster and more scalable than the cluster_edge_betweenness algorithm and is a good choice for large networks with many nodes and edges. It can detect communities of varying sizes and shapes and is less sensitive to noise.</span>
<span id="cb122-1094"><a href="#cb122-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1095"><a href="#cb122-1095" aria-hidden="true" tabindex="-1"></a>On the other hand, the cluster edge betweenness algorithm is more computationally expensive and may be more appropriate for smaller networks. It can also be useful for identifying communities that are not well-separated or that overlap with each other.</span>
<span id="cb122-1096"><a href="#cb122-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1097"><a href="#cb122-1097" aria-hidden="true" tabindex="-1"></a><span class="fu">## Interactive network visualizations</span></span>
<span id="cb122-1098"><a href="#cb122-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1099"><a href="#cb122-1099" aria-hidden="true" tabindex="-1"></a>One of the coolest things about network analysis is the visualization process. Up until now, we have only plotted static graphs. In this section, we will plot networks that can be physically (with a mouse pointer) interacted with using the <span class="in">`{threejs}`</span> package in R. We will only cover the basics of 3D visualization.</span>
<span id="cb122-1100"><a href="#cb122-1100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1101"><a href="#cb122-1101" aria-hidden="true" tabindex="-1"></a>Plotting the graph is as simple as using the function <span class="in">`graphjs()`</span> from the <span class="in">`{threejs}`</span> package.</span>
<span id="cb122-1102"><a href="#cb122-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1105"><a href="#cb122-1105" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1106"><a href="#cb122-1106" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(threejs)) <span class="fu">install.packages</span>(<span class="st">'threejs'</span>)</span>
<span id="cb122-1107"><a href="#cb122-1107" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(threejs)</span>
<span id="cb122-1108"><a href="#cb122-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1109"><a href="#cb122-1109" aria-hidden="true" tabindex="-1"></a><span class="co"># plotting our previous network</span></span>
<span id="cb122-1110"><a href="#cb122-1110" aria-hidden="true" tabindex="-1"></a><span class="fu">graphjs</span>(df_rel_ig_gender)</span>
<span id="cb122-1111"><a href="#cb122-1111" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1112"><a href="#cb122-1112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1113"><a href="#cb122-1113" aria-hidden="true" tabindex="-1"></a>We can finally move our networks!</span>
<span id="cb122-1114"><a href="#cb122-1114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1115"><a href="#cb122-1115" aria-hidden="true" tabindex="-1"></a>Let us re-plot the network we got after using the fast-greedy community algorithm. Since the size of the network is 2, we denote two colors to represent each of the two communities. You can also hover over the vertices to display its name on top.</span>
<span id="cb122-1116"><a href="#cb122-1116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1119"><a href="#cb122-1119" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb122-1120"><a href="#cb122-1120" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(threejs)</span>
<span id="cb122-1121"><a href="#cb122-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1122"><a href="#cb122-1122" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform fast-greedy community detection on network graph</span></span>
<span id="cb122-1123"><a href="#cb122-1123" aria-hidden="true" tabindex="-1"></a>fg <span class="ot">=</span> <span class="fu">cluster_fast_greedy</span>(df_rel_ig_gender)</span>
<span id="cb122-1124"><a href="#cb122-1124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1125"><a href="#cb122-1125" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an object 'i' containing the memberships of the fast-greedy community detection</span></span>
<span id="cb122-1126"><a href="#cb122-1126" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span>  <span class="fu">membership</span>(fg)</span>
<span id="cb122-1127"><a href="#cb122-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1128"><a href="#cb122-1128" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the number of different communities</span></span>
<span id="cb122-1129"><a href="#cb122-1129" aria-hidden="true" tabindex="-1"></a>size_fg <span class="ot">&lt;-</span> <span class="fu">sizes</span>(fg)</span>
<span id="cb122-1130"><a href="#cb122-1130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1131"><a href="#cb122-1131" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a color attribute to each vertex, setting the vertex color based on community membership</span></span>
<span id="cb122-1132"><a href="#cb122-1132" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">set_vertex_attr</span>(df_rel_ig_gender, <span class="st">"color"</span>, <span class="at">value =</span> <span class="fu">c</span>(<span class="st">"yellow"</span>, <span class="st">"blue"</span>)[i])</span>
<span id="cb122-1133"><a href="#cb122-1133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1134"><a href="#cb122-1134" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the graph using threejs</span></span>
<span id="cb122-1135"><a href="#cb122-1135" aria-hidden="true" tabindex="-1"></a><span class="fu">graphjs</span>(g, <span class="at">vertex.label =</span> df_names<span class="sc">$</span>name)</span>
<span id="cb122-1136"><a href="#cb122-1136" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb122-1137"><a href="#cb122-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1138"><a href="#cb122-1138" aria-hidden="true" tabindex="-1"></a>With that, we have successfully learned the basics of network analysis using R.</span>
<span id="cb122-1139"><a href="#cb122-1139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1140"><a href="#cb122-1140" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb122-1141"><a href="#cb122-1141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1142"><a href="#cb122-1142" aria-hidden="true" tabindex="-1"></a>In short, we learned about;</span>
<span id="cb122-1143"><a href="#cb122-1143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1144"><a href="#cb122-1144" aria-hidden="true" tabindex="-1"></a><span class="ss">1.    </span>What is a network and what are the different ways to denote the network data?</span>
<span id="cb122-1145"><a href="#cb122-1145" aria-hidden="true" tabindex="-1"></a><span class="ss">2.    </span>How to convert the network data into an igraph object to analyze and plot the network via the <span class="in">`{igraph}`</span> package in R.</span>
<span id="cb122-1146"><a href="#cb122-1146" aria-hidden="true" tabindex="-1"></a><span class="ss">3.    </span>What are vertex and edge attributes and how do add them to the igraph object?</span>
<span id="cb122-1147"><a href="#cb122-1147" aria-hidden="true" tabindex="-1"></a><span class="ss">4.    </span>How do filter attributes and how can we visualize them?</span>
<span id="cb122-1148"><a href="#cb122-1148" aria-hidden="true" tabindex="-1"></a><span class="ss">5.    </span>What are the different types of network visualizations?</span>
<span id="cb122-1149"><a href="#cb122-1149" aria-hidden="true" tabindex="-1"></a><span class="ss">6.    </span>What are directed networks?</span>
<span id="cb122-1150"><a href="#cb122-1150" aria-hidden="true" tabindex="-1"></a><span class="ss">7.    </span>What is path length?</span>
<span id="cb122-1151"><a href="#cb122-1151" aria-hidden="true" tabindex="-1"></a><span class="ss">8.    </span>What are the different measures of network structure?</span>
<span id="cb122-1152"><a href="#cb122-1152" aria-hidden="true" tabindex="-1"></a><span class="ss">9.    </span>What is network randomization test and why is its purpose?</span>
<span id="cb122-1153"><a href="#cb122-1153" aria-hidden="true" tabindex="-1"></a><span class="ss">10.   </span>what are the different network substructures?</span>
<span id="cb122-1154"><a href="#cb122-1154" aria-hidden="true" tabindex="-1"></a><span class="ss">11.   </span>How to identify special relationships in the network?</span>
<span id="cb122-1155"><a href="#cb122-1155" aria-hidden="true" tabindex="-1"></a><span class="ss">12.   </span>How to find communities in a network?</span>
<span id="cb122-1156"><a href="#cb122-1156" aria-hidden="true" tabindex="-1"></a><span class="ss">13.   </span>How to visualize the network in 3D using the <span class="in">`{threejs}`</span> package ?</span>
<span id="cb122-1157"><a href="#cb122-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1158"><a href="#cb122-1158" aria-hidden="true" tabindex="-1"></a>This tutorial is based on my notes from attending the 'Network Analysis in R' course on DataCamp. As with any personal notes, there may be mistakes and some of the information presented may not accurately reflect the topic. If you notice any errors, please feel free to leave a comment in the section below.</span>
<span id="cb122-1159"><a href="#cb122-1159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1160"><a href="#cb122-1160" aria-hidden="true" tabindex="-1"></a>I am particularly interested in learning about 3D visualization techniques, which I find to be fascinating. If I am able to learn more about this topic, I will write a sequel to this tutorial. Thank you for reading!</span>
<span id="cb122-1161"><a href="#cb122-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1162"><a href="#cb122-1162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-1163"><a href="#cb122-1163" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;a</span> <span class="er">hidden</span> <span class="er">href</span><span class="ot">=</span><span class="st">"https://info.flagcounter.com/ynrK"</span><span class="kw">&gt;&lt;img</span> <span class="er">src</span><span class="ot">=</span><span class="st">"https://s11.flagcounter.com/count2/ynrK/bg_000000/txt_FFFFFF/border_F0F0F0/columns_5/maxflags_25/viewers_0/labels_1/pageviews_1/flags_0/percent_0/"</span> <span class="er">alt</span><span class="ot">=</span><span class="st">"Flag Counter"</span> <span class="er">border</span><span class="ot">=</span><span class="st">"0"</span><span class="kw">/&gt;&lt;/a&gt;</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Blog made using <a href="https://quarto.org/">Quarto®</a> with ❤️, by Jewel Johnson.</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jeweljohnsonj">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/jeweljohnsonj">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:jewel15@alumni.iisertvm.ac.in">
      <i class="bi bi-briefcase" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:jeweljohnsonj@gmail.com">
      <i class="bi bi-house" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<div class="page-columns page-rows-contents page-layout-article"><div class="social-share"><a href="https://twitter.com/share?url=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html&amp;text=Introduction to Network Analysis in R" target="_blank" class="twitter"><i class="fab fa-twitter fa-fw fa-lg"></i></a><a href="https://www.linkedin.com/shareArticle?url=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html&amp;title=Introduction to Network Analysis in R" target="_blank" class="linkedin"><i class="fa-brands fa-linkedin-in fa-fw fa-lg"></i></a>  <a href="mailto:?subject=Introduction to Network Analysis in R&amp;body=Check out this link:https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html" target="_blank" class="email"><i class="fa-solid fa-envelope fa-fw fa-lg"></i></a><a href="https://www.facebook.com/sharer.php?u=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html" target="_blank" class="facebook"><i class="fab fa-facebook-f fa-fw fa-lg"></i></a><a href="https://reddit.com/submit?url=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html&amp;title=Introduction to Network Analysis in R" target="_blank" class="reddit">   <i class="fa-brands fa-reddit-alien fa-fw fa-lg"></i></a><a href="https://www.stumbleupon.com/submit?url=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html&amp;title=Introduction to Network Analysis in R" target="_blank" class="stumbleupon"><i class="fa-brands fa-stumbleupon fa-fw fa-lg"></i></a><a href="https://www.tumblr.com/share/link?url=https://sciquest.netlify.app/tutorials/stat_model/network_analysis.html&amp;name=Introduction to Network Analysis in R" target="_blank" class="tumblr"><i class="fa-brands fa-tumblr fa-fw fa-lg"></i></a></div></div>



<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>