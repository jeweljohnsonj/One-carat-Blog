[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "one carat blog",
    "section": "",
    "text": "Image 01\n\n\nAsian honey bee\n\n\n\n\nImage 02\n\n\nJungle babbler\n\n\n\n\nImage 03\n\n\nBonnet macaque\n\n\n\n\nImage 04\n\n\nIndian peafowl\n\n\n\n\nImage 05\n\n\nNilgiri tahr\n\n\n\n\nImage 06\n\n\nBlue tailed bee eater"
  },
  {
    "objectID": "articles/data_viz/project1.html",
    "href": "articles/data_viz/project1.html",
    "title": "Chapter 1: Data visualization using ggplot2",
    "section": "",
    "text": "In this chapter we will be plotting different types of graphs using a package called ggplot2 in R. The ggplot2 package is based on ‘grammar of graphics plot’ which provides a systematic way of doing data visualizations in R. With a few lines of code you can plot a simple graph and by adding more layers onto it you can create complex yet elegant data visualizations.\nA ggplot2 graph is made up of three components.\n\n\nData: Data of your choice that you want to visually summarise.\n\nGeometry or geoms: Geometry dictates the type of graph that you want to plot and this information is conveyed to ggplot2 through the geom() command code. For e.g. using the geom_boxplot() command, you can plot a box plot with your data. Likewise, there are many types of geometry that you can plot using the ggplot2 package.\n\nAesthetic mappings: Aesthetics define the different kinds of information that you want to include in the plot. One fo the most important aesthetic is in choosing which data values to plot on the x-axis and the y-axis. Another example is changing the colour of the data points, which can be used to differentiate two different categories in the data. The use of aesthetics depends on the geometry that you are using. We use the command aes() for adding different types of aesthetics to the plot. We will learn more about aes() in Chapter 2.\n\nThis tutorial is primarily focused on students who are beginners in R programming and wants to quickly plot their data without much of a hassle. So without further ado let’s plot some graphs!"
  },
  {
    "objectID": "articles/data_viz/project1.html#setting-up-the-prerequisites",
    "href": "articles/data_viz/project1.html#setting-up-the-prerequisites",
    "title": "Chapter 1: Data visualization using ggplot2",
    "section": "\n2 Setting up the prerequisites",
    "text": "2 Setting up the prerequisites\nFirst, we need to install the ggplot2 package in R as it does not come in the standard distribution of R.\n\nTo install packages in R we use the command install.packages() and to load packages we use the command library(). Therefore to install and load ggplot2 package we use the following lines of command.\n\n\nCodeinstall.packages(\"ggplot2\")\nlibrary(ggplot2)\n\n\nAll right we have the ggplot2 package loaded, now we just need some data to plot. Most R programming tutorials use the iris dataset as an example. But this tutorial won’t be like most tutorials. So let me introduce you to some lovely penguins from Palmer Station in Antarctica!\nFor this tutorial, we will be installing the palmerpenguins package which showcases body measurements taken from three different species of penguins from Antarctica. This package was made possible by the efforts of Dr. Allison Horst. The penguin data was collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER.\n\nInstall the palmerpenguins package and load it in R.\n\n\nCodeinstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\n\n\nNow there are two datasets in this package. We will be using the penguins dataset which is a simplified version of the raw data present in the package.\n\nUse the command head() to display the first few values of penguins dataset to see how it looks like\n\n\nCodelibrary(palmerpenguins)\nknitr::kable(head(penguins))\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\n\n\n\nWe can see that are 8 columns in the dataset representing different values. Now let us try plotting some graphs with this data.\n\n2.1 Bar graph\nSo we will try to plot a simple bar graph first. Bar graphs are used to represent categorical data where the height of the rectangular bar represents the value for that category. We will plot a bargraph representing frequency data for all three species of penguins.\n\nWe will be using the geom_bar() command to plot the bar graph. Let us also use the command theme_bw() for a nice looking theme.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = species, fill = species)) + \n  xlab(\"Species\") + ylab(\"Frequency\") + \n  ggtitle(\"Frequency of individuals for each species\") + \n  geom_bar() + theme_bw()\n\n\n\n\n\n2.2 Histogram\nHistograms are similar to bar graphs visually. But histograms are used to represent continuous data. Also the all the rectangular bars will have the same bin size or width.\n\nWe can plot a histogram using the command geom_histogram().\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = body_mass_g, fill = species)) + \n  xlab(\"Body Mass (g)\") + ylab(\"Frequency\") + \n  ggtitle(\"Frequency of individuals for respective body mass\") + \n  geom_histogram(bins = 25) + theme_bw()\n\nWarning: Removed 2 rows containing non-finite values (stat_bin).\n\n\n\n\n\nThe warning message indicates that for two rows in the dataset, they have NA values or that they did not have any values present. This is true for real-life cases, as during data collection sometimes you will be unable to collect data due to various reasons. So this is perfectly fine.\n\n2.3 Line graph\nLine graph simply joins together data points to show overall distribution.\n\nUse the command geom_line() for plotting a line graph.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = bill_length_mm, \n                            y = bill_depth_mm, colour = species)) + \n  xlab(\"Bill length (mm)\") + ylab(\"Bill depth (mm)\") + \n  ggtitle(\"Bill length vs Bill depth\") + geom_line() + theme_bw()\n\n\n\n\n\n2.4 Scatter plot\nThe scatter plot simply denotes the data points in the dataset.\n\nUse the command geom_point() to plot a scatter plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = body_mass_g, y = flipper_length_mm, \n                            shape = species, colour = species)) + \n  xlab(\"Body mass (g)\") + ylab(\"Flipper length (mm)\") + \n  ggtitle(\"Body mass vs Filpper length\") + geom_point(size = 2) + theme_bw()\n\n\n\n\n\n2.5 Density Plot\nDensity plots are similar to histograms but show it shows the overall distribution of the data in a finer way. This way we will get a bell-shaped curve if our data follows a normal distribution.\n\nUse the command geom_density() to a density plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = body_mass_g, fill = species)) + \n  xlab(\"Body Mass (g)\") + ylab(\"Density\") + ggtitle(\"Body mass distribution\") + \n  geom_density() + theme_bw()\n\n\n\n\nSince we plotted for all three species the graph looks clustered. Let us try plotting the same graph for only gentoo penguins. We will use the dplyr package to filter() data for gentoo penguins alone. The dplyr package comes in-built with R so just load the dplyr package using the command library().\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\nlibrary(dplyr)\n\npenguins_gentoo <- penguins %>% filter(species == \"Gentoo\")\n\nggplot(data = penguins_gentoo, aes(x = body_mass_g)) + \n  xlab(\"Body Mass of Gentoo penguins (g)\") + ylab(\"Density\") + \n  ggtitle(\"Body mass distribution of Gentoo penguins\") + \n  geom_density(fill = \"red\") + theme_bw()\n\n\n\n\n\n2.6 Dot-plot\nDot-plot is similar to a density plot but it shows discretely each data point in the distribution.\n\nUse the command geom_dotplot() to plot a dot-plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = species, y = body_mass_g, fill = species)) + \n  xlab(\"Species\") + ylab(\"Body mass (g)\") + \n  ggtitle(\"Body mass in three diferent species of penguins\") + \n  geom_dotplot(binaxis = \"y\", stackdir = \"center\", binwidth = 100) + theme_bw()\n\n\n\n\n\n2.7 Rug-plot\nRug-plot is a simple way to visualize the distribution of data along the axis lines. It is often used in conjunction with other graphical representations.\n\nUse the command geom_rug() to plot a rug-plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\nlibrary(dplyr)\n\npenguins_gentoo <- penguins %>% filter(species == \"Gentoo\")\n\nggplot(data = penguins_gentoo, aes(x = body_mass_g, y = flipper_length_mm)) + \n  xlab(\"Body Mass of Gentoo penguins (g)\") + ylab(\"Density\") + \n  ggtitle(\"Body mass distribution of Gentoo penguins\") + \n  geom_point(colour = \"darkred\") + geom_rug() + theme_bw()\n\n\n\n\n\n2.8 Box plot\nBox-plot is one of the better ways of showing data via quartiles. You can learn more about box plots here.\n\nUse the command geom_boxplot() to plot a box-plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = species, y = body_mass_g, colour = species)) + \n  xlab(\"Species\") + ylab(\"Body mass (g)\") + \n  ggtitle(\"Body mass in three diferent species of penguins\") + geom_boxplot() + \n  theme_bw()\n\n\n\n\n\n2.9 Violin plot\nViolin plot can be considered as the best of both a box-plot and a density plot. It shows the quartile values, like in a box-plot and also shows the distribution of the data, like in a density plot.\n\nUse the command geom_violin() in conjunction with geom_boxplot() to plot a violin plot.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = species, y = body_mass_g, fill = species)) + \n  xlab(\"Species\") + ylab(\"Body mass (g)\") + \n  ggtitle(\"Body mass in three diferent species of penguins\") + \n  geom_violin(aes(colour = species), trim = TRUE) + geom_boxplot(width = 0.2) +\n  theme_bw()"
  },
  {
    "objectID": "articles/data_viz/project1.html#saving-your-ggplot2-graphs",
    "href": "articles/data_viz/project1.html#saving-your-ggplot2-graphs",
    "title": "Chapter 1: Data visualization using ggplot2",
    "section": "\n3 Saving your ggplot2 graphs",
    "text": "3 Saving your ggplot2 graphs\n\nUse the command ggsave() to save the graph locally. In the code below, ‘my_graph’ is the ggplot element containing your graph. The plot will be saved in your working directory.\n\n\nCodelibrary(ggplot2)\nlibrary(palmerpenguins)\n\nmy_graph <- ggplot(data = penguins, aes(x = species, y = body_mass_g,\n                                    fill = species)) + \n  xlab(\"Species\") + ylab(\"Body mass (g)\") + \n  ggtitle(\"Body mass in three diferent species of penguins\") + \n  geom_violin(aes(colour = species), trim = TRUE) + \n  geom_boxplot(width = 0.2) +\n  theme_bw()\n\n#to save the plot\nggsave(my_graph, filename = \"your_graph_name.png\", width = 20, height = 20,\n       units = \"cm\")"
  },
  {
    "objectID": "articles/data_viz/project1.html#summary",
    "href": "articles/data_viz/project1.html#summary",
    "title": "Chapter 1: Data visualization using ggplot2",
    "section": "\n4 Summary",
    "text": "4 Summary\nI hope this tutorial helped you to get familiarized with the ggplot2 commands. There are many more different types of graphs that you can plot using ggplot2. The tutorial only showed some of the commonly used ones. The best way to learn R is through actually doing it yourself. Try to recreate the examples given in this tutorial by yourself and then try what you learned with the different datasets available in R. Have a good day!"
  },
  {
    "objectID": "articles/data_viz/project1.html#references",
    "href": "articles/data_viz/project1.html#references",
    "title": "Chapter 1: Data visualization using ggplot2",
    "section": "\n5 References",
    "text": "5 References\n\nH. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016. Read more about ggplot2 here. You can also look at the cheat sheet for all the syntax used in ggplot2. Also check this out.\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.\n\nLast updated on\n\n\n[1] \"2022-05-26 07:02:34 IST\""
  },
  {
    "objectID": "articles/data_man/project5.html",
    "href": "articles/data_man/project5.html",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "",
    "text": "Raw data might not be always in a usable form for any form of analysis or visualization process. The tidyr package aims to help you in reshaping your data in a usable form. In short, it helps you to ‘tidy’ up your data using various tools. In this chapter, we will see how you can use the tidyr package to make your data tidy."
  },
  {
    "objectID": "articles/data_man/project5.html#what-is-tidy-data",
    "href": "articles/data_man/project5.html#what-is-tidy-data",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n2 What is tidy data?",
    "text": "2 What is tidy data?\nFirst, we need to understand what tidy data looks like. For that let us imagine a scenario where you are a doctor who is trying to find the best treatment for a disease. Now your colleagues have short-listed five different treatment methods and have reported their efficacy values when tested with five different patients. Now you are tasked with finding which of the five treatments is the best against the disease. You open your computer and you find the following data of the experiment.\n\n\n\n\n  \n\n\n\nThis is how often data is stored because it is easy to write it this way. In the first column, you can see the different treatments from one to five. And in the second column, you have the efficacy values of the treatments for patient 1 and it goes on for the other patients. Now, this is a good example of how a dataset should not look like! Surprised? Let us see what makes this dataset ‘dirty’.\nYou can quickly notice that there is no mentioning of what these numerical values mean. Of course, we know that they are efficacy values for the different treatments. But for someone who only has this data as a reference, that person would not have a clue as to what these numbers mean. Also, note that each of the rows contains multiple observation values which is not a feature of tidy data. This kind of data format is called ‘wide data’ which we will talk more about later.\nWith that being said, tidy data will have;\n\nEach of its variables represented in its own column\nEach observation or a case in its own row.\nEach of the rows will contain only a single value.\n\nSo let us see how the ‘tidier’ version of this data would look like.\n\n\n\n\n  \n\n\n\nYou can see each of the columns represent only one type of variable. In the first column, you have the types of treatments, followed by patient IDs and their efficacy values for each treatment. Also, note that each row represents only one observation. So this kind of data format is what we strive to achieve by using the tidyr package and they are called as ‘long data’. So let us begin!"
  },
  {
    "objectID": "articles/data_man/project5.html#reshaping-dataset",
    "href": "articles/data_man/project5.html#reshaping-dataset",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n3 Reshaping dataset",
    "text": "3 Reshaping dataset\nThere are different sets of commands which you can utilize to reshape your data and make it tidy. Let us each of these commands in action. But first, make sure you have the tidyr package loaded.\n\nCode# load tidyr package\nlibrary(tidyr)\n\n\n\n3.1 pivot_longer()\nThe pivot_longer() command converts a ‘wide data’ to a ‘long data’. It does so by converting row names to a new column under a new variable name with its corresponding values moved into another column with another variable name. So let us see how it goes. We will take the earlier mentioned example and will see how to make it tidy. Now you don’t have to be concerned with the codes I have used to make the dummy data. Just have your focus on the pivot_longer() syntax.\n\nCodelibrary(tidyr)\n# making a dummy data\n# using sample function to pick random numbers in a sequence\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\n\n# cbind simple combines the columns of same size\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \n\ntrt <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\n\ntrt_data <- cbind(trt, treatment_data)\ntrt_data <- as.data.frame(trt_data) # making it a data frame\n\ntrt_data_tidy <- pivot_longer(trt_data,\n                              c(patient1,patient2,patient3,patient4,patient5), \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\nrmarkdown::paged_table(trt_data_tidy)\n\n\n\n  \n\n\n\nFurthermore, you don’t have to manually type in the column names as you can use colnames() to call the column names of the dataset. Another way of doing the same is by excluding the first column from the process. By doing so the command will automatically pivot all columns except the excluded ones, so in this way, we don’t need to manually specify the column names. The codes given below will give you the same result as before.\n\nShow the codelibrary(tidyr)\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \ntreatment <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\ntrt_data <- cbind(treatment, treatment_data)\ntrt_data <- as.data.frame(trt_data)\n# using colnames, [-1] is included to exclude the name of first column from the process\ntrt_data_tidy1 <- pivot_longer(trt_data,\n                              colnames(trt_data)[-1], \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\n\n# the same can be done by manually specifying which columns to exclude\n# this can be done by denoting the column name ('treatment' in this case) with '-' sign\ntrt_data_tidy2 <- pivot_longer(trt_data, names_to = \"patient_ID\",\n                               values_to = \"efficacy\", -treatment)\n# checking if both the tidy datasets are one and the same\ntrt_data_tidy1 == trt_data_tidy2\n\n\nThe syntax for pivot_longer() is given below with description\n\nCodepivot_longer(\"data\", c(\"colname1, colname2,.....\"), \n  names_to = \"name of the column where your row names are present\",\n  values_to = \"name of the column where your corresponding row values are present\")\n\n\nHere is a graphical representation\n\n\n3.2 pivot_wider()\nThe pivot_wider() does the exact opposite of what pivot_longer() does, which is to convert long data into wide data. We will use the previously given dummy data.\n\nCodelibrary(tidyr)\n# making a dummy data\n# using sample function to pick random numbers in a sequence\npatient1 <- c(seq(1,5,1))\npatient2 <- c(seq(6,10,1))\npatient3 <- c(seq(11,15,1))\npatient4 <- c(seq(16,20,1))\npatient5 <- c(seq(21,25,1))\n\n# cbind simple combines the columns of same size\ntreatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) \n\ntrt <- c(\"treatment1\", \"treatment2\",\"treatment3\",\"treatment4\",\"treatment5\")\n\ntrt_data <- cbind(trt, treatment_data)\ntrt_data <- as.data.frame(trt_data) # making it a data frame\n\ntrt_data_tidy <- pivot_longer(trt_data,\n                              c(patient1,patient2,patient3,patient4,patient5), \n                              names_to = \"patient_ID\", values_to = \"efficacy\")\n\n# making the data wide\ntrt_data_wider <- pivot_wider(trt_data_tidy, names_from = \"patient_ID\",\n                              values_from = \"efficacy\")\n\n# paged_Table() for viewing the dataset as a table, \n# you can see that the dataset is same as before\nrmarkdown::paged_table(trt_data_wider)\n\n\n\n  \n\n\n\nThe syntax for pivot_wider() is given below with description\n\nCodepivot_longer(\"data\", \n  names_from = \"name of the column which contains your wide data columns\",\n  values_from = \"name of the column where your corresponding wide data column values are\")\n\n\nHere is a graphical representation"
  },
  {
    "objectID": "articles/data_man/project5.html#splitting-and-uniting-cells",
    "href": "articles/data_man/project5.html#splitting-and-uniting-cells",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n4 Splitting and uniting cells",
    "text": "4 Splitting and uniting cells\nThere can be an instance where you want to split or untie cells within your dataset. Let us look at some examples.\n\n4.1 unite()\nIn the data given below, let say we want to unite the century column and the year column together. This can be done using the unite() command. You can view the before and after instances in the tabs below.\n\n\nBefore\nAfter\n\n\n\n\nShow the codeevent <- c(letters[1:4])\ncentury <- c(rep(19:20, each = 2))\nyear <- c(seq(10,16,2))\ndata <- as.data.frame(cbind(event,century,year))\n\nrmarkdown::paged_table(data)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nevent <- c(letters[1:4])\ncentury <- c(rep(19:20, each = 2))\nyear <- c(seq(10,16,2))\ndata <- as.data.frame(cbind(event,century,year))\n\n# uniting columns century and year\ndata_new <- unite(data, century, year, col = \"event_year\", sep = \"\")\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n\n\n\n  \n\n\n\n\n\n\nThe syntax of unite() is as follows.\n\nCodeunite(\"dataset name\",\n      \"name of first column to unite, name of second column to unite,.......\",\n      col = \"name of the new column to which all the other column will unite together\",\n      sep = \"input any element as a separator between the joining column values\")\n# in this case we are not putting a sep value\n\n\n\n4.2 separate()\nIn the data given below, let say we want to split the ‘area_perimeter’ column into two separate columns. This can be done using the separate() command. You can view the before and after instances in the tabs below. As always I will be making dummy data to work with.\n\n\nBefore\nAfter\n\n\n\n\nShow the code# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n\n# separating column values into two separate columns named area and perimeter respectively\ndata_new <- separate(data, area_perimetre, sep = \"_\",\n                     into = c(\"area\", \"perimetre\"))\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n\n\n\n  \n\n\n\n\n\n\nThe syntax of separate() is as follows.\n\nCodeseparate(\"data name\",\n         \"column to separate into\",\n         sep = \"the separator element\",\n         into = c(\"col1\", \"col2\", \"........\")) # column names for the separated values\n\n\n\n4.3 separate_rows()\nSimilar to the above case, you can also separate column values into several rows.\n\n\nBefore\nAfter\n\n\n\n\nShow the code# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nshapes <- c(letters[1:4])\narea <- c(paste0(10:13, \"m^2\"))\nperimetre <- c(paste0(30:33, \"m\"))\nratio <-as.data.frame(cbind(shapes,area,perimetre))\ndata <- unite(ratio, area, perimetre, col = \"area_perimetre\", sep = \"_\")\n\n# separating column values into two several rows\ndata_new <- separate_rows(data, area_perimetre, sep = \"_\")\n# viewing data as a table\nrmarkdown::paged_table(data_new)\n\n\n\n  \n\n\n\n\n\n\nThe syntax of separate_rows() is as follows.\n\nCodeseparate_rows(\"data name\",\n         \"column to separate\",\n         sep = \"the separator element\")"
  },
  {
    "objectID": "articles/data_man/project5.html#expanding-and-completing-dataset",
    "href": "articles/data_man/project5.html#expanding-and-completing-dataset",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n5 Expanding and completing dataset",
    "text": "5 Expanding and completing dataset\nYou can expand your data to include all possible combinations of values of variables listed or complete the dataset with NA values for all possible combinations.\n\n5.1 expand()\nUsing the expand() command we can expand our data with missing combinations for the variables we specify.\n\n\nBefore\nAfter\n\n\n\n\nShow the code# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# expanding dataset with brand and dress as variables\ndress_data_expand <- expand(dress_data, brand, dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_expand)\n\n\n\n  \n\n\n\n\n\n\nThe syntax of expand() is as follows.\n\nCodeexpand(\"data name\", \"column names which you want to expand separated by commas\")\n\n\n\n5.2 complete()\nThe complete() command functions similar to the expand() command, but it also fills in NA values for columns which we didn’t specify, The main reason to use this command would be to convert implicit NA values hidden in the dataset to explicit NA values which are expressed in the dataset. Given below is a comparison between the complete() and expand() commands.\n\n\nexpand()\ncomplete()\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# expanding dataset with brand and dress as variables\ndress_data_expand <- expand(dress_data, brand, dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_expand)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\n# completing dataset with brand and dress as variables\n# the variable 'size' will be filled with NAs as we did not specify it\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_complete)\n\n\n\n  \n\n\n\n\n\n\nThe syntax of complete() is as follows.\n\nCodecomplete(\"data name\", \"column names which you want to complete separated by commas\")"
  },
  {
    "objectID": "articles/data_man/project5.html#handling-nas-or-missing-values",
    "href": "articles/data_man/project5.html#handling-nas-or-missing-values",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n6 Handling NAs or missing values",
    "text": "6 Handling NAs or missing values\nMost data collection would often result in possible NA values. The tidyr package allows us to drop or convert NA values. We will reuse the earlier example. Below tabs show before and removing NA values.\n\n6.1 drop_na()\nUse drop_na() to remove NA value containing rows from the dataset.\n\n\nBefore\nAfter\n\n\n\n\nShow the code# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_complete)\n\n\n\n  \n\n\n\n\n\n\nShow the codelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\n\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# dropping NA values\n\ndress_data_noNA <- drop_na(dress_data_complete)\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_noNA)\n\n\n\n  \n\n\n\n\n\n\n\n6.2 fill()\nUse fill() to replace NA values by taking values from nearby cells. By default the NA values as replaced by whatever value that is above the cell containing the NA value. This can be changed by specifying the .direction value within fill()\n\nCodelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# direction 'downup' simultaneously fill both upwards and downwards NA containing cells\ndress_data_fill <- fill(dress_data_complete, size, .direction = \"downup\")\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_fill)\n\n\n\n  \n\n\n\n\n6.3 replace_na()\nUse replace_na() command to replace NA values to whatever value specified.\n\nCodelibrary(tidyr)\n# dummy data\nbrand <- c(letters[1:4])\ndress <- c(\"shirt\", \"pant\", \"jeans\", \"trousers\")\nsize <- c(\"s\", \"m\", \"l\", \"xl\")\ndress_data <- as.data.frame(cbind(brand,dress,size))\ndress_data_complete <- complete(dress_data,brand,dress)\n\n# replace NA to unknown\n# specify the column which have NA inside the list()\n# then equate the value which would replace NAs\ndress_data_zero <- replace_na(dress_data_complete, list(size = \"unknown\"))\n\n# viewing data as a table\nrmarkdown::paged_table(dress_data_zero)"
  },
  {
    "objectID": "articles/data_man/project5.html#summary",
    "href": "articles/data_man/project5.html#summary",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n7 Summary",
    "text": "7 Summary\nSo in this chapter, we learned what is tidy data and how we can make our data into tidy data. Making our data tidy is very important as it helps us to analyse and visualise the data in a very efficient manner. We also learned how to reshape our data, how to split or unite cells, how to complete and expand data and how to handle NA values. Hope this chapter was fruitful for you!"
  },
  {
    "objectID": "articles/data_man/project5.html#references",
    "href": "articles/data_man/project5.html#references",
    "title": "Chapter 1: Data tidying using tidyr",
    "section": "\n8 References",
    "text": "8 References\n\nHadley Wickham (2021). tidyr: Tidy Messy Data. R package version 1.1.4. https://CRAN.R-project.org/package=tidyr\n\nLast updated on\n\n\n[1] \"2022-05-26 07:08:14 IST\""
  },
  {
    "objectID": "articles/stat/project1.html",
    "href": "articles/stat/project1.html",
    "title": "Chapter 1: Introduction to statistics with R",
    "section": "",
    "text": "This article, along with the related articles to this topic, is a culmination of knowledge that I gained during my time in IISER-TVM, when I took the BIO4203 course named Biological Data Analysis offered in 2019. The course was taught to me by Dr. Ravi Maruthachalam who is an excellent teacher and an inspiring researcher. The course helped me immensely by allowing me to understand the core basics of statistics and more importantly, remove any misconceptions about it. I hope I can deliver whatever I learned effectively through the series of articles that will be available regarding this topic, starting with this one.\nThe topics I want to cover include;\n\nIntroduction to statistics\nDistribution and variance\nStandard error and standard deviation\np-value and level of significance\nType I error and type II error\nConfidence interval and effect size\nParametric test and assumptions\nNon-parametric test and assumptions\nTests for multiple groups of data\n\nWith that being said, the articles will be focused on enriching the intuition behind the concepts rather than the pure math behind them. In addition, I will also be explaining how one can do the same tests using R. The articles will be supplemented by published research papers related to the topic."
  },
  {
    "objectID": "articles/stat/project1.html#descriptive-statistics",
    "href": "articles/stat/project1.html#descriptive-statistics",
    "title": "Chapter 1: Introduction to statistics with R",
    "section": "\n2 Descriptive statistics",
    "text": "2 Descriptive statistics\nApplied statistics is broadly categorized into descriptive statistics and inferential statistics. Descriptive statistics deals with the data at hand. It uses different ways to summarise and inspect the data in hand and does not go beyond the data. If the data is for a population then the characteristics used are called parameters. Some of those descriptive parameters include the mean, median, and mode which are used to elucidate the central tendency of the data. For measuring variability, there is a range, quartiles, and standard deviation which we will see later in greater detail."
  },
  {
    "objectID": "articles/stat/project1.html#inferential-statistics",
    "href": "articles/stat/project1.html#inferential-statistics",
    "title": "Chapter 1: Introduction to statistics with R",
    "section": "\n3 Inferential statistics",
    "text": "3 Inferential statistics\nInferential statistics are used to understand patterns of a population using sample data from it. Since collecting data for a population is tedious, we take a sample from that population, which acts as a true representative of the population. Through sampling methods and hypothesis testing, patterns seen within the sample can be extrapolated to the whole population. The characteristics used for sample data are called statistics. Some of the inferential statistics include sample mean, standard deviation, etc.\nLast updated on\n\n\n[1] \"2022-05-26 07:22:44 IST\""
  }
]